<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c22 doc-content">
    <p class="c1 c4"><span class="c6"></span></p>
    <h1 class="c1 c7 c18">Obiecte în funcții. </h1>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c20">Obiect ca rezultat al unei func&#539;ii.</span></p>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c13">Func&#539;iile pot returna obiecte. Acest lucru poate fi util &icirc;n diverse
            situa&#539;ii. S&#259; lu&#259;m, de exemplu, crearea unui obiect &#537;i s&#259; o plas&#259;m &icirc;ntr-o
            func&#539;ie separat&#259;:</span></p>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c4"><span class="c6"></span></p><a id="t.a2405021f27b281b40351f054e173435749ea15d"></a><a id="t.0"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">function</span><span class="c3">&nbsp;</span><span
                        class="c0">createUser</span><span class="c3">(pName, pAge) {<br> &nbsp; &nbsp;</span><span
                        class="c5">return</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;name: pName,<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;age: pAge,<br> &nbsp; &nbsp; &nbsp; &nbsp;print: </span><span
                        class="c5">function</span><span class="c3">() {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c0">console</span><span class="c3">.log(`</span><span class="c9">Nume:
                        ${</span><span class="c5">this</span><span class="c9">.name} &nbsp;V&acirc;rst&#259;:
                        ${</span><span class="c5">this</span><span class="c9">.age}`</span><span class="c3">);<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;};<br>};<br></span><span
                        class="c5">const</span><span class="c3">&nbsp;tom = createUser(</span><span
                        class="c9">&quot;Tom&quot;</span><span class="c3">, </span><span class="c2">26</span><span
                        class="c3">);<br>tom.print();<br></span><span class="c5">const</span><span
                        class="c3">&nbsp;alice = createUser(</span><span class="c9">&quot;Alice&quot;</span><span
                        class="c3">, </span><span class="c2">24</span><span class="c3">);<br>alice.print();</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c13">&Icirc;n acest caz, func&#539;ia createUser() prime&#537;te valorile pName
            &#537;i pAge &#537;i creeaz&#259; un nou obiect pe baza acestora, care este rezultatul returnat. Rezultatul
            programului este:</span></p>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c7"><span class="c6">Nume: Tom &nbsp;V&acirc;rst&#259;: 26</span></p>
    <p class="c1 c7"><span class="c6">Nume: Alice &nbsp;V&acirc;rst&#259;: 24</span></p>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c13">Avantajul externaliz&#259;rii cre&#259;rii obiectului &icirc;ntr-o func&#539;ie
            const&#259; &icirc;n faptul c&#259; ulterior putem crea mai multe obiecte similare cu valori diferite,
            adic&#259; s&#259; func&#539;ion&#259;m ca o fabric&#259; sau un constructor. &Icirc;n plus, &icirc;ntr-o
            astfel de func&#539;ie putem verifica valorile furnizate pentru corectitudine &#537;i, &icirc;n cazul
            &icirc;n care sunt incorecte, putem reac&#539;iona &icirc;n consecin&#539;&#259;.</span></p>
    <p class="c1 c4"><span class="c6"></span></p><a id="t.b2b9992f94a00f8b36e81c866d1d0960e7e974f3"></a><a id="t.1"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">function</span><span class="c3">&nbsp;</span><span
                        class="c0">createUser</span><span class="c3">(pName, pAge) {<br> &nbsp;</span><span
                        class="c5">if</span><span class="c3">&nbsp;(pAge &lt; </span><span class="c2">1</span><span
                        class="c3">&nbsp;|| pAge &gt; </span><span class="c2">110</span><span class="c3">) { &nbsp;
                        &nbsp; &nbsp; </span><span class="c15">// dac&#259; v&acirc;rsta este mai mic&#259; de 1 sau mai
                        mare de 110</span><span class="c3"><br> &nbsp; &nbsp;</span><span class="c0">console</span><span
                        class="c3">.log(</span><span class="c9">&quot;V&acirc;rsta nu este valid&#259;&quot;</span><span
                        class="c3">);<br> &nbsp; &nbsp;pAge = </span><span class="c2">1</span><span class="c3">;<br>
                        &nbsp;}<br> &nbsp;</span><span class="c5">return</span><span class="c3">&nbsp;{<br> &nbsp;
                        &nbsp;name: pName,<br> &nbsp; &nbsp;age: pAge,<br> &nbsp; &nbsp;print: </span><span
                        class="c5">function</span><span class="c3">&nbsp;() {<br> &nbsp; &nbsp; &nbsp;</span><span
                        class="c0">console</span><span class="c3">.log(`</span><span class="c9">Nume: ${</span><span
                        class="c5">this</span><span class="c9">.name} &nbsp;V&acirc;rst&#259;: ${</span><span
                        class="c5">this</span><span class="c9">.age}`</span><span class="c3">);<br> &nbsp; &nbsp;},<br>
                        &nbsp;};<br>}<br><br></span><span class="c5">const</span><span class="c3">&nbsp;tom =
                        createUser(</span><span class="c9">&quot;Tom&quot;</span><span class="c3">, </span><span
                        class="c2">26</span><span class="c3">);<br>tom.print();<br></span><span
                        class="c5">const</span><span class="c3">&nbsp;alice = createUser(</span><span
                        class="c9">&quot;Alice&quot;</span><span class="c3">, </span><span class="c2">12345</span><span
                        class="c3">);<br>alice.print();</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c7"><span class="c16">Aici se verific&#259; parametrul </span><span class="c8">pAge</span><span
            class="c16">, care reprezint&#259; v&acirc;rsta utilizatorului. &Icirc;n mod teoretic, acesta poate fi orice
            num&#259;r, inclusiv unul care dep&#259;&#537;e&#537;te limitele rezonabile, de exemplu, s&#259; fie
            negativ. &Icirc;n acest caz, verific&#259;m dac&#259; </span><span class="c8">pAge </span><span
            class="c16">corespunde acestor limite. Dac&#259; valoarea </span><span class="c8">pAge </span><span
            class="c13">nu corespunde limitei, &icirc;i atribuim o valoare implicit&#259; - &icirc;n acest caz, 1,
            &#537;i afi&#537;&#259;m un mesaj diagnostic &icirc;n consol&#259;. Output-ul programului:</span></p>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c6">Nume: Tom &nbsp;V&acirc;rst&#259;: 26</span></p>
    <p class="c1 c7"><span class="c6">V&acirc;rsta nu este valid&#259;</span></p>
    <p class="c1 c7"><span class="c6">Nume: Alice &nbsp;V&acirc;rst&#259;: 1</span></p>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c13">Returnarea unui obiect poate fi util&#259; atunci c&acirc;nd trebuie s&#259;
            &icirc;ntoarcem dintr-o func&#539;ie mai mult de un rezultat - &icirc;n acest caz, le putem uni
            &icirc;ntr-un singur obiect. De exemplu, o func&#539;ie prime&#537;te un &#537;ir &#537;i g&#259;se&#537;te
            valorile minime &#537;i maxime &icirc;n el:</span></p>
    <p class="c1 c4"><span class="c13"></span></p><a id="t.88ee5551815c22e26450152365100fcf624a5b1e"></a><a
        id="t.2"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">function</span><span class="c3">&nbsp;</span><span
                        class="c0">getMinMax</span><span class="c3">(numbers){<br> <br> &nbsp;</span><span
                        class="c15">// dac&#259; &#537;irul este gol, valorile minime &#537;i maxime nu sunt
                        definite</span><span class="c3"><br> &nbsp;</span><span class="c5">if</span><span
                        class="c3">(numbers.length === </span><span class="c2">0</span><span class="c3">) </span><span
                        class="c5">return</span><span class="c3">&nbsp;{min: </span><span
                        class="c5">undefined</span><span class="c3">, max: </span><span class="c5">undefined</span><span
                        class="c3">};<br> <br> &nbsp;</span><span class="c5">let</span><span class="c3">&nbsp;minNumber
                        = numbers[</span><span class="c2">0</span><span class="c3">];<br> &nbsp;</span><span
                        class="c5">let</span><span class="c3">&nbsp;maxNumber = numbers[</span><span
                        class="c2">0</span><span class="c3">];<br> &nbsp;</span><span class="c5">for</span><span
                        class="c3">(</span><span class="c5">let</span><span class="c3">&nbsp;i=</span><span
                        class="c2">1</span><span class="c3">; i&lt; numbers.length; i++){<br> &nbsp; &nbsp; <br> &nbsp;
                        &nbsp;</span><span class="c5">if</span><span class="c3">(minNumber &gt; numbers[i]) minNumber =
                        numbers[i];<br> &nbsp; &nbsp;</span><span class="c5">if</span><span class="c3">(maxNumber &lt;
                        numbers[i]) maxNumber = numbers[i];<br> &nbsp;}<br> &nbsp;</span><span
                        class="c5">return</span><span class="c3">&nbsp;{min: minNumber, max: maxNumber};<br>}<br>
                        <br></span><span class="c5">const</span><span class="c3">&nbsp;nums = [</span><span
                        class="c2">1</span><span class="c3">, </span><span class="c2">2</span><span class="c3">,
                    </span><span class="c2">3</span><span class="c3">, </span><span class="c2">4</span><span
                        class="c3">, </span><span class="c2">5</span><span class="c3">];<br></span><span
                        class="c5">const</span><span class="c3">&nbsp;result = getMinMax(nums);<br></span><span
                        class="c0">console</span><span class="c3">.log(</span><span
                        class="c9">&quot;Min:&quot;</span><span class="c3">, result.min); &nbsp; &nbsp;</span><span
                        class="c15">// Min: 1</span><span class="c3"><br></span><span class="c0">console</span><span
                        class="c3">.log(</span><span class="c9">&quot;Max:&quot;</span><span class="c3">, result.max);
                        &nbsp; &nbsp;</span><span class="c15">// Max: 5</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c7"><span class="c13">Aici, &icirc;n func&#539;ia getMinMax, primim un &#537;ir. Dac&#259; &#537;irul
            nu con&#539;ine numere, return&#259;m un obiect &icirc;n care c&acirc;mpurile min &#537;i max au valori
            nedefinite. &Icirc;n caz contrar, parcurgem &icirc;ntregul &#537;ir &#537;i calcul&#259;m valorile maxime
            &#537;i minime, &icirc;ntorc&acirc;ndu-le sub forma unui singur obiect.</span></p>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c7"><span class="c20">Obiectul ca parametru.</span></p>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c13">La fel ca &#537;i celelalte valori, un obiect poate fi transmis ca parametru
            c&#259;tre o func&#539;ie.</span></p>
    <p class="c1 c4"><span class="c6"></span></p><a id="t.23bafb7a18c9246d09fd1c5b81ce43c7a8f09a14"></a><a id="t.3"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">function</span><span class="c3">&nbsp;</span><span
                        class="c0">printPerson</span><span class="c3">(person){<br> <br> &nbsp;</span><span
                        class="c0">console</span><span class="c3">.log(</span><span
                        class="c9">&quot;Name:&quot;</span><span class="c3">, person.name);<br> &nbsp;</span><span
                        class="c0">console</span><span class="c3">.log(</span><span
                        class="c9">&quot;Age:&quot;</span><span class="c3">, person.age);<br>}<br> <br></span><span
                        class="c5">const</span><span class="c3">&nbsp;tom = {name: </span><span
                        class="c9">&quot;Tom&quot;</span><span class="c3">, age: </span><span class="c2">39</span><span
                        class="c3">};<br></span><span class="c5">const</span><span class="c3">&nbsp;alice = {name:
                    </span><span class="c9">&quot;Alice&quot;</span><span class="c3">, age: </span><span
                        class="c2">35</span><span class="c3">};<br> <br>printPerson(tom);<br>printPerson(alice);</span>
                </p>
            </td>
        </tr>
    </table>
    <p class="c1 c4"><span class="c6"></span></p>
    <p class="c1 c7"><span class="c13">&Icirc;n acest exemplu, func&#539;ia printPerson prime&#537;te un obiect,
            presupun&acirc;nd c&#259; acesta are dou&#259; propriet&#259;&#539;i: name &#537;i age.</span></p>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c7"><span class="c13">Trebuie s&#259; re&#539;inem c&#259; obiectele sunt tipuri de date
            referen&#539;iale, iar variabila/constant&#259;/parametrul care reprezint&#259; obiectul stocheaz&#259; de
            fapt o referin&#539;&#259; c&#259;tre obiect &icirc;n memorie, nu obiectul &icirc;n sine. Prin urmare,
            atunci c&acirc;nd un obiect este transmis ca argument c&#259;tre o func&#539;ie, se transmite o copie a
            referin&#539;ei c&#259;tre acel obiect. &#536;i prin intermediul acestei referin&#539;e, func&#539;ia poate
            modifica diverse propriet&#259;&#539;i ale obiectului.</span></p>
    <p class="c1 c4"><span class="c13"></span></p><a id="t.7199344fc9dfb8c2ffe67ab48c5b795274836cd8"></a><a
        id="t.4"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">function</span><span class="c3">&nbsp;</span><span
                        class="c0">setAge</span><span class="c3">(person, pAge){<br> <br> &nbsp;person.age =
                        pAge;<br>}<br> <br></span><span class="c5">const</span><span class="c3">&nbsp;sam = {name:
                    </span><span class="c9">&quot;Sam&quot;</span><span class="c3">, age: </span><span
                        class="c2">29</span><span class="c3">};<br></span><span class="c0">console</span><span
                        class="c3">.log(</span><span class="c9">&quot;Before setAge:&quot;</span><span class="c3">,
                        sam.age);<br>setAge(sam, </span><span class="c2">30</span><span class="c3">);<br></span><span
                        class="c0">console</span><span class="c3">.log(</span><span class="c9">&quot;After
                        setAge:&quot;</span><span class="c3">, sam.age);</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c4"><span class="c13"></span></p>
    <p class="c1 c7"><span class="c13">Aici, mai &icirc;nt&acirc;i definim constanta sam, care reprezint&#259; un obiect
            cu propriet&#259;&#539;ile name &#537;i age:</span></p>
    <p class="c1 c4"><span class="c13"></span></p><a id="t.d6572210dff5fec71652fbe32fd36103adf4a45f"></a><a
        id="t.5"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">const</span><span class="c3">&nbsp;sam = {name: </span><span
                        class="c9">&quot;Sam&quot;</span><span class="c3">, age: </span><span class="c2">29</span><span
                        class="c3">};</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c14"><span class="c13"></span></p>
    <p class="c1"><span class="c13">De fapt, constanta sam stocheaz&#259; o referin&#539;&#259; la zona de memorie
            &icirc;n care este plasat obiectul.</span></p>
    <p class="c1 c14"><span class="c13"></span></p>
    <p class="c1"><span class="c13">Apel&#259;m apoi func&#539;ia setAge, care prime&#537;te obiectul person &#537;i
            &icirc;i schimb&#259; proprietatea age.</span></p>
    <p class="c1 c14"><span class="c13"></span></p><a id="t.ec521ce9826bfad724dba30720cf48418e9747da"></a><a
        id="t.6"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c3">setAge(sam, </span><span class="c2">30</span><span class="c3">);</span>
                </p>
            </td>
        </tr>
    </table>
    <p class="c1 c14"><span class="c13"></span></p>
    <p class="c1"><span class="c13">Deoarece obiectele sunt transmise prin referin&#539;&#259;, func&#539;ia setAge
            prime&#537;te o copie a referin&#539;ei stocate &icirc;n constanta sam. Prin urmare, dup&#259; aceasta,
            constanta sam &#537;i primul parametru al func&#539;iei setAge vor reprezenta dou&#259; referin&#539;e
            diferite, dar vor indica c&#259;tre acela&#537;i obiect &icirc;n memorie. Prin urmare, dac&#259;
            modific&#259;m proprietatea acestui obiect &icirc;n interiorul func&#539;iei setAge, atunci acces&acirc;nd
            proprietatea obiectului sam aceasta se va schimba &#537;i ea, deoarece, &icirc;n realitate, este
            acela&#537;i obiect. &Icirc;n final, browserul va afi&#537;a:</span></p>
    <p class="c1 c14"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Before setAge: 29</span></p>
    <p class="c17"><span class="c21">After setAge: 30</span></p>
    <p class="c19"><span class="c13">Dar dac&#259; alt obiect este atribuit parametrului &icirc;n interiorul
            func&#539;iei, atunci referin&#539;a schimb&#259; efectiv valoarea sa &#537;i &icirc;ncepe s&#259; indice
            c&#259;tre o alt&#259; zon&#259; de memorie:</span></p>
    <p class="c1 c14"><span class="c13"></span></p><a id="t.7679dfda5e50f2935e8cff679aaca5fec5c0b16a"></a><a
        id="t.7"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c5">function</span><span class="c3">&nbsp;</span><span
                        class="c0">setDefault</span><span class="c3">(person){<br> <br> &nbsp;person = {name:
                    </span><span class="c9">&quot;Undefined&quot;</span><span class="c3">, age: </span><span
                        class="c2">0</span><span class="c3">};<br>}<br> <br></span><span class="c5">let</span><span
                        class="c3">&nbsp;sam = {name: </span><span class="c9">&quot;Sam&quot;</span><span class="c3">,
                        age: </span><span class="c2">29</span><span class="c3">};<br></span><span
                        class="c0">console</span><span class="c3">.log(</span><span class="c9">&quot;Before
                        setDefault:&quot;</span><span class="c3">, sam.name);<br>setDefault(sam);<br></span><span
                        class="c0">console</span><span class="c3">.log(</span><span class="c9">&quot;After
                        setDefault:&quot;</span><span class="c3">, sam.name);</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c14"><span class="c13"></span></p>
    <p class="c1"><span class="c16">La transmiterea variabilei </span><span class="c8">sam </span><span
            class="c16">&icirc;n func&#539;ia </span><span class="c8">setDefault</span><span class="c16">, parametrul
            acestei func&#539;ii &#537;i variabila </span><span class="c8">sam </span><span class="c13">vor reprezenta
            dou&#259; link-uri diferite, dar vor indica c&#259;tre acela&#537;i obiect &icirc;n memorie:</span></p>
    <p class="c1 c14"><span class="c13"></span></p><a id="t.52fb7473ebcf33a7bd37d4672978caa3d3de0017"></a><a
        id="t.8"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c3">setDefault(sam);</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c14"><span class="c13"></span></p>
    <p class="c1"><span class="c13">Dar apoi, &icirc;n interiorul func&#539;iei, schimb&#259;m valoarea
            parametrului:</span></p>
    <p class="c1 c14"><span class="c13"></span></p><a id="t.b289ce64a3afffdf0a4cc76a488e373fa98963a2"></a><a
        id="t.9"></a>
    <table class="c10">
        <tr class="c12">
            <td class="c11" colspan="1" rowspan="1">
                <p class="c1"><span class="c3">person = {name: </span><span class="c9">&quot;Undefined&quot;</span><span
                        class="c3">, age: </span><span class="c2">0</span><span class="c3">};</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c14"><span class="c13"></span></p>
    <p class="c1"><span class="c16">&Icirc;n final, referin&#539;ei stocate &icirc;n parametrul </span><span
            class="c8">person </span><span class="c16">i se atribuie un nou obiect. Dar deoarece variabila </span><span
            class="c8">sam </span><span class="c16">&#537;i parametrul </span><span class="c8">person </span><span
            class="c16">reprezint&#259; dou&#259; link-uri diferite, aceast&#259; atribuire nu va afecta &icirc;n niciun
            fel obiectul </span><span class="c8">sam</span><span class="c13">.</span></p>
    <p class="c1 c14"><span class="c13"></span></p>
</body>

</html>