<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c17 doc-content">
    <h1 class="c9 c18">Obținerea rezultatului operației într-un Promise. </h1>
    <p class="c8"><span class="c11"></span></p>
    <p class="c9"><span class="c5">Anterior, am examinat cum putem transmite rezultatul unei opera&#539;iuni asincrone
            dintr-o func&#539;ie promise:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.782ceef57501563496d28ff15be56ee7b4bdc566"></a><a id="t.0"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">const</span><span class="c0">&nbsp;myPromise = </span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(resolve){<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;Executarea opera&#539;iunii asincrone&quot;</span><span class="c0">);<br>
                        &nbsp; &nbsp;resolve(</span><span class="c7 c14">&quot;Salut lume!&quot;</span><span
                        class="c0">);<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Acum s&#259; ob&#539;inem aceast&#259; valoare. Pentru a ob&#539;ine rezultatul
            opera&#539;iei unui promise se utilizeaz&#259; func&#539;ia</span><span class="c16">&nbsp;then()</span><span
            class="c7">&nbsp;a obiectului </span><span class="c1">Promise</span><span class="c5">:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.cef816fbd44cc15cebf66bbe90081c2a9341d088"></a><a id="t.1"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">then(onFulfilled, onRejected);</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Primul parametru al func&#539;iei -</span><span
            class="c1">&nbsp;onFulfilled</span><span class="c5">&nbsp;reprezint&#259; func&#539;ia care se execut&#259;
            la finalizarea cu succes a promise-ului &#537;i prime&#537;te ca parametru datele transmise &icirc;n
            resolve().</span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Al doilea parametru al func&#539;iei -</span><span
            class="c1">&nbsp;onRejected</span><span class="c7">&nbsp;reprezint&#259; func&#539;ia care se execut&#259;
            la apari&#539;ia unei erori &#537;i prime&#537;te ca parametru datele transmise &icirc;n </span><span
            class="c1">reject()</span><span class="c5">.</span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Func&#539;ia </span><span class="c16">then()</span><span
            class="c7">&nbsp;returneaz&#259; de asemenea un obiect </span><span class="c1">Promise</span><span
            class="c5">.</span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">Astfel, ob&#539;inem datele transmise:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.102c17d8d2f906dd6a004a2a13d2e0d55d2b533f"></a><a id="t.2"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">const</span><span class="c0">&nbsp;myPromise = </span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(resolve){<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;Executarea opera&#539;iunii asincrone&quot;</span><span class="c0">);<br>
                        &nbsp; &nbsp;resolve(</span><span class="c7 c14">&quot;Salut lume!&quot;</span><span
                        class="c0">);<br>});<br>myPromise.then(</span><span class="c4">function</span><span
                        class="c0">(value){<br> &nbsp; &nbsp;</span><span class="c2">console</span><span
                        class="c0">.log(</span><span class="c7 c14">`Date ob&#539;inute din promise:
                        ${value}`</span><span class="c0">);<br>})</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Adic&#259;, parametrul </span><span class="c1">value </span><span class="c7">aici va
            reprezenta &#537;irul &quot;</span><span class="c1">Salut lume!</span><span class="c7">&quot;, care este
            transmis &icirc;n resolve(&quot;</span><span class="c1">Salut lume!</span><span class="c5">&quot;). &Icirc;n
            final, ie&#537;irea &icirc;n consol&#259; va ar&#259;ta astfel:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.c661e9be380a20d320e4a6b5cc75ca4c66a2a81c"></a><a id="t.3"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">Executarea opera&#539;iunii asincrone<br></span><span
                        class="c2">Date</span><span class="c0">&nbsp;ob&#539;inute din promise: Salut lume!</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">Pentru exemplu, s&#259; apel&#259;m mai multe promise-uri, pentru a vedea
            asincronitatea &icirc;n ac&#539;iune:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.b6042cb256568d5fb5e1676eb05fcbe730e81ba6"></a><a id="t.4"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">const</span><span class="c0">&nbsp;myPromise3000 = </span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(resolve){<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;[myPromise3000] Executarea opera&#539;iunii asincrone&quot;</span><span
                        class="c0">);<br> &nbsp; &nbsp;setTimeout(()=&gt;{resolve(</span><span
                        class="c7 c14">&quot;[myPromise3000] Salut lume!&quot;</span><span class="c0">)}, </span><span
                        class="c7 c13">3000</span><span class="c0">);<br>});<br></span><span
                        class="c4">const</span><span class="c0">&nbsp;myPromise1000 = </span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(resolve){<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;[myPromise1000] Executarea opera&#539;iunii asincrone&quot;</span><span
                        class="c0">);<br> &nbsp; &nbsp;setTimeout(()=&gt;{resolve(</span><span
                        class="c7 c14">&quot;[myPromise1000] Salut lume!&quot;</span><span class="c0">)}, </span><span
                        class="c7 c13">1000</span><span class="c0">);<br>});<br></span><span
                        class="c4">const</span><span class="c0">&nbsp;myPromise2000 = </span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(resolve){<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;[myPromise2000] Executarea opera&#539;iunii asincrone&quot;</span><span
                        class="c0">);<br> &nbsp; &nbsp;setTimeout(()=&gt;{resolve(</span><span
                        class="c7 c14">&quot;[myPromise2000] Salut lume!&quot;</span><span class="c0">)}, </span><span
                        class="c7 c13">2000</span><span class="c0">);<br>});<br>
                        <br>myPromise3000.then((value)=&gt;</span><span class="c2">console</span><span
                        class="c0">.log(value));<br>myPromise1000.then((value)=&gt;</span><span
                        class="c2">console</span><span
                        class="c0">.log(value));<br>myPromise2000.then((value)=&gt;</span><span
                        class="c2">console</span><span class="c0">.log(value));</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">Aici sunt definite trei promise-uri identice. Pentru ca fiecare dintre ele s&#259; nu
            se execute imediat, folosesc func&#539;ia setTimeout &#537;i stabilesc valoarea returnat&#259; doar
            dup&#259; c&acirc;teva secunde. Durata &icirc;nt&acirc;rzierii variaz&#259; pentru diferite promise-uri.
            &#536;i &icirc;n acest caz vom ob&#539;ine urm&#259;toarea ie&#537;ire &icirc;n consol&#259;:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.2066a8c7f864e757d7fa95a1bee013f84c338d1a"></a><a id="t.5"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">[myPromise3000] Executarea opera&#539;iunii asincrone<br>[myPromise1000]
                        Executarea opera&#539;iunii asincrone<br>[myPromise2000] Executarea opera&#539;iunii
                        asincrone<br>[myPromise1000] Salut lume!<br>[myPromise2000] Salut lume!<br>[myPromise3000] Salut
                        lume!</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">Aici vedem c&#259; primul a &icirc;nceput s&#259; se execute promise-ul
            myPromise3000, dar el s-a &#537;i terminat ultimul, deoarece pentru el este stabilit cel mai lung timp de
            &icirc;nt&acirc;rziere - 3 secunde. Totu&#537;i, &icirc;nt&acirc;rzierea sa nu a &icirc;mpiedicat executarea
            celorlalte promise-uri.</span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">&Icirc;n acela&#537;i timp, nu este necesar s&#259; transmitem &icirc;n </span><span
            class="c1">resolve()</span><span class="c5">&nbsp;nicio valoare. Poate opera&#539;iunea asincron&#259; se
            execut&#259; pur &#537;i simplu &#537;i nu transmite niciun rezultat &icirc;n exterior.</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.5282a9a63ce62a4c72cbd5c58494486d7c73fea8"></a><a id="t.6"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">const</span><span class="c0">&nbsp;x = </span><span
                        class="c7 c13">4</span><span class="c0">;<br></span><span class="c4">const</span><span
                        class="c0">&nbsp;y = </span><span class="c7 c13">8</span><span class="c0">;<br></span><span
                        class="c4">const</span><span class="c0">&nbsp;myPromise = </span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(){<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;Executarea opera&#539;iunii asincrone&quot;</span><span class="c0">);<br>
                        &nbsp; &nbsp;</span><span class="c4">const</span><span class="c0">&nbsp;z = x + y;<br> &nbsp;
                        &nbsp;</span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">`Rezultatul opera&#539;iunii: ${z}`</span><span
                        class="c0">)<br>});<br>myPromise.then();</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">&Icirc;n acest caz, func&#539;ia din promise calculeaz&#259; suma numerelor x &#537;i
            y &#537;i afi&#537;eaz&#259; rezultatul &icirc;n consol&#259;.</span></p>
    <p class="c8"><span class="c11"></span></p>
    <p class="c9"><span class="c12">Metoda Promise.resolve.</span></p>
    <p class="c8"><span class="c11"></span></p>
    <p class="c9"><span class="c7">Uneori este necesar s&#259; return&#259;m pur &#537;i simplu dintr-un promise o
            anumit&#259; valoare. Pentru aceasta se poate folosi metoda </span><span
            class="c16">Promise.resolve()</span><span class="c7">. &Icirc;n aceast&#259; metod&#259; se transmite
            valoarea returnat&#259; din promise. Metoda </span><span class="c16">Promise.resolve()</span><span
            class="c5">&nbsp;returneaz&#259; un obiect Promise:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.22d1d10d678f1874b9e30e428f84ae7dea71deb3"></a><a id="t.7"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">const</span><span class="c0">&nbsp;myPromise = </span><span
                        class="c2">Promise</span><span class="c0">.resolve(</span><span class="c7 c14">&quot;Salut
                        lume!&quot;</span><span class="c0">);<br> <br>myPromise.then(value =&gt; </span><span
                        class="c2">console</span><span class="c0">.log(value)); &nbsp; &nbsp; </span><span
                        class="c7 c19">// Salut lume!</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c11">Definirea unui promise prin intermediul unei func&#539;ii.</span></p>
    <p class="c8"><span class="c11"></span></p>
    <p class="c9"><span class="c5">Adesea, un promise este definit printr-o func&#539;ie care returneaz&#259; un obiect
            Promise. De exemplu:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.d2a3001845b3f0d4a95998ffa8603f2c0753cd91"></a><a id="t.8"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">function</span><span class="c0">&nbsp;</span><span
                        class="c2">sum</span><span class="c0">(x, y){ <br> &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c0">&nbsp;</span><span class="c4">new</span><span
                        class="c0">&nbsp;</span><span class="c2">Promise</span><span class="c0">(</span><span
                        class="c4">function</span><span class="c0">(resolve){<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c4">const</span><span class="c0">&nbsp;result = x + y;<br> &nbsp;
                        &nbsp; &nbsp; &nbsp;resolve(result);<br> &nbsp; &nbsp;})<br>}<br>sum(</span><span
                        class="c7 c13">3</span><span class="c0">, </span><span class="c7 c13">5</span><span
                        class="c0">).then(</span><span class="c4">function</span><span class="c0">(value){ </span><span
                        class="c2">console</span><span class="c0">.log(</span><span class="c7 c14">&quot;Rezultatul
                        opera&#539;iunii:&quot;</span><span class="c0">, value);});<br>sum(</span><span
                        class="c7 c13">25</span><span class="c0">, </span><span class="c7 c13">4</span><span
                        class="c0">).then(</span><span class="c4">function</span><span class="c0">(value){ </span><span
                        class="c2">console</span><span class="c0">.log(</span><span class="c7 c14">&quot;Suma
                        numerelor:&quot;</span><span class="c0">, value);});</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Aici, func&#539;ia </span><span class="c1">sum() </span><span class="c7">accept&#259;
            dou&#259; numere &#537;i returneaz&#259; un promise care &icirc;ncapsuleaz&#259; opera&#539;ia de adunare a
            acestor numere. Dup&#259; calcularea sumei, aceasta este transmis&#259; &icirc;n </span><span
            class="c1">resolve()</span><span class="c7">, astfel &icirc;nc&acirc;t ulterior o putem ob&#539;ine prin
            metoda</span><span class="c1">&nbsp;then()</span><span class="c5">. Definirea unui promise printr-o
            func&#539;ie ne permite, pe de o parte, s&#259; transmitem diferite valori la apelul func&#539;iei. Iar pe
            de alt&#259; parte, s&#259; lucr&#259;m cu rezultatul acestei func&#539;ii ca &#537;i cum ar fi un promise
            &#537;i s&#259; configur&#259;m la fiecare apel concret procesarea valorii ob&#539;inute.</span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">Rezultatul execu&#539;iei programului:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.18e145cb27c05a72261d1abd6ae3955348c6c329"></a><a id="t.9"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">Rezultatul opera&#539;iunii: </span><span class="c7 c13">8</span><span
                        class="c0"><br>Suma numerelor: </span><span class="c7 c13">29</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c5">Totu&#537;i, ce se &icirc;nt&acirc;mpl&#259; dac&#259; avem acela&#537;i principiu de
            procesare a valorii ob&#539;inute dintr-o func&#539;ie asincron&#259;?</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.83890f0d7ebb4615c4e2556f2cd24ef07dfe4956"></a><a id="t.10"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">sum(</span><span class="c7 c13">3</span><span class="c0">, </span><span
                        class="c7 c13">5</span><span class="c0">).then(</span><span class="c4">function</span><span
                        class="c0">(value){ </span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;Rezultatul opera&#539;iunii:&quot;</span><span class="c0">,
                        value);});<br>sum(</span><span class="c7 c13">25</span><span class="c0">, </span><span
                        class="c7 c13">4</span><span class="c0">).then(</span><span class="c4">function</span><span
                        class="c0">(value){ </span><span class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;Rezultatul opera&#539;iunii:&quot;</span><span class="c0">,
                        value);});</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">&Icirc;n acest caz, logica de procesare se va repeta. Dar, deoarece
            metoda</span><span class="c1">&nbsp;then()</span><span class="c5">&nbsp;returneaz&#259; de asemenea un
            obiect Promise, putem proceda &icirc;n felul urm&#259;tor:</span></p>
    <p class="c8"><span class="c5"></span></p><a id="t.a3d47ae4714c0c86214015f2e3122d1efd97e1dd"></a><a id="t.11"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">function</span><span class="c0">&nbsp;</span><span
                        class="c2">sum</span><span class="c0">(x, y){ <br> &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c0">&nbsp;</span><span class="c4">new</span><span
                        class="c0">&nbsp;</span><span class="c2">Promise</span><span class="c0">(</span><span
                        class="c4">function</span><span class="c0">(resolve){<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c4">const</span><span class="c0">&nbsp;result = x + y;<br> &nbsp;
                        &nbsp; &nbsp; &nbsp;resolve(result);<br> &nbsp; &nbsp;}).then(</span><span
                        class="c4">function</span><span class="c0">(value){ </span><span class="c2">console</span><span
                        class="c0">.log(</span><span class="c7 c14">&quot;Rezultatul opera&#539;iunii:&quot;</span><span
                        class="c0">, value);});<br>}<br>sum(</span><span class="c7 c13">3</span><span class="c0">,
                    </span><span class="c7 c13">5</span><span class="c0">);<br>sum(</span><span
                        class="c7 c13">25</span><span class="c0">, </span><span class="c7 c13">4</span><span
                        class="c0">);</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c12">Configurare flexibil&#259; a func&#539;iei.</span></p>
    <p class="c8"><span class="c11"></span></p>
    <p class="c9"><span class="c5">&#536;i ce se &icirc;nt&acirc;mpl&#259; dac&#259; dorim ca programatorul s&#259;
            aib&#259; posibilitatea de alegere: dac&#259; dore&#537;te, poate s&#259; defineasc&#259; propriul handler,
            iar dac&#259; nu, se aplic&#259; un handler implicit. &Icirc;n acest caz, putem defini func&#539;ia handler
            ca parametru al func&#539;iei, iar dac&#259; nu este transmis, s&#259; stabilim handlerul implicit:</span>
    </p>
    <p class="c8"><span class="c5"></span></p><a id="t.62767b4e15ea2ffbfae85df4d46c622a44ebd5fc"></a><a id="t.12"></a>
    <table class="c6">
        <tr class="c15">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c10"><span class="c4">function</span><span class="c0">&nbsp;</span><span
                        class="c2">sum</span><span class="c0">(x, y, func){ <br> &nbsp; &nbsp;</span><span
                        class="c7 c19">// dac&#259; handlerul nu este stabilit, atunci stabilim handlerul
                        implicit</span><span class="c0"><br> &nbsp; &nbsp;</span><span class="c4">if</span><span
                        class="c0">(func===</span><span class="c4">undefined</span><span class="c0">) func =
                    </span><span class="c4">function</span><span class="c0">(value){ </span><span
                        class="c2">console</span><span class="c0">.log(</span><span class="c7 c14">&quot;Rezultatul
                        opera&#539;iunii:&quot;</span><span class="c0">, value);};<br> &nbsp; &nbsp; <br> &nbsp;
                        &nbsp;</span><span class="c4">return</span><span class="c0">&nbsp;</span><span
                        class="c4">new</span><span class="c0">&nbsp;</span><span class="c2">Promise</span><span
                        class="c0">(</span><span class="c4">function</span><span class="c0">(resolve){<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">const</span><span class="c0">&nbsp;result = x + y;<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;resolve(result);<br> &nbsp;
                        &nbsp;}).then(func);<br>}<br>sum(</span><span class="c7 c13">3</span><span class="c0">,
                    </span><span class="c7 c13">5</span><span class="c0">);<br>sum(</span><span
                        class="c7 c13">25</span><span class="c0">, </span><span class="c7 c13">4</span><span
                        class="c0">, </span><span class="c4">function</span><span class="c0">(value){ </span><span
                        class="c2">console</span><span class="c0">.log(</span><span
                        class="c7 c14">&quot;Suma:&quot;</span><span class="c0">, value);});</span></p>
            </td>
        </tr>
    </table>
    <p class="c8"><span class="c5"></span></p>
    <p class="c9"><span class="c7">Aici, la prima apelare a func&#539;iei </span><span class="c1">sum() (sum(3,
            5))</span><span class="c7">, va ac&#539;iona handlerul implicit. &Icirc;n al doilea caz, handlerul este
            transmis explicit prin al treilea parametru, respectiv el va fi utilizat</span><span
            class="c1">&nbsp;sum(25, 4, function(value){ console.log(&quot;Suma:&quot;, value);})</span><span
            class="c5">.</span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c8"><span class="c5"></span></p>
    <p class="c8"><span class="c5"></span></p>
</body>

</html>