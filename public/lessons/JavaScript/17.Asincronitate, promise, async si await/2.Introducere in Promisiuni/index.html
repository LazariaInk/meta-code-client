<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c18 doc-content">
    <h1 class="c7 c20">Introducere Ã®n Promisiuni. </h1>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c8">O </span><span class="c12">promisiune </span><span class="c8">(</span><span
            class="c12">promise</span><span class="c0">) este un obiect care reprezint&#259; rezultatul final (fie
            succes, fie e&#537;ec) al unei opera&#539;iuni asincrone. Simplificat, o opera&#539;iune asincron&#259; este
            o ac&#539;iune care se execut&#259; independent de codul &icirc;nconjur&#259;tor care o apeleaz&#259;
            &#537;i nu blocheaz&#259; execu&#539;ia codului care o cheam&#259;.</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">O promisiune poate fi &icirc;n una dintre urm&#259;toarele st&#259;ri:</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <ul class="c19 lst-kix_wqj32w42eoo8-0 start">
        <li class="c7 c14 c21 li-bullet-0"><span class="c8">Starea de a&#537;teptare (</span><span
                class="c12">pending</span><span class="c0">): Este starea ini&#539;ial&#259;, promisiunea a fost
                creat&#259;, dar execu&#539;ia nu a fost &icirc;nc&#259; finalizat&#259;.</span></li>
    </ul>
    <p class="c7 c11 c14"><span class="c0"></span></p>
    <ul class="c19 lst-kix_wqj32w42eoo8-0">
        <li class="c7 c14 c21 li-bullet-0"><span class="c8">Starea &icirc;ndeplinit&#259; (</span><span
                class="c12">fulfilled</span><span class="c0">): Ac&#539;iunea pe care o reprezint&#259; promisiunea a
                fost finalizat&#259; cu succes.</span></li>
    </ul>
    <p class="c7 c11 c14"><span class="c0"></span></p>
    <ul class="c19 lst-kix_wqj32w42eoo8-0">
        <li class="c7 c14 c21 li-bullet-0"><span class="c8">Starea respins&#259; (</span><span
                class="c12">rejected</span><span class="c0">): A ap&#259;rut o eroare &icirc;n timpul execu&#539;iei
                ac&#539;iunii pe care o reprezint&#259; promisiunea.</span></li>
    </ul>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c8">Pentru a crea o promisiune se folose&#537;te constructorul </span><span
            class="c12">Promise</span><span class="c0">:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.bacf551d4175cfe32337a00fd5a96a67791d1e3f"></a><a
        id="t.0"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">new</span><span class="c3">&nbsp;</span><span
                        class="c5">Promise</span><span class="c3">(executor)</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Constructorul accept&#259; o func&#539;ie ca parametru, func&#539;ie care este
            executat&#259; la crearea promisiunii. De obicei, aceast&#259; func&#539;ie reprezint&#259; opera&#539;iuni
            asincrone care necesit&#259; timp. De exemplu, s&#259; definim cea mai simpl&#259; promisiune:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.75193f60da6280863aa9d89103b61c9f4c0bec87"></a><a
        id="t.1"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;myPromise = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(){<br> &nbsp;
                        &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;Executarea unei opera&#539;iuni asincrone&quot;</span><span
                        class="c3">);<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Aici, func&#539;ia pur &#537;i simplu afi&#537;eaz&#259; un mesaj pe consol&#259;.
            Astfel, la executarea acestui cod, vom vedea mesajul &quot;Executarea unei opera&#539;iuni asincrone&quot;
            pe consol&#259;.</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">C&acirc;nd se creeaz&#259; o promisiune &#537;i func&#539;ia acesteia &icirc;nc&#259;
            nu a &icirc;nceput s&#259; se execute, promisiunea trece &icirc;n starea &quot;pending&quot;, adic&#259;
            a&#537;teapt&#259; s&#259; fie executat&#259;.</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Pentru a emula asincronitatea, s&#259; definim c&acirc;teva promisiuni:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.370c54061b486c47a91c75163c6e0f3db165db70"></a><a
        id="t.2"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;myPromise3000 = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(){<br> &nbsp;
                        &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;[myPromise3000] Executarea unei opera&#539;iuni asincrone&quot;</span><span
                        class="c3">);<br> &nbsp; &nbsp;setTimeout(()=&gt;</span><span class="c5">console</span><span
                        class="c3">.log(</span><span class="c1">&quot;[myPromise3000] Finalizarea unei opera&#539;iuni
                        asincrone&quot;</span><span class="c3">), </span><span class="c8 c10">3000</span><span
                        class="c3">);<br>});<br></span><span class="c2">const</span><span class="c3">&nbsp;myPromise1000
                        = </span><span class="c2">new</span><span class="c3">&nbsp;</span><span
                        class="c5">Promise</span><span class="c3">(</span><span class="c2">function</span><span
                        class="c3">(){<br> &nbsp; &nbsp;</span><span class="c5">console</span><span
                        class="c3">.log(</span><span class="c1">&quot;[myPromise1000] Executarea unei opera&#539;iuni
                        asincrone&quot;</span><span class="c3">);<br> &nbsp; &nbsp;setTimeout(()=&gt;</span><span
                        class="c5">console</span><span class="c3">.log(</span><span class="c1">&quot;[myPromise1000]
                        Finalizarea unei opera&#539;iuni asincrone&quot;</span><span class="c3">), </span><span
                        class="c8 c10">1000</span><span class="c3">);<br>});<br></span><span
                        class="c2">const</span><span class="c3">&nbsp;myPromise2000 = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(){<br> &nbsp;
                        &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;[myPromise2000] Executarea unei opera&#539;iuni asincrone&quot;</span><span
                        class="c3">);<br> &nbsp; &nbsp;setTimeout(()=&gt;</span><span class="c5">console</span><span
                        class="c3">.log(</span><span class="c1">&quot;[myPromise2000] Finalizarea unei opera&#539;iuni
                        asincrone&quot;</span><span class="c3">), </span><span class="c8 c10">2000</span><span
                        class="c3">);<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Aici sunt definite trei promisiuni identice. Pentru ca fiecare dintre ele s&#259; nu
            se execute imediat, folosesc func&#539;ia setTimeout cu o &icirc;nt&acirc;rziere de c&acirc;teva secunde.
            Durata &icirc;nt&acirc;rzierii difer&#259; pentru diferite promisiuni. &#536;i &icirc;n acest caz, vom
            ob&#539;ine urm&#259;torul output pe consol&#259;:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.a85b1fa7aaa93a3da30de507a1893d8ea5f0c8b1"></a><a
        id="t.3"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c3">[myPromise3000] Executarea unei opera&#539;iuni
                        asincrone<br>[myPromise1000] Executarea unei opera&#539;iuni asincrone<br>[myPromise2000]
                        Executarea unei opera&#539;iuni asincrone<br>[myPromise1000] Finalizarea unei opera&#539;iuni
                        asincrone<br>[myPromise2000] Finalizarea unei opera&#539;iuni asincrone<br>[myPromise3000]
                        Finalizarea unei opera&#539;iuni asincrone</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Aici vedem c&#259; primul a &icirc;nceput s&#259; se execute promisiunea
            myPromise3000, dar a &#537;i finalizat ultima, deoarece are cel mai mare timp de &icirc;nt&acirc;rziere - 3
            secunde. Totu&#537;i, &icirc;nt&acirc;rzierea sa nu a &icirc;mpiedicat executarea celorlalte
            promisiuni.</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c17">resolve &#537;i reject.</span></p>
    <p class="c7 c11"><span class="c6"></span></p>
    <p class="c7"><span class="c0">De obicei, func&#539;ia care este transmis&#259; constructorului Promise accept&#259;
            dou&#259; parametri:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.fb6e1232f2691d4214ac6557928e15c901e0fa56"></a><a
        id="t.4"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;myPromise = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(resolve, reject){<br>
                        &nbsp; &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;Executarea unei opera&#539;iuni asincrone&quot;</span><span
                        class="c3">);<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Ambii parametri - resolve &#537;i reject - sunt, de asemenea, func&#539;ii. Fiecare
            dintre aceste func&#539;ii accept&#259; un parametru de orice tip.</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Primul parametru, func&#539;ia resolve, este apelat&#259; &icirc;n cazul unui succes.
            Putem transmite &icirc;n aceasta o valoare pe care o putem ob&#539;ine ca rezultat al unui succes.</span>
    </p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Al doilea parametru, func&#539;ia reject, este apelat&#259; &icirc;n cazul unei
            erori. Putem transmite &icirc;n aceasta o valoare care reprezint&#259; informa&#539;ii despre eroare.</span>
    </p>
    <p class="c7 c11"><span class="c15"></span></p>
    <p class="c7"><span class="c17">Execu&#539;ia reu&#537;it&#259; a unei promisiuni.</span></p>
    <p class="c7 c11"><span class="c6"></span></p>
    <p class="c7"><span class="c0">A&#537;adar, primul parametru al func&#539;iei din constructorul Promise -
            func&#539;ia resolve - este executat&#259; la un succes. &Icirc;n aceast&#259; func&#539;ie, de obicei, se
            transmite o valoare care reprezint&#259; rezultatul opera&#539;iunii &icirc;n cazul unui succes.
            Aceast&#259; valoare poate reprezenta orice obiect. De exemplu, transmitem &icirc;n aceast&#259;
            func&#539;ie un &#537;ir de caractere:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.6ff0cc0b6f979b5d7353198d459aa8b7d597f421"></a><a
        id="t.5"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;myPromise = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(resolve){<br> &nbsp;
                        &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;Executarea unei opera&#539;iuni asincrone&quot;</span><span class="c3">);<br>
                        &nbsp; &nbsp; <br> &nbsp; &nbsp;resolve(</span><span class="c1">&quot;Salut
                        lume!&quot;</span><span class="c3">);<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Func&#539;ia resolve() este apelat&#259; la sf&acirc;r&#537;itul opera&#539;iunii
            executate dup&#259; toate ac&#539;iunile. C&acirc;nd se apeleaz&#259; aceast&#259; func&#539;ie, promisiunea
            trece &icirc;n starea fulfilled (executat&#259; cu succes).</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Totu&#537;i, trebuie s&#259; men&#539;ion&#259;m c&#259;, teoretic, putem returna un
            rezultat din func&#539;ie, dar practic nu ar avea sens:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.012e1d86d89a15cf4047e2b78562cf631460171b"></a><a
        id="t.6"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;myPromise = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(resolve, reject){<br>
                        &nbsp; &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;Executarea unei opera&#539;iuni asincrone&quot;</span><span class="c3">);<br>
                        &nbsp; &nbsp; <br> &nbsp; &nbsp;</span><span class="c2">return</span><span
                        class="c3">&nbsp;</span><span class="c1">&quot;Salut lume!&quot;</span><span
                        class="c3">;<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">Valoarea returnat&#259; nu poate fi transmis&#259; &icirc;n afar&#259;. &#536;i,
            dac&#259; &icirc;ntr-adev&#259;r trebuie s&#259; return&#259;m un anumit rezultat, acesta trebuie transmis
            func&#539;iei resolve().</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c17">Transmiterea informa&#539;iilor despre eroare.</span></p>
    <p class="c7 c11"><span class="c6"></span></p>
    <p class="c7"><span class="c0">Al doilea parametru al func&#539;iei din constructorul Promise este func&#539;ia
            reject, care este apelat&#259; c&acirc;nd apare o eroare. &Icirc;n aceast&#259; func&#539;ie, de obicei, se
            transmite o informa&#539;ie despre eroare, care poate reprezenta orice obiect. De exemplu:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.f2bf53af9da69afb5716987434ce71ac55fda554"></a><a
        id="t.7"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;myPromise = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(resolve, reject){<br>
                        &nbsp; &nbsp;</span><span class="c5">console</span><span class="c3">.log(</span><span
                        class="c1">&quot;Executarea unei opera&#539;iuni asincrone&quot;</span><span class="c3">);<br>
                        &nbsp; &nbsp;reject(</span><span class="c1">&quot;Au fost transmise date
                        incorecte&quot;</span><span class="c3">);<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">C&acirc;nd se apeleaz&#259; func&#539;ia reject(), promisiunea trece &icirc;n starea
            rejected (finalizat&#259; cu eroare).</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c6">Combinarea resolve &#537;i reject.</span></p>
    <p class="c7 c11"><span class="c6"></span></p>
    <p class="c7"><span class="c0">Evident, putem defini o logic&#259; &icirc;n care, &icirc;n func&#539;ie de anumite
            condi&#539;ii, vor fi executate ambele func&#539;ii:</span></p>
    <p class="c7 c11"><span class="c0"></span></p><a id="t.30fb31fb1f9b828931878bd468185df16dd02a48"></a><a
        id="t.8"></a>
    <table class="c13">
        <tr class="c9">
            <td class="c4" colspan="1" rowspan="1">
                <p class="c16"><span class="c2">const</span><span class="c3">&nbsp;x = </span><span
                        class="c8 c10">4</span><span class="c3">;<br></span><span class="c2">const</span><span
                        class="c3">&nbsp;y = </span><span class="c8 c10">0</span><span class="c3">;<br></span><span
                        class="c2">const</span><span class="c3">&nbsp;myPromise = </span><span
                        class="c2">new</span><span class="c3">&nbsp;</span><span class="c5">Promise</span><span
                        class="c3">(</span><span class="c2">function</span><span class="c3">(resolve, reject){<br> <br>
                        &nbsp; &nbsp;</span><span class="c2">if</span><span class="c3">(y === </span><span
                        class="c8 c10">0</span><span class="c3">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;reject(</span><span
                        class="c1">&quot;Au fost transmise date incorecte&quot;</span><span class="c3">);<br> &nbsp;
                        &nbsp;}<br> &nbsp; &nbsp;</span><span class="c2">else</span><span class="c3">{<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c2">const</span><span class="c3">&nbsp;z = x / y;<br> &nbsp;
                        &nbsp; &nbsp; &nbsp;resolve(z);<br> &nbsp; &nbsp;}<br>});</span></p>
            </td>
        </tr>
    </table>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7"><span class="c0">&Icirc;n acest caz, dac&#259; valoarea constantei y este 0, atunci comunic&#259;m
            despre eroare, apel&acirc;nd func&#539;ia reject(). Dac&#259; nu este 0, atunci execut&#259;m opera&#539;ia
            de &icirc;mp&#259;r&#539;ire &#537;i transmitem rezultatul func&#539;iei resolve().</span></p>
    <p class="c7 c11"><span class="c0"></span></p>
    <p class="c7 c11"><span class="c0"></span></p>
</body>

</html>