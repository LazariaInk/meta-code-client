<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c18 doc-content">
    <h1 class="c1 c17">Pattern-ul Modul. </h1>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Pattern-ul &quot;Modul&quot; se bazeaz&#259; pe &icirc;nchideri (closures) &#537;i
            const&#259; din dou&#259; componente: o func&#539;ie extern&#259;, care define&#537;te mediul lexical,
            &#537;i un set returnat de func&#539;ii interne, care au acces la acest mediu.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">S&#259; definim cel mai simplu modul:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.de41c417bdb3f39fd5ca13f99d12bb5017b5285e"></a><a id="t.0"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">const</span><span class="c3">&nbsp;printer = (</span><span
                        class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;messages = {greeting: </span><span
                        class="c8">&quot;hello&quot;</span><span class="c3">};<br> &nbsp; &nbsp; <br> &nbsp;
                        &nbsp;</span><span class="c4">return</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;print: </span><span class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp;
                        &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c11">console</span><span
                        class="c3">.log(messages.greeting);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp;
                        &nbsp;}<br>})();<br>printer.print(); &nbsp; &nbsp;</span><span class="c7">// hello</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Aici este definit&#259; constanta printer, care reprezint&#259; rezultatul unei
            func&#539;ii anonime. &Icirc;n interiorul acestei func&#539;ii este definit un obiect messages cu unele
            date.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Func&#539;ia anonim&#259; returneaz&#259; un obiect, care define&#537;te func&#539;ia
            print. Obiectul returnat define&#537;te API-ul public, prin intermediul c&#259;ruia putem accesa datele
            definite &icirc;n interiorul modulului.</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.02fcb0cf92881e00b52434050eea497115245558"></a><a id="t.1"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">return</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp;print:
                    </span><span class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c11">console</span><span class="c3">.log(messages.greeting);<br>
                        &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Aceast&#259; construc&#539;ie permite s&#259; izol&#259;m un anumit set de date
            &icirc;n cadrul func&#539;iei-modul &#537;i s&#259; mediere accesul la acestea printr-un API definit -
            func&#539;iile interne returnate.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Func&#539;iile returnate pot fi definite &icirc;n alt loc, nu doar &icirc;n
            interiorul func&#539;iei anonime:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.f01513907b6e436eea432c47461cf7b722dfa2bd"></a><a id="t.2"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">const</span><span class="c3">&nbsp;printer = (</span><span
                        class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;messages = {greeting: </span><span
                        class="c8">&quot;Hello FDC.COM&quot;</span><span class="c3">};<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;printMessage = </span><span
                        class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c11">console</span><span class="c3">.log(messages.greeting);<br> &nbsp; &nbsp;};<br>
                        &nbsp; &nbsp;</span><span class="c4">return</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;print: printMessage </span><span class="c7">// func&#539;ia printMessage este
                        definit&#259; &icirc;n afara obiectului</span><span class="c3"><br> &nbsp;
                        &nbsp;}<br>})();<br>printer.print(); &nbsp; &nbsp;</span><span class="c7">// Hello
                        FDC.COM</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Dac&#259; exist&#259; posibilitatea ca modulul s&#259; fie deja definit undeva mai
            devreme &icirc;n cod sau &icirc;n fi&#537;iere externe incluse, atunci putem folosi urm&#259;toarea
            construc&#539;ie:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.28f4506afea2b8c2bf150e96f2952c40adef82c3"></a><a id="t.3"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">var</span><span class="c3">&nbsp;printer = &nbsp;printer || (</span><span
                        class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;messages = {greeting: </span><span
                        class="c8">&quot;Hello World&quot;</span><span class="c3">};<br> &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;print:
                    </span><span class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c11">console</span><span class="c3">.log(messages.greeting);<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>})();<br>printer.print(); &nbsp;
                        &nbsp;</span><span class="c7">// Hello World</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c13">Definirea </span><span class="c13 c14">var printer = printer || (function(){ ... })
        </span><span class="c13">atribuie variabilei valoarea unui anumit obiect printer, dac&#259; exist&#259;, sau
            atribuie rezultatul apel&#259;rii func&#539;iei anonime IIFE. Dar cu aceast&#259; defini&#539;ie nu putem
            folosi cuvintele cheie </span><span class="c13 c14">let </span><span class="c13">sau </span><span
            class="c13 c14">const </span><span class="c13">pentru a defini obiectul. Prin urmare, &icirc;n acest caz,
            obiectul este definit cu ajutorul </span><span class="c13 c14">var</span><span class="c6">.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">S&#259; examin&#259;m un exemplu pu&#539;in mai complex:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.9e3e11d4b1b3ecf02a6f1533047bb7584b9967b5"></a><a id="t.4"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">const</span><span class="c3">&nbsp;calculator = (</span><span
                        class="c4">function</span><span class="c3">(){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;data = { number: </span><span
                        class="c10">0</span><span class="c3">};<br> &nbsp; &nbsp; <br> &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;sum:
                    </span><span class="c4">function</span><span class="c3">(n){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp;data.number += n;<br> &nbsp; &nbsp; &nbsp; &nbsp;},<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;subtract: </span><span class="c4">function</span><span class="c3">(n){<br> &nbsp; &nbsp;
                        &nbsp; &nbsp; &nbsp; &nbsp;data.number -= n;<br> &nbsp; &nbsp; &nbsp; &nbsp;},<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;print: </span><span class="c4">function</span><span class="c3">(){<br> &nbsp;
                        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c11">console</span><span
                        class="c3">.log(</span><span class="c8">&quot;Result: &quot;</span><span class="c3">,
                        data.number);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp;
                        &nbsp;}<br>})();<br>calculator.sum(</span><span class="c10">10</span><span
                        class="c3">);<br>calculator.sum(</span><span class="c10">3</span><span
                        class="c3">);<br>calculator.display(); &nbsp; </span><span class="c7">// Result: 13</span><span
                        class="c3"><br>calculator.subtract(</span><span class="c10">4</span><span
                        class="c3">);<br>calculator.display(); &nbsp; </span><span class="c7">// Result: 9</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Acest modul reprezint&#259; un calculator primitiv, care efectueaz&#259; trei
            opera&#539;ii: adunare, sc&#259;dere &#537;i afi&#537;area rezultatului.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Toate datele sunt &icirc;ncapsulate &icirc;n obiectul data, care stocheaz&#259;
            rezultatul opera&#539;iei. Toate opera&#539;iile sunt reprezentate de trei func&#539;ii returnate: sum,
            subtract &#537;i print. Prin aceste func&#539;ii putem controla rezultatul calculatorului din
            exterior.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c16">Introducerea modulelor externe.</span></p>
    <p class="c1 c2"><span class="c15"></span></p>
    <p class="c1"><span class="c6">Prin parametrii func&#539;iilor IIFE &icirc;n module se pot introduce unele date, de
            exemplu, alte module:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.3e9b2f3235e4bc8dd0e706013bf192cbff5a6a5c"></a><a id="t.5"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">var</span><span class="c3">&nbsp;moduleA = moduleA || (</span><span
                        class="c4">function</span><span class="c3">&nbsp;() { <br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;message = </span><span class="c8">&quot;Hello
                        World&quot;</span><span class="c3">;<br> &nbsp; &nbsp;</span><span class="c4">return</span><span
                        class="c3">&nbsp;{ <br> &nbsp; &nbsp; &nbsp; &nbsp;printMessage: </span><span
                        class="c4">function</span><span class="c3">() { &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c11">console</span><span class="c3">.log(message); &nbsp;<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;<br> &nbsp; &nbsp; } <br>})();<br> <br></span><span
                        class="c4">var</span><span class="c3">&nbsp;moduleB = moduleB || (</span><span
                        class="c4">function</span><span class="c3">&nbsp;(moduleA) { <br> &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c3">&nbsp;{ <br> &nbsp; &nbsp; &nbsp; &nbsp;print:
                    </span><span class="c4">function</span><span class="c3">() { &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp; &nbsp;moduleA.printMessage(); &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;<br>
                        &nbsp; &nbsp; } <br>})(moduleA);<br> <br>moduleB.print();</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">&Icirc;n acest caz, modulul moduleB a&#537;teapt&#259; s&#259; primeasc&#259; modulul
            moduleA. &Icirc;n interiorul modulului moduleB se face referire la func&#539;ia moduleA.printMessage.
            Similar, se pot transmite &#537;i seturi de module.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c16">Extinderea unui modul.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">C&acirc;nd lucra&#539;i cu module, poate ap&#259;rea necesitatea de a extinde
            func&#539;ionalitatea acestuia - ad&#259;ug&acirc;nd func&#539;ii sau variabile noi. &Icirc;n acest caz,
            putem folosi o serie de tehnici.</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.890be76a0b7c813ff26e84257ab8d15997b49ce9"></a><a id="t.6"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c7">// prima tehnic&#259;</span><span class="c3"><br></span><span
                        class="c4">var</span><span class="c3">&nbsp;localeModule = &nbsp;localeModule || (</span><span
                        class="c4">function</span><span class="c3">(locale){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;enMessage = </span><span class="c8">&quot;Hello
                        World&quot;</span><span class="c3">;<br> &nbsp; &nbsp;locale.printEn = </span><span
                        class="c4">function</span><span class="c3">(){</span><span class="c11">console</span><span
                        class="c3">.log(enMessage);};<br> &nbsp; &nbsp;</span><span class="c4">return</span><span
                        class="c3">&nbsp;locale;<br>})(localeModule || {});<br></span><span class="c7">// a doua
                        tehnic&#259;</span><span class="c3"><br></span><span class="c4">var</span><span
                        class="c3">&nbsp;localeModule = &nbsp;(</span><span class="c4">function</span><span
                        class="c3">(locale){<br> &nbsp; &nbsp;</span><span class="c4">const</span><span
                        class="c3">&nbsp;roMessage = </span><span class="c8">&quot;Salut lume&quot;</span><span
                        class="c3">;<br> &nbsp; &nbsp;locale.printRo = </span><span class="c4">function</span><span
                        class="c3">(){</span><span class="c11">console</span><span class="c3">.log(roMessage);};<br>
                        &nbsp; &nbsp;</span><span class="c4">return</span><span
                        class="c3">&nbsp;locale;<br>})(localeModule);<br><br>localeModule.printEn(); </span><span
                        class="c7">// Hello World</span><span class="c3"><br>localeModule.printRo(); </span><span
                        class="c7">// Salut lume</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Pentru a extinde un modul, se pot aplica dou&#259; tehnici. Prima tehnic&#259;
            presupune c&#259;, dac&#259; modulul nu a fost &icirc;nc&#259; creat, atunci ca parametru se transmite un
            obiect gol:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.bd29e3527faaae560e15c47d533d97546e1d66d9"></a><a id="t.7"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">var</span><span class="c3">&nbsp;localeModule = &nbsp;localeModule ||
                        (</span><span class="c4">function</span><span class="c3">(locale){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;enMessage = </span><span class="c8">&quot;Hello
                        World&quot;</span><span class="c3">;<br> &nbsp; &nbsp;locale.printEn = </span><span
                        class="c4">function</span><span class="c3">(){</span><span class="c11">console</span><span
                        class="c3">.log(enMessage);};<br> &nbsp; &nbsp;</span><span class="c4">return</span><span
                        class="c3">&nbsp;locale;<br>})(localeModule || {});</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">&Icirc;n acest caz, dac&#259; modulul localeModule nu exist&#259; &icirc;nc&#259;, va
            fi creat un obiect nou, la care va fi ad&#259;ugat&#259; func&#539;ia printEn pentru a afi&#537;a un anumit
            mesaj.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Avantajul acestei tehnici este c&#259; scripturile care fac parte din modul pot fi
            &icirc;nc&#259;rcate asincron. Nu conteaz&#259; care script este &icirc;nc&#259;rcat primul, deoarece,
            &icirc;n caz de &icirc;ndoial&#259;, modulul va fi creat din nou.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">A doua tehnic&#259; presupune c&#259; modulul exist&#259; deja:</span></p>
    <p class="c1 c2"><span class="c6"></span></p><a id="t.339dadf7d6c5c1ecb160a4514a969acb59c36dd1"></a><a id="t.8"></a>
    <table class="c12">
        <tr class="c0">
            <td class="c9" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">var</span><span class="c3">&nbsp;localeModule = &nbsp;(</span><span
                        class="c4">function</span><span class="c3">(locale){<br> &nbsp; &nbsp;</span><span
                        class="c4">const</span><span class="c3">&nbsp;roMessage = </span><span class="c8">&quot;Salut
                        lume&quot;</span><span class="c3">;<br> &nbsp; &nbsp;locale.printRo = </span><span
                        class="c4">function</span><span class="c3">(){</span><span class="c11">console</span><span
                        class="c3">.log(roMessage);};<br> &nbsp; &nbsp;</span><span class="c4">return</span><span
                        class="c3">&nbsp;locale;<br>})(localeModule);</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Aici suntem siguri c&#259; exist&#259; deja obiectul localeModule, &#537;i de
            asemenea ad&#259;ug&#259;m o nou&#259; func&#539;ie -printRo. &Icirc;n ambele cazuri, modulul
            returneaz&#259; ca rezultat un obiect extins cu noua func&#539;ionalitate din parametru.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1"><span class="c6">Totu&#537;i, indiferent de tipul de extindere a modulului aplicat, ambele au un
            dezavantaj comun: func&#539;iile definite &icirc;ntr-un fi&#537;ier de cod surs&#259; pentru modul nu au
            acces la variabilele &#537;i constantele private definite &icirc;ntr-un alt fi&#537;ier de cod surs&#259;
            pentru acela&#537;i modul. De exemplu, metoda printRo nu are acces la constanta enMessage.</span></p>
    <p class="c1 c2"><span class="c6"></span></p>
    <p class="c1 c2"><span class="c6"></span></p>
</body>

</html>