<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c14 doc-content">
    <h1 class="c0 c20">Introducere Ã®n Stream API.</h1>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">&Icirc;ncep&acirc;nd cu JDK 8, &icirc;n Java a ap&#259;rut un nou API
            numit</span><span class="c2">&nbsp;Stream API</span><span class="c11">. Scopul acestuia este s&#259;
            simplifice lucrul cu seturile de date, &icirc;n special opera&#539;iile de filtrare, sortare &#537;i alte
            manipul&#259;ri de date. Toat&#259; func&#539;ionalitatea principal&#259; a acestui API este
            concentrat&#259; &icirc;n pachetul</span><span class="c2">&nbsp;java.util.stream</span><span
            class="c1">.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">Conceptul cheie &icirc;n Stream API este</span><span class="c2">&nbsp;fluxul de
            date</span><span class="c1">. Termenul &bdquo;flux&rdquo; este destul de utilizat &icirc;n programare,
            &icirc;n special &icirc;n Java. &Icirc;n capitolele anterioare, a fost discutat lucrul cu fluxuri de
            caractere &#537;i byte pentru citirea &#537;i scrierea fi&#537;ierelor. &Icirc;n contextul Stream API,
            fluxul reprezint&#259; un canal de transmitere a datelor dintr-o surs&#259; de date. Sursele pot fi
            fi&#537;iere, dar &#537;i tablouri sau colec&#539;ii.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">Un aspect distinctiv al Stream API este utilizarea expresiilor lambda, care permit
            reducerea semnificativ&#259; a complexit&#259;&#539;ii codului pentru ac&#539;iunile executate.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">Un exemplu simplu poate ilustra aceasta. S&#259; presupunem c&#259; avem o
            sarcin&#259;: s&#259; g&#259;sim num&#259;rul tuturor elementelor dintr-un tablou care sunt mai mari
            dec&acirc;t 0. &Icirc;nainte de JDK 8, codul ar fi ar&#259;tat astfel:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <table class="c19">
        <tr class="c13">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c12">int</span><span class="c5">[] numbers = {-</span><span
                        class="c6">5</span><span class="c5">, -</span><span class="c6">4</span><span class="c5">,
                        -</span><span class="c6">3</span><span class="c5">, -</span><span class="c6">2</span><span
                        class="c5">, -</span><span class="c6">1</span><span class="c5">, </span><span
                        class="c6">0</span><span class="c5">, </span><span class="c6">1</span><span class="c5">,
                    </span><span class="c6">2</span><span class="c5">, </span><span class="c6">3</span><span
                        class="c5">, </span><span class="c6">4</span><span class="c5">, </span><span
                        class="c6">5</span><span class="c5">};<br></span><span class="c12">int</span><span
                        class="c5">&nbsp;count = </span><span class="c6">0</span><span class="c5">;<br></span><span
                        class="c12">for</span><span class="c5">(</span><span class="c12">int</span><span
                        class="c5">&nbsp;i : numbers){<br> &nbsp; &nbsp;</span><span class="c12">if</span><span
                        class="c5">(i &gt; </span><span class="c6">0</span><span class="c5">)
                        count++;<br>}<br>System.out.println(count);</span></p>
            </td>
        </tr>
    </table>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">Acum, aplic&acirc;nd Stream API:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <table class="c19">
        <tr class="c13">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c12">import</span><span class="c5">&nbsp;java.util.stream.*;<br></span><span
                        class="c16">//.......................</span><span class="c5"><br></span><span
                        class="c12">long</span><span class="c5">&nbsp;count = IntStream.of(-</span><span
                        class="c6">5</span><span class="c5">, -</span><span class="c6">4</span><span class="c5">,
                        -</span><span class="c6">3</span><span class="c5">, -</span><span class="c6">2</span><span
                        class="c5">, -</span><span class="c6">1</span><span class="c5">, </span><span
                        class="c6">0</span><span class="c5">, </span><span class="c6">1</span><span class="c5">,
                    </span><span class="c6">2</span><span class="c5">, </span><span class="c6">3</span><span
                        class="c5">, </span><span class="c6">4</span><span class="c5">, </span><span
                        class="c6">5</span><span class="c5">).filter(w -&gt; w &gt; </span><span
                        class="c6">0</span><span class="c5">).count();<br>System.out.println(count);</span></p>
            </td>
        </tr>
    </table>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">&Icirc;n loc de un ciclu &#537;i mai multe construc&#539;ii condi&#539;ionale, pe
            care le-am fi folosit &icirc;nainte de JDK 8, acum putem scrie un lan&#539; de metode care vor realiza
            acelea&#537;i ac&#539;iuni.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c10">Oper&#259;ri terminale &#537;i intermediare.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">Este important s&#259; &icirc;n&#539;elegem c&#259; toate opera&#539;iile cu fluxuri
            sunt fie </span><span class="c2">terminale</span><span class="c11">, fie </span><span
            class="c2">intermediare</span><span class="c11">. Opera&#539;iile intermediare returneaz&#259; un flux
            transformat. De exemplu, metoda </span><span class="c11 c15">filter </span><span class="c1">din exemplul de
            mai sus preia un flux de numere &#537;i returneaz&#259; un flux filtrat, cu doar numere mai mari de 0.
            Acestui flux returnat i se pot aplica &#537;i alte opera&#539;ii intermediare.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">Opera&#539;iile terminale returneaz&#259; un rezultat concret. De exemplu, metoda
        </span><span class="c11 c15">count() </span><span class="c1">din exemplul anterior este o opera&#539;ie
            terminal&#259; &#537;i returneaz&#259; un num&#259;r. Dup&#259; aceasta, nu mai pot fi aplicate alte
            opera&#539;ii intermediare.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c10">Executare am&acirc;nat&#259;.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">Toate fluxurile efectueaz&#259; calcule doar atunci c&acirc;nd se aplic&#259; o
            opera&#539;ie terminal&#259;, ceea ce &icirc;nseamn&#259; c&#259; se aplic&#259; o execu&#539;ie
            am&acirc;nat&#259;.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c10">Interfa&#539;a BaseStream.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">La baza Stream API st&#259; interfa&#539;a </span><span
            class="c2">BaseStream</span><span class="c1">. Defini&#539;ia complet&#259; a acesteia este:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <table class="c19">
        <tr class="c13">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c12">interface</span><span class="c5">&nbsp;</span><span
                        class="c18">BaseStream</span><span class="c5">&lt;</span><span class="c18">T</span><span
                        class="c5">, </span><span class="c18">S</span><span class="c5">&nbsp;</span><span
                        class="c12">extends</span><span class="c5">&nbsp;</span><span class="c18">BaseStream</span><span
                        class="c5">&lt;</span><span class="c18">T</span><span class="c5">, </span><span
                        class="c18">S</span><span class="c5">&gt;&gt;</span></p>
            </td>
        </tr>
    </table>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">Parametrul </span><span class="c11 c15">T </span><span class="c11">reprezint&#259;
            tipul de date din flux, iar </span><span class="c11 c15">S</span><span class="c1">&nbsp;este tipul fluxului,
            care mo&#537;tene&#537;te interfa&#539;a BaseStream.</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">Interfa&#539;a BaseStream define&#537;te func&#539;ionalitatea de baz&#259; pentru
            lucrul cu fluxuri, implementat&#259; prin urm&#259;toarele metode:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0 start">
        <li class="c0 c4 li-bullet-0"><span class="c2">void close()</span><span class="c1">: &icirc;nchide fluxul
                &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">boolean isParallel()</span><span class="c1">: returneaz&#259;
                true dac&#259; fluxul este paralel &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Iterator&lt;T&gt; iterator()</span><span class="c1">:
                returneaz&#259; un iterator pentru flux &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Spliterator&lt;T&gt; spliterator()</span><span class="c1">:
                returneaz&#259; un spliterator pentru flux &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">S parallel()</span><span class="c1">: returneaz&#259; un flux
                paralel (fluxurile paralele pot utiliza mai multe nuclee &icirc;n arhitecturile multi-core)
                &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">S sequential()</span><span class="c1">: returneaz&#259; un flux
                secven&#539;ial &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_l2oyhuwx0tng-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">S unordered()</span><span class="c1">: returneaz&#259; un flux
                neordonat &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">Interfa&#539;a BaseStream este mo&#537;tenit&#259; de o serie de interfe&#539;e
            destinate cre&#259;rii fluxurilor specifice:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_ukkv7j2lpc0v-0 start">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt;</span><span class="c1">: utilizat pentru fluxuri
                de date care reprezint&#259; orice tip de referin&#539;&#259; &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_ukkv7j2lpc0v-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">IntStream</span><span class="c1">: utilizat pentru fluxuri de tip
                int &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_ukkv7j2lpc0v-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">DoubleStream</span><span class="c1">: utilizat pentru fluxuri de
                tip double &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_ukkv7j2lpc0v-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">LongStream</span><span class="c1">: utilizat pentru fluxuri de
                tip long &nbsp;</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c11">La lucrul cu fluxuri care reprezint&#259; anumite tipuri primitive - double, int,
            long - este mai simplu s&#259; folose&#537;ti interfe&#539;ele DoubleStream, IntStream, LongStream.
            &Icirc;ns&#259;, &icirc;n majoritatea cazurilor, de obicei, se lucreaz&#259; cu date mai complexe, pentru
            care este destinat interfa&#539;a</span><span class="c11 c15">&nbsp;Stream&lt;T&gt;</span><span class="c1">.
            S&#259; analiz&#259;m c&acirc;teva dintre metodele sale:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0 start">
        <li class="c0 c4 li-bullet-0"><span class="c2">boolean allMatch(Predicate&lt;? super T&gt;
                predicate)</span><span class="c1">: returneaz&#259; true dac&#259; toate elementele fluxului
                &icirc;ndeplinesc condi&#539;ia din predicat. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">boolean anyMatch(Predicate&lt;? super T&gt;
                predicate)</span><span class="c1">: returneaz&#259; true dac&#259; cel pu&#539;in un element din flux
                &icirc;ndepline&#537;te condi&#539;ia din predicat. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt;
                collector)</span><span class="c1">: adaug&#259; elementele &icirc;ntr-un container imuabil de tipul R. T
                reprezint&#259; tipul de date din fluxul apelant, iar A - tipul de date din container. Opera&#539;ie
                terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">long count()</span><span class="c1">: returneaz&#259;
                num&#259;rul de elemente din flux. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; concat&#8203;(Stream&lt;? extends T&gt; a,
                Stream&lt;? extends T&gt; b)</span><span class="c1">: une&#537;te dou&#259; fluxuri. Opera&#539;ie
                intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; distinct()</span><span class="c1">:
                returneaz&#259; un flux &icirc;n care exist&#259; doar date unice de tip T. Opera&#539;ie
                intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; dropWhile&#8203;(Predicate&lt;? super T&gt;
                predicate)</span><span class="c1">: omite elementele care corespund condi&#539;iei din predicat
                p&acirc;n&#259; c&acirc;nd se &icirc;nt&acirc;lne&#537;te un element care nu corespunde condi&#539;iei.
                Elementele selectate sunt returnate sub form&#259; de flux. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt;
                predicate)</span><span class="c1">: filtreaz&#259; elementele &icirc;n func&#539;ie de condi&#539;ia din
                predicat. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Optional&lt;T&gt; findFirst()</span><span class="c1">:
                returneaz&#259; primul element din flux. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Optional&lt;T&gt; findAny()</span><span class="c1">:
                returneaz&#259; primul element &icirc;nt&acirc;lnit din flux. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">void forEach(Consumer&lt;? super T&gt; action)</span><span
                class="c1">: pentru fiecare element se execut&#259; ac&#539;iunea action. Opera&#539;ie
                terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; limit(long maxSize)</span><span class="c1">:
                p&#259;streaz&#259; &icirc;n flux doar maxSize elemente. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Optional&lt;T&gt; max(Comparator&lt;? super T&gt;
                comparator)</span><span class="c1">: returneaz&#259; elementul maxim din flux. Pentru compararea
                elementelor se folose&#537;te comparatorul comparator. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Optional&lt;T&gt; min(Comparator&lt;? super T&gt;
                comparator)</span><span class="c1">: returneaz&#259; elementul minim din flux. Pentru compararea
                elementelor se folose&#537;te comparatorul comparator. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends
                R&gt; mapper)</span><span class="c1">: transform&#259; elementele de tip T &icirc;n elemente de tip R
                &#537;i returneaz&#259; un flux cu elemente de tip R. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ?
                extends Stream&lt;? extends R&gt;&gt; mapper)</span><span class="c1">: permite transformarea unui
                element de tip T &icirc;n mai multe elemente de tip R &#537;i returneaz&#259; un flux cu elemente de tip
                R. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">boolean noneMatch(Predicate&lt;? super T&gt;
                predicate)</span><span class="c1">: returneaz&#259; true dac&#259; niciunul dintre elementele din flux
                nu &icirc;ndepline&#537;te condi&#539;ia din predicat. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; skip(long n)</span><span class="c1">:
                returneaz&#259; un flux din care lipsesc primele n elemente. Opera&#539;ie intermediar&#259;.</span>
        </li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; sorted()</span><span class="c1">: returneaz&#259;
                un flux sortat. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt;
                comparator)</span><span class="c1">: returneaz&#259; un flux sortat conform comparatorului.
                Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Stream&lt;T&gt; takeWhile&#8203;(Predicate&lt;? super T&gt;
                predicate)</span><span class="c1">: selecteaz&#259; elementele din flux c&acirc;t timp acestea
                &icirc;ndeplinesc condi&#539;ia din predicate. Elementele selectate sunt returnate sub form&#259; de
                flux. Opera&#539;ie intermediar&#259;.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_gz03mxu095z-0">
        <li class="c0 c4 li-bullet-0"><span class="c2">Object[] toArray()</span><span class="c1">: returneaz&#259; un
                array cu elementele din flux. Opera&#539;ie terminal&#259;.</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
    <p class="c0"><span class="c1">De&#537;i toate aceste opera&#539;ii permit interac&#539;iunea cu fluxul ca &#537;i
            cum ar fi un set de date asem&#259;n&#259;tor unei colec&#539;ii, este important s&#259;
            &icirc;n&#539;elegem diferen&#539;a dintre colec&#539;ii &#537;i fluxuri:</span></p>
    <p class="c0 c7"><span class="c1"></span></p>
    <ul class="c9 lst-kix_xvc2l2wevai4-0 start">
        <li class="c0 c4 li-bullet-0"><span class="c1">Fluxurile nu stocheaz&#259; elementele. Elementele utilizate
                &icirc;n fluxuri pot fi stocate &icirc;ntr-o colec&#539;ie sau, dac&#259; este necesar, pot fi generate
                direct.</span></li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_xvc2l2wevai4-0">
        <li class="c0 c4 li-bullet-0"><span class="c1">Opera&#539;iile pe fluxuri nu modific&#259; sursa de date.
                Opera&#539;iile pe fluxuri doar returneaz&#259; un flux nou cu rezultatele acestor opera&#539;ii.</span>
        </li>
    </ul>
    <p class="c0 c3"><span class="c1"></span></p>
    <ul class="c9 lst-kix_xvc2l2wevai4-0">
        <li class="c0 c4 li-bullet-0"><span class="c1">Fluxurile sunt caracterizate prin execu&#539;ie
                &icirc;nt&acirc;rziat&#259;. Adic&#259;, toate opera&#539;iile pe flux se execut&#259; doar atunci
                c&acirc;nd se efectueaz&#259; o opera&#539;ie terminal&#259; &#537;i se returneaz&#259; un rezultat
                concret, nu un nou flux.</span></li>
    </ul>
    <p class="c0 c7"><span class="c1"></span></p>
</body>

</html>