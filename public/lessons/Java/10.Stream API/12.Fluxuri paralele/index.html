<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c20 doc-content">
    <h1 class="c1 c16">Fluxuri paralele.</h1>
    <p class="c1 c9"><span class="c16"></span></p>
    <p class="c1"><span class="c0">Pe l&acirc;ng&#259; fluxurile secven&#539;iale, Stream API suport&#259; &#537;i
            fluxuri paralele. Paralelizarea fluxurilor permite utilizarea mai multor nuclee ale procesorului (dac&#259;
            ma&#537;ina &#539;int&#259; este multi-core), ceea ce poate &icirc;mbun&#259;t&#259;&#539;i performan&#539;a
            &#537;i accelera calculele. Cu toate acestea, nu este &icirc;ntotdeauna corect s&#259; afirm&#259;m c&#259;
            utilizarea fluxurilor paralele pe ma&#537;inile multi-core va cre&#537;te performan&#539;a &icirc;n mod
            garantat. &Icirc;n fiecare caz specific, este necesar s&#259; se testeze &#537;i s&#259; se verifice.</span>
    </p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c3">Pentru a face un flux secven&#539;ial obi&#537;nuit paralel, trebuie s&#259;
            apel&#259;m metoda </span><span class="c8">parallel </span><span class="c3">a obiectului Stream. De
            asemenea, putem folosi metoda </span><span class="c8">parallelStream() </span><span class="c0">a
            interfe&#539;ei Collection pentru a crea un flux paralel dintr-o colec&#539;ie.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">Dac&#259; ma&#537;ina de lucru nu este multi-core, fluxul se va executa
            secven&#539;ial.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">Utilizarea fluxurilor paralele &icirc;n multe cazuri va fi similar&#259;. De
            exemplu:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <table class="c11">
        <tr class="c10">
            <td class="c12" colspan="1" rowspan="1">
                <p class="c5"><span class="c6">import</span><span class="c4">&nbsp;java.util.Optional;<br></span><span
                        class="c6">import</span><span class="c4">&nbsp;java.util.stream.Stream;<br><br></span><span
                        class="c6">public</span><span class="c4">&nbsp;</span><span class="c6">class</span><span
                        class="c4">&nbsp;</span><span class="c15">Program</span><span class="c4">&nbsp;{<br> &nbsp;
                        &nbsp;</span><span class="c6">public</span><span class="c4">&nbsp;</span><span
                        class="c6">static</span><span class="c4">&nbsp;</span><span class="c6">void</span><span
                        class="c4">&nbsp;</span><span class="c15">main</span><span class="c4">(String[] args) {<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;Stream&lt;Integer&gt; numbersStream = Stream.of(</span><span
                        class="c7">1</span><span class="c4">, </span><span class="c7">2</span><span class="c4">,
                    </span><span class="c7">3</span><span class="c4">, </span><span class="c7">4</span><span
                        class="c4">, </span><span class="c7">5</span><span class="c4">, </span><span
                        class="c7">6</span><span class="c4">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Optional&lt;Integer&gt;
                        result = numbersStream.parallel().reduce((x, y) -&gt; x * y);<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;System.out.println(result.get()); </span><span class="c19">// 720</span><span
                        class="c4"><br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">Un alt exemplu:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <table class="c11">
        <tr class="c10">
            <td class="c12" colspan="1" rowspan="1">
                <p class="c5"><span class="c6">import</span><span class="c4">&nbsp;java.util.Arrays;<br></span><span
                        class="c6">import</span><span class="c4">&nbsp;java.util.List;<br><br></span><span
                        class="c6">public</span><span class="c4">&nbsp;</span><span class="c6">class</span><span
                        class="c4">&nbsp;</span><span class="c15">Program</span><span class="c4">&nbsp;{<br> &nbsp;
                        &nbsp;</span><span class="c6">public</span><span class="c4">&nbsp;</span><span
                        class="c6">static</span><span class="c4">&nbsp;</span><span class="c6">void</span><span
                        class="c4">&nbsp;</span><span class="c15">main</span><span class="c4">(String[] args) {<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;List&lt;String&gt; people = Arrays.asList(</span><span
                        class="c2">&quot;Tom&quot;</span><span class="c4">, </span><span
                        class="c2">&quot;Bob&quot;</span><span class="c4">, </span><span
                        class="c2">&quot;Sam&quot;</span><span class="c4">, </span><span
                        class="c2">&quot;Kate&quot;</span><span class="c4">, </span><span
                        class="c2">&quot;Tim&quot;</span><span class="c4">);<br><br> &nbsp; &nbsp; &nbsp;
                        &nbsp;System.out.println(</span><span class="c2">&quot;Flux secven&#539;ial&quot;</span><span
                        class="c4">);<br> &nbsp; &nbsp; &nbsp; &nbsp;people.stream().filter(p -&gt; p.length() ==
                    </span><span class="c7">3</span><span class="c4">).forEach(System.out::println);<br><br> &nbsp;
                        &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c2">&quot;\nFlux
                        paralel&quot;</span><span class="c4">);<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;people.parallelStream().filter(p -&gt; p.length() == </span><span class="c7">3</span><span
                        class="c4">).forEach(System.out::println);<br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">&Icirc;n acest caz, mai &icirc;nt&acirc;i cre&#259;m un flux pentru lista people
            &#537;i efectu&#259;m c&acirc;teva opera&#539;iuni &icirc;n mod secven&#539;ial, c&#259;ut&acirc;nd &icirc;n
            list&#259; &#537;iruri de caractere cu lungimea egal&#259; cu 3 &#537;i afi&#537;&acirc;ndu-le &icirc;n
            consol&#259;. &Icirc;n acest caz, toate opera&#539;iunile vor fi efectuate &icirc;n ordinea &icirc;n care
            elementele apar &icirc;n list&#259;.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c3">Apoi, folosim metoda </span><span class="c3 c17">people.parallelStream() </span><span
            class="c0">pentru a crea un flux paralel. De&#537;i aplic&#259;m acelea&#537;i opera&#539;iuni, ordinea
            &icirc;n care elementele listei vor fi procesate nu este determinat&#259;.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">Output &icirc;n consol&#259;:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <table class="c11">
        <tr class="c10">
            <td class="c12" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">Flux secven&#539;ial<br>Tom<br>Bob<br>Sam<br>Tim<br><br>Flux
                        paralel<br>Sam<br>Tim<br>Bob<br>Tom</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">&Icirc;n cazul fluxului paralel, rezultatul este nedeterministic &#537;i poate
            varia.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">Totu&#537;i, nu toate func&#539;iile pot fi transferate de la fluxurile
            secven&#539;iale la cele paralele f&#259;r&#259; a compromite corectitudinea calculelor. Aceste func&#539;ii
            trebuie s&#259; fie f&#259;r&#259; st&#259;ri &#537;i asociative, adic&#259; s&#259; produc&#259;
            acela&#537;i rezultat indiferent dac&#259; se efectueaz&#259; de la st&acirc;nga la dreapta sau de la
            dreapta la st&acirc;nga, ca &icirc;n cazul &icirc;nmul&#539;irii numerelor. De exemplu:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <table class="c11">
        <tr class="c10">
            <td class="c12" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">Stream&lt;Integer&gt; numbersStream = Stream.of(</span><span
                        class="c7">1</span><span class="c4">, </span><span class="c7">2</span><span class="c4">,
                    </span><span class="c7">3</span><span class="c4">, </span><span class="c7">4</span><span
                        class="c4">, </span><span class="c7">5</span><span class="c4">, </span><span
                        class="c7">6</span><span class="c4">);<br>Integer result =
                        numbersStream.parallel().reduce(</span><span class="c7">1</span><span class="c4">, (x, y) -&gt;
                        x * y);<br>System.out.println(result);</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c3">Aici se realizeaz&#259; &icirc;nmul&#539;irea numerelor. Nu conteaz&#259; dac&#259;
            ordinea este </span><span class="c3 c17">1 * 2 * 3 * 4 * (5 * 6) sau 5 * 6 * 1 * (2 * 3) * 4</span><span
            class="c0">. Putem pune parantezele &icirc;n orice mod, iar rezultatul va fi acela&#537;i, deoarece
            opera&#539;ia este asociativ&#259; &#537;i poate fi paralelizat&#259;.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c18">Probleme de performan&#539;&#259; &icirc;n opera&#539;iunile paralele.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c0">Utilizarea fluxurilor paralele implic&#259; &icirc;mp&#259;r&#539;irea datelor
            &icirc;n p&#259;r&#539;i, fiecare parte fiind procesat&#259; pe un nucleu separat al procesorului, iar la
            final aceste p&#259;r&#539;i sunt combinate &#537;i se aplic&#259; opera&#539;iile finale. Iat&#259;
            c&acirc;&#539;iva factori care pot afecta performan&#539;a fluxurilor paralele:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <ul class="c14 lst-kix_s5lb3r8ahqlr-0 start">
        <li class="c1 c13 li-bullet-0"><span class="c0">Dimensiunea datelor: Cu c&acirc;t datele sunt mai mari, cu
                at&acirc;t este mai complicat s&#259; le &icirc;mp&#259;r&#539;im &#537;i apoi s&#259; le
                combin&#259;m.</span></li>
    </ul>
    <p class="c1 c9"><span class="c0"></span></p>
    <ul class="c14 lst-kix_s5lb3r8ahqlr-0">
        <li class="c1 c13 li-bullet-0"><span class="c0">Num&#259;rul de nuclee ale procesorului: Teoretic, cu c&acirc;t
                sunt mai multe nuclee, cu at&acirc;t mai rapid va func&#539;iona programul. Dac&#259; ma&#537;ina are un
                singur nucleu, nu are sens s&#259; folosim fluxuri paralele.</span></li>
    </ul>
    <p class="c1 c9"><span class="c0"></span></p>
    <ul class="c14 lst-kix_s5lb3r8ahqlr-0">
        <li class="c1 c13 li-bullet-0"><span class="c0">Structura datelor: Cu c&acirc;t structura datelor este mai
                simpl&#259;, cu at&acirc;t mai rapid vor fi efectuate opera&#539;iile. De exemplu, ArrayList este
                u&#537;or de utilizat deoarece con&#539;ine date neconectate. &Icirc;n schimb, LinkedList nu este cea
                mai bun&#259; alegere, deoarece fiecare element din list&#259; este conectat cu cel
                anterior/urm&#259;tor, ceea ce face dificil&#259; paralelizarea.</span></li>
    </ul>
    <p class="c1 c9"><span class="c0"></span></p>
    <ul class="c14 lst-kix_s5lb3r8ahqlr-0">
        <li class="c1 c13 li-bullet-0"><span class="c0">Tipuri de date primitive: Opera&#539;iile pe tipuri primitive
                vor fi efectuate mai rapid dec&acirc;t pe obiecte de clas&#259;.</span></li>
    </ul>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c18">Ordinea &icirc;n fluxurile paralele.</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c3">De obicei, elementele sunt transmise fluxului &icirc;n aceea&#537;i ordine &icirc;n
            care sunt definite &icirc;n sursa de date. &Icirc;n fluxurile paralele, sistemul men&#539;ine ordinea
            elementelor. O excep&#539;ie este metoda</span><span class="c3 c17">&nbsp;forEach()</span><span class="c3">,
            care poate afi&#537;a elementele &icirc;ntr-o ordine aleatorie. Pentru a p&#259;stra ordinea, trebuie
            s&#259; folosim metoda </span><span class="c8">forEachOrdered</span><span class="c0">:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <table class="c11">
        <tr class="c10">
            <td class="c12" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">phones.parallelStream()<br> &nbsp; &nbsp;.sorted()<br> &nbsp;
                        &nbsp;.forEachOrdered(s -&gt; System.out.println(s));</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1"><span class="c3">P&#259;strarea ordinii &icirc;n fluxurile paralele implic&#259; costuri suplimentare
            la execu&#539;ie. Dar dac&#259; ordinea nu este important&#259;, o putem dezactiva pentru a cre&#537;te
            performan&#539;a, folosind metoda </span><span class="c8">unordered</span><span class="c0">:</span></p>
    <p class="c1 c9"><span class="c0"></span></p>
    <table class="c11">
        <tr class="c10">
            <td class="c12" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">phones.parallelStream()<br> &nbsp; &nbsp;.sorted()<br> &nbsp;
                        &nbsp;.unordered()<br> &nbsp; &nbsp;.forEach(s -&gt; System.out.println(s));</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c9"><span class="c0"></span></p>
    <p class="c1 c9"><span class="c0"></span></p>
</body>

</html>