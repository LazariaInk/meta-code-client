<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c19 doc-content">
    <h1 class="c1 c18">Expresii regulate.</h1>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">Expresiile regulate reprezint&#259; un instrument puternic pentru procesarea
            &#537;irurilor de caractere. Ele permit definirea unui &#537;ablon la care trebuie s&#259; corespund&#259;
            un &#537;ir sau un sub&#537;ir.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">Unele metode din clasa String accept&#259; expresii regulate &#537;i le folosesc
            pentru a efectua opera&#539;iuni pe &#537;iruri.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c16">split &nbsp;</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Pentru a &icirc;mp&#259;r&#539;i un &#537;ir &icirc;n sub&#537;iruri se
            folose&#537;te metoda</span><span class="c2">&nbsp;split()</span><span class="c4">. Aceasta poate accepta o
            expresie regulat&#259; ca parametru, care define&#537;te criteriul de &icirc;mp&#259;r&#539;ire a
            &#537;irului.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">De exemplu, &icirc;mp&#259;r&#539;im o propozi&#539;ie &icirc;n cuvinte:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">String text = </span><span class="c10">&quot;FIFA will never regret
                        it&quot;</span><span class="c3">;<br>String[] words = text.split(</span><span
                        class="c10">&quot;\\s*(\\s|,|!|\\.)\\s*&quot;</span><span class="c3">);<br></span><span
                        class="c6">for</span><span class="c3">(String word : words){<br> &nbsp;
                        &nbsp;System.out.println(word);<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">Pentru &icirc;mp&#259;r&#539;ire se folose&#537;te expresia regulat&#259;
            \\s*(\\s|,|!|\\.)\\s*. Subexpresia \\s reprezint&#259; un spa&#539;iu. Asteriscul indic&#259; faptul c&#259;
            simbolul poate ap&#259;rea de la 0 p&acirc;n&#259; la un num&#259;r infinit de ori. Prin urmare, \\s*
            &icirc;nseamn&#259; un num&#259;r nedefinit de spa&#539;ii consecutive &ndash; adic&#259; nu conteaz&#259;
            c&acirc;te spa&#539;ii sunt &icirc;ntre cuvinte. &Icirc;n plus, pot s&#259; nu existe deloc spa&#539;ii.
            &Icirc;n paranteze este indicat un grup de expresii care poate urma dup&#259; un num&#259;r nedefinit de
            spa&#539;ii. Grupul ne permite s&#259; definim un set de valori separate printr-o bar&#259; vertical&#259;,
            &#537;i sub&#537;irul trebuie s&#259; corespund&#259; uneia dintre aceste valori. &Icirc;n grupul
            \\s|,|!|\\. sub&#537;irul poate fi un spa&#539;iu, o virgul&#259;, un semn de exclamare sau un punct.
            Deoarece punctul are un sens special &icirc;n expresiile regulate, trebuie s&#259; &icirc;l sc&#259;p&#259;m
            cu ajutorul unei bare inverse.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c16">Potrivirea unui &#537;ir. matches</span></p>
    <p class="c1"><span class="c4">&nbsp; </span></p>
    <p class="c1"><span class="c11">O alt&#259; metod&#259; a clasei String,</span><span
            class="c2">&nbsp;matches()</span><span class="c4">, accept&#259; o expresie regulat&#259; &#537;i
            returneaz&#259; true dac&#259; &#537;irul corespunde acesteia. &Icirc;n caz contrar, returneaz&#259;
            false.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">De exemplu, verific&#259;m dac&#259; un &#537;ir corespunde unui num&#259;r de
            telefon:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">String input = </span><span
                        class="c10">&quot;+12343454556&quot;</span><span class="c3">;<br></span><span
                        class="c6">boolean</span><span class="c3">&nbsp;result = input.matches(</span><span
                        class="c10">&quot;(\\+*)\\d{11}&quot;</span><span class="c3">);<br></span><span
                        class="c6">if</span><span class="c3">(result){<br> &nbsp; &nbsp;System.out.println(</span><span
                        class="c10">&quot;Este un num&#259;r de telefon&quot;</span><span
                        class="c3">);<br>}<br></span><span class="c6">else</span><span class="c3">{<br> &nbsp;
                        &nbsp;System.out.println(</span><span class="c10">&quot;Nu este un num&#259;r de
                        telefon!&quot;</span><span class="c3">);<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">&Icirc;n acest caz, expresia regulat&#259; define&#537;te mai &icirc;nt&acirc;i un
            grup (\\+*), adic&#259; &#537;irul poate &icirc;ncepe cu semnul plus, dar acesta poate lipsi. Apoi,
            verific&#259;m dac&#259; urm&#259;toarele 11 caractere sunt cifre. Expresia \\d reprezint&#259; un caracter
            numeric, iar num&#259;rul din acolade {11} indic&#259; de c&acirc;te ori trebuie s&#259; se repete acest tip
            de caractere. Astfel, c&#259;ut&#259;m un &#537;ir care poate &icirc;ncepe cu semnul plus (sau nu) &#537;i
            urmat de 11 cifre.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c16">Clasa Pattern.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Cea mai mare parte a func&#539;ionalit&#259;&#539;ii pentru lucrul cu expresii
            regulate &icirc;n Java este concentrat&#259; &icirc;n pachetu</span><span class="c2">l
            java.util.regex</span><span class="c4">.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Expresia regulat&#259; &icirc;n sine reprezint&#259; un &#537;ablon pentru
            c&#259;utarea potrivirilor &icirc;ntr-un &#537;ir. Pentru a defini un astfel de &#537;ablon &#537;i pentru a
            c&#259;uta sub&#537;iruri care corespund acestuia, &icirc;n Java sunt definite clasele </span><span
            class="c2">Pattern </span><span class="c11">&#537;i </span><span class="c2">Matcher</span><span
            class="c4">.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Pentru o c&#259;utare simpl&#259; a potrivirilor, clasa Pattern define&#537;te
            metoda static&#259; </span><span class="c2">boolean matches(String pattern, CharSequence input)</span><span
            class="c4">. Aceasta returneaz&#259; true dac&#259; secven&#539;a de caractere input corespunde complet
            &#537;ablonului specificat:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c6">import</span><span class="c3">&nbsp;java.util.regex.Pattern;<br>
                        <br></span><span class="c6">public</span><span class="c3">&nbsp;</span><span
                        class="c6">class</span><span class="c3">&nbsp;</span><span class="c5">StringsApp</span><span
                        class="c3">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c3">&nbsp;</span><span class="c6">static</span><span class="c3">&nbsp;</span><span
                        class="c6">void</span><span class="c3">&nbsp;</span><span class="c5">main</span><span
                        class="c3">(String[] args) {<br> &nbsp; &nbsp; &nbsp; &nbsp;String input = </span><span
                        class="c10">&quot;Hello&quot;</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c6">boolean</span><span class="c3">&nbsp;found =
                        Pattern.matches(</span><span class="c10">&quot;Hello&quot;</span><span class="c3">, input);<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c3">(found)<br> &nbsp;
                        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span
                        class="c10">&quot;G&#259;sit&quot;</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c6">else</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp;System.out.println(</span><span class="c10">&quot;Nu a fost
                        g&#259;sit&quot;</span><span class="c3">);<br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">Totu&#537;i, de obicei, pentru c&#259;utarea potrivirilor se folose&#537;te clasa
            Matcher.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c16">Clasa Matcher.</span></p>
    <p class="c1"><span class="c4">&nbsp; </span></p>
    <p class="c1"><span class="c11">Principalele metode ale clasei </span><span class="c2">Matcher </span><span
            class="c4">sunt:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">- </span><span class="c2">boolean matches()</span><span class="c4">: returneaz&#259;
            true dac&#259; &icirc;ntregul &#537;ir corespunde &#537;ablonului &nbsp;</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">- </span><span class="c2">boolean find()</span><span class="c4">: returneaz&#259;
            true dac&#259; exist&#259; un sub&#537;ir care corespunde &#537;ablonului &#537;i trece la acest sub&#537;ir
            &nbsp;</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">- </span><span class="c2">String group()</span><span class="c11">: returneaz&#259;
            sub&#537;irul care corespunde &#537;ablonului &icirc;n urma apel&#259;rii metodei find. Dac&#259; nu
            exist&#259; potriviri, metoda genereaz&#259; o excep&#539;ie </span><span
            class="c11 c14">IllegalStateException </span><span class="c4">&nbsp;</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">- </span><span class="c2">int start()</span><span class="c4">: returneaz&#259;
            indexul potrivirii curente &nbsp;</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">- </span><span class="c2">int end()</span><span class="c4">: returneaz&#259; indexul
            urm&#259;tor dup&#259; potrivirea curent&#259; &nbsp;</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">- </span><span class="c2">String replaceAll(String str)</span><span class="c4">:
            &icirc;nlocuie&#537;te toate potrivirile cu sub&#537;irul specificat &#537;i returneaz&#259; &#537;irul
            modificat</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">S&#259; folosim clasa </span><span class="c2">Matcher</span><span class="c11">. Mai
            &icirc;nt&acirc;i trebuie s&#259; cre&#259;m un obiect Pattern folosind metoda static&#259;</span><span
            class="c2">&nbsp;compile()</span><span class="c11">, </span><span class="c4">care permite setarea
            &#537;ablonului:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">Pattern pattern = Pattern.compile(</span><span
                        class="c10">&quot;Hello&quot;</span><span class="c3">);</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Ca &#537;ablon este folosit &#537;irul &quot;Hello&quot;. Metoda </span><span
            class="c11 c14">compile()</span><span class="c4">&nbsp;returneaz&#259; un obiect Pattern pe care &icirc;l
            putem folosi &icirc;n program.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">&Icirc;n clasa Pattern este definit&#259; &#537;i metoda</span><span
            class="c2">&nbsp;matcher(String input)</span><span class="c11">, care prime&#537;te &#537;irul &icirc;n care
            se caut&#259; potrivirea &#537;i returneaz&#259; un obiect </span><span class="c2">Matcher</span><span
            class="c4">:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">String input = </span><span class="c10">&quot;Hello world! Hello
                        Java!&quot;</span><span class="c3">;<br>Pattern pattern = Pattern.compile(</span><span
                        class="c10">&quot;hello&quot;</span><span class="c3">);<br>Matcher matcher =
                        pattern.matcher(input);</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Apoi, pentru a c&#259;uta potriviri, se apeleaz&#259; metoda </span><span
            class="c2">matches()</span><span class="c4">&nbsp;a obiectului Matcher:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c6">import</span><span
                        class="c3">&nbsp;java.util.regex.Matcher;<br></span><span class="c6">import</span><span
                        class="c3">&nbsp;java.util.regex.Pattern;<br> <br></span><span class="c6">public</span><span
                        class="c3">&nbsp;</span><span class="c6">class</span><span class="c3">&nbsp;</span><span
                        class="c5">StringsApp</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c3">&nbsp;</span><span class="c6">static</span><span
                        class="c3">&nbsp;</span><span class="c6">void</span><span class="c3">&nbsp;</span><span
                        class="c5">main</span><span class="c3">(String[] args) {<br> &nbsp; &nbsp; &nbsp; &nbsp;String
                        input = </span><span class="c10">&quot;Hello&quot;</span><span class="c3">;<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;Pattern pattern = Pattern.compile(</span><span
                        class="c10">&quot;Hello&quot;</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Matcher
                        matcher = pattern.matcher(input);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c6">boolean</span><span class="c3">&nbsp;found = matcher.matches();<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c6">if</span><span class="c3">(found)<br> &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp; &nbsp;System.out.println(</span><span
                        class="c10">&quot;G&#259;sit&quot;</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c6">else</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp;System.out.println(</span><span class="c10">&quot;Nu a fost
                        g&#259;sit&quot;</span><span class="c3">);<br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">Un exemplu mai func&#539;ional, care caut&#259; potriviri par&#539;iale &icirc;ntr-un
            &#537;ir:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c6">import</span><span
                        class="c3">&nbsp;java.util.regex.Matcher;<br></span><span class="c6">import</span><span
                        class="c3">&nbsp;java.util.regex.Pattern;<br> <br></span><span class="c6">public</span><span
                        class="c3">&nbsp;</span><span class="c6">class</span><span class="c3">&nbsp;</span><span
                        class="c5">StringsApp</span><span class="c3">&nbsp;{<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c3">&nbsp;</span><span class="c6">static</span><span
                        class="c3">&nbsp;</span><span class="c6">void</span><span class="c3">&nbsp;</span><span
                        class="c5">main</span><span class="c3">(String[] args) {<br> &nbsp; &nbsp; &nbsp; &nbsp;String
                        input = </span><span class="c10">&quot;Hello Java! Hello JavaScript! JavaSE 8.&quot;</span><span
                        class="c3">;<br> &nbsp; &nbsp; &nbsp; &nbsp;Pattern pattern = Pattern.compile(</span><span
                        class="c10">&quot;Java(\\w*)&quot;</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;Matcher matcher = pattern.matcher(input);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c6">while</span><span class="c3">(matcher.find())<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp;System.out.println(matcher.group());<br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">S&#259; presupunem c&#259; dorim s&#259; g&#259;sim &icirc;n &#537;ir toate
            apari&#539;iile cuv&acirc;ntului &quot;Java&quot;. &Icirc;n &#537;irul surs&#259;, aceste apari&#539;ii
            sunt: &quot;Java&quot;, &quot;JavaScript&quot; &#537;i &quot;JavaSE&quot;. Pentru aceasta, folosim
            &#537;ablonul &quot;Java(\\w*)&quot;. Acest &#537;ablon specific&#259; faptul c&#259; toate potrivirile
            trebuie s&#259; &icirc;nceap&#259; cu &quot;Java&quot;, iar expresia (\\w*) permite ca dup&#259;
            &quot;Java&quot; s&#259; apar&#259; orice num&#259;r de caractere alfanumerice. Expresia \\w reprezint&#259;
            un caracter alfanumeric, iar asteriscul indic&#259; un num&#259;r indefinit de astfel de caractere. Pentru a
            ne asigura c&#259; Java nu interpreteaz&#259; \\w ca o secven&#539;&#259; de escape, folosim o alt&#259;
            bar&#259; invers&#259; pentru a o sc&#259;pa.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Apoi, folosim metoda</span><span class="c11 c14">&nbsp;find() </span><span
            class="c11">a clasei Matcher pentru a trece la urm&#259;toarea potrivire &icirc;n &#537;ir. Fiecare apel al
            metodei va g&#259;si urm&#259;toarea potrivire. Cu ajutorul ciclului </span><span
            class="c11 c14">while(matcher.find())</span><span class="c11">, putem parcurge toate potrivirile. Fiecare
            potrivire poate fi ob&#539;inut&#259; cu metoda </span><span class="c11 c14">matcher.group()</span><span
            class="c4">. Rezultatul va fi:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">Java<br>JavaScript<br>JavaSE</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c16">&Icirc;nlocuirea &icirc;ntr-un &#537;ir.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Acum vom &icirc;nlocui toate potrivirile folosind metoda </span><span
            class="c11 c14">replaceAll()</span><span class="c4">:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">String input = </span><span class="c10">&quot;Hello Java! Hello
                        JavaScript! JavaSE 8.&quot;</span><span class="c3">;<br>Pattern pattern =
                        Pattern.compile(</span><span class="c10">&quot;Java(\\w*)&quot;</span><span
                        class="c3">);<br>Matcher matcher = pattern.matcher(input);<br>String newStr =
                        matcher.replaceAll(</span><span class="c10">&quot;HTML&quot;</span><span
                        class="c3">);<br>System.out.println(newStr); </span><span class="c9">// Hello HTML! Hello HTML!
                        HTML 8.</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">De asemenea, clasa String are o metod&#259; </span><span
            class="c11 c14">replaceAll() </span><span class="c4">cu func&#539;ionalitate similar&#259;:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">String input = </span><span class="c10">&quot;Hello Java! Hello
                        JavaScript! JavaSE 8.&quot;</span><span class="c3">;<br>String myStr =
                        input.replaceAll(</span><span class="c10">&quot;Java(\\w*)&quot;</span><span class="c3">,
                    </span><span class="c10">&quot;HTML&quot;</span><span class="c3">);<br>System.out.println(myStr);
                    </span><span class="c9">// Hello HTML! Hello HTML! HTML 8.</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c16">&Icirc;mp&#259;r&#539;irea &#537;irului &icirc;n lexeme.</span></p>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c11">Cu ajutorul metodei </span><span class="c2">String[] split(CharSequence
            input)</span><span class="c4">&nbsp;din clasa Pattern putem &icirc;mp&#259;r&#539;i un &#537;ir
            &icirc;ntr-un tablou de sub&#537;iruri pe baza unui separator. De exemplu, putem extrage cuvintele dintr-un
            &#537;ir:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c6">import</span><span class="c3">&nbsp;java.util.regex.Pattern;<br>
                        <br></span><span class="c6">public</span><span class="c3">&nbsp;</span><span
                        class="c6">class</span><span class="c3">&nbsp;</span><span class="c5">StringsApp</span><span
                        class="c3">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c3">&nbsp;</span><span class="c6">static</span><span class="c3">&nbsp;</span><span
                        class="c6">void</span><span class="c3">&nbsp;</span><span class="c5">main</span><span
                        class="c3">(String[] args) {<br> &nbsp; &nbsp; &nbsp; &nbsp;String input = </span><span
                        class="c10">&quot;Hello Java! Hello JavaScript! JavaSE 8.&quot;</span><span class="c3">;<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;Pattern pattern = Pattern.compile(</span><span class="c10">&quot;[
                        ,.!?]&quot;</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp; &nbsp;String[] words =
                        pattern.split(input);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">for</span><span
                        class="c3">(String word : words)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp;System.out.println(word);<br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">&#536;i rezultatul va fi:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13"></tr>
    </table>
    <p class="c8"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">Hello<br>Java<br><br>Hello<br>JavaScript<br><br>JavaSE<br></span><span
                        class="c17">8</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">&Icirc;n acest proces, to&#539;i separatorii sunt elimina&#539;i. Totu&#537;i,
            aceast&#259; metod&#259; nu este perfect&#259;, deoarece r&#259;m&acirc;n unele spa&#539;ii care sunt
            considerate lexeme. Pentru o &icirc;mp&#259;r&#539;ire mai precis&#259;, ar trebui s&#259; folosim
            elementele expresiilor regulate. Astfel, putem &icirc;nlocui &#537;ablonul cu urm&#259;torul:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">Pattern pattern = Pattern.compile(</span><span
                        class="c10">&quot;\\s*(\\s|,|!|\\.)\\s*&quot;</span><span class="c3">);</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
    <p class="c1"><span class="c4">Acum vor r&#259;m&acirc;ne doar cuvintele:</span></p>
    <p class="c0"><span class="c4"></span></p>
    <table class="c7">
        <tr class="c13">
            <td class="c15" colspan="1" rowspan="1">
                <p class="c12"><span class="c3">Hello<br>Java<br>Hello<br>JavaScript<br>JavaSE<br></span><span
                        class="c17">8</span></p>
            </td>
        </tr>
    </table>
    <p class="c0"><span class="c4"></span></p>
</body>

</html>