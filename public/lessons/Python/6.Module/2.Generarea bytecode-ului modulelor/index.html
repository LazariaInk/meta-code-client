<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c21 doc-content">
    <h1 class="c3 c9">Generarea bytecode-ului modulelor.</h1>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c1">La executarea unui script &icirc;n limbajul Python, execu&#539;ia este, &icirc;n
            general, &icirc;mp&#259;r&#539;it&#259; &icirc;n dou&#259; etape:</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <ol class="c12 lst-kix_ypp7nbfsgtym-0 start" start="1">
        <li class="c3 c6 li-bullet-0"><span class="c2">Fi&#537;ierul cu codul (fi&#537;ierul cu extensia </span><span
                class="c11">.py</span><span class="c1">) este compilat &icirc;ntr-un bytecode intermediar</span></li>
    </ol>
    <p class="c3 c4 c20"><span class="c1"></span></p>
    <ol class="c12 lst-kix_ypp7nbfsgtym-0" start="2">
        <li class="c3 c6 li-bullet-0"><span class="c1">Apoi bytecode-ul compilat este interpretat, adic&#259; are loc
                execu&#539;ia propriu-zis&#259; a programului</span></li>
    </ol>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">&Icirc;n acest proces, nu trebuie s&#259; gener&#259;m explicit niciun bytecode;
            acesta este creat implicit &icirc;n timpul execu&#539;iei scriptului Python. Dac&#259; programul
            import&#259; module/biblioteci externe &#537;i acestea sunt importate pentru prima dat&#259;, bytecode-ul
            lor compilat este salvat &icirc;ntr-un fi&#537;ier cu extensia</span><span
            class="c11">&nbsp;.pyc</span><span class="c2">&nbsp;&#537;i este stocat &icirc;n directorul </span><span
            class="c11">__pycache__</span><span class="c2">&nbsp;din folderul &icirc;n care se afl&#259; fi&#537;ierul
            cu codul Python. Dac&#259; aducem modific&#259;ri &icirc;n fi&#537;ierul surs&#259; al bibliotecii, Python
            recompileaz&#259; fi&#537;ierul bytecode. Dac&#259; nu exist&#259; modific&#259;ri &icirc;n cod, este
            &icirc;nc&#259;rcat bytecode-ul compilat anterior din fi&#537;ierul </span><span
            class="c11">*.pyc</span><span class="c1">. Acest lucru permite optimizarea lucrului cu aplica&#539;ia,
            compilarea &#537;i execu&#539;ia ei mai rapid&#259;.</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">Cu toate acestea, bytecode-ul scriptului principal, care reprezint&#259;
            fi&#537;ierul principal al programului &#537;i care este transmis interpretului Python, nu este salvat
            &icirc;n fi&#537;ierul </span><span class="c11">*.pyc</span><span class="c1">&nbsp;&#537;i este recompilat
            de fiecare dat&#259; la lansarea aplica&#539;iei.</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">S&#259; presupunem c&#259; &icirc;n folderul proiectului avem un fi&#537;ier
        </span><span class="c11">user.py </span><span class="c1">cu o func&#539;ie simpl&#259; care prime&#537;te doi
            parametri &#537;i afi&#537;eaz&#259; valorile lor:</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <table class="c13">
        <tr class="c17">
            <td class="c8" colspan="1" rowspan="1">
                <p class="c10"><span class="c14">def</span><span class="c0">&nbsp;</span><span
                        class="c18">printUser</span><span class="c0">(username, userage):<br> &nbsp;
                        &nbsp;print(</span><span class="c19">f&quot;Name: {username}
                        &nbsp;Age:{userage}&quot;</span><span class="c0">)</span></p>
            </td>
        </tr>
    </table>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">Conect&#259;m acest fi&#537;ier &icirc;n modulul principal al programului, pe care
            &icirc;l vom numi </span><span class="c11">app.py</span><span class="c1">:</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <table class="c13">
        <tr class="c17">
            <td class="c8" colspan="1" rowspan="1">
                <p class="c10"><span class="c14">import</span><span class="c0">&nbsp;user<br>username = </span><span
                        class="c19">&quot;Tom&quot;</span><span class="c0"><br>userage = </span><span
                        class="c22">39</span><span class="c0"><br><br>user.printUser(username, userage)</span></p>
            </td>
        </tr>
    </table>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">La executarea acestui script, &icirc;n folderul proiectului (unde se afl&#259;
            modulul &quot;user.py&quot;) va fi creat directorul </span><span class="c11">__pycache__</span><span
            class="c2">. &Icirc;n acesta va fi generat un fi&#537;ier bytecode, care va fi similar cu </span><span
            class="c2 c16">user.cpython-versiune.pyc</span><span class="c2">, unde versiunea va corespunde versiunii
            interpretului utilizat, de exemplu, 311 (pentru versiunea Python 3.11). Fi&#537;ierul </span><span
            class="c11">pyc</span><span class="c1">&nbsp;generat este binar, deci nu are sens s&#259; fie deschis
            &icirc;ntr-un editor de text.</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 257.00px; height: 162.00px;"><img
                alt="" src="images/image1.png"
                style="width: 257.00px; height: 162.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c5">Compilarea manual&#259; a bytecode-ului.</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">De&#537;i fi&#537;ierul bytecode este creat automat, putem s&#259;-l gener&#259;m
            manual. Exist&#259; c&acirc;teva metode pentru acest lucru: compilarea cu ajutorul scriptului </span><span
            class="c11">py_compile</span><span class="c2">&nbsp;&#537;i compilarea cu ajutorul modulului </span><span
            class="c11">compileall</span><span class="c1">.</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">Scriptul</span><span class="c11">&nbsp;py_compile</span><span class="c2">&nbsp;este
            utilizat pentru compilarea fi&#537;ierelor individuale. Pentru a compila un script arbitrar,</span><span
            class="c11">&nbsp;user.py</span><span class="c1">, &icirc;ntr-un fi&#537;ier cu bytecode, am putea folosi
            urm&#259;torul program:</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <table class="c13">
        <tr class="c17">
            <td class="c8" colspan="1" rowspan="1">
                <p class="c10"><span class="c14">import</span><span
                        class="c0">&nbsp;py_compile<br><br>py_compile.compile(</span><span
                        class="c19">&quot;user.py&quot;</span><span class="c0">) &nbsp; </span><span class="c7">#
                        transmitem calea c&#259;tre script</span></p>
            </td>
        </tr>
    </table>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">Pentru compilare, transmitem calea c&#259;tre script func&#539;iei </span><span
            class="c2 c16">compile()</span><span class="c2">. Dup&#259; execu&#539;ia programului, &icirc;n folderul
            curent va fi generat &#537;i un director </span><span class="c11">__pycache__</span><span class="c2">, iar
            &icirc;n el un fi&#537;ier</span><span class="c11 c15">&nbsp;user.cpython-311.pyc</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">Modulul </span><span class="c11">compileall </span><span class="c2">este utilizat
            pentru a compila toate fi&#537;ierele Python din anumite loca&#539;ii. De exemplu, vom compila toate
            fi&#537;ierele din directorul </span><span class="c15 c11">C:/python/files</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <table class="c13">
        <tr class="c17">
            <td class="c8" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">python -m compileall c:\python\files</span></p>
            </td>
        </tr>
    </table>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3"><span class="c2">&Icirc;n mod implicit, sunt compilate chiar &#537;i acele fi&#537;iere care se
            afl&#259; &icirc;n subdirectoare. Dac&#259; dorim s&#259; compil&#259;m doar fi&#537;ierele care se
            afl&#259; direct &icirc;n folderul specificat, se utilizeaz&#259; op&#539;iunea </span><span
            class="c15 c11">-l</span></p>
    <p class="c3 c4"><span class="c1"></span></p>
    <table class="c13">
        <tr class="c17">
            <td class="c8" colspan="1" rowspan="1">
                <p class="c10"><span class="c0">python -m compileall c:\python\files -l</span></p>
            </td>
        </tr>
    </table>
    <p class="c3 c4"><span class="c1"></span></p>
    <p class="c3 c4"><span class="c1"></span></p>
</body>

</html>