<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" type="text/css" href="/lessons/styles.css">
</head>

<body class="c18 doc-content">
    <h1 class="c1 c11 c17">Clase È™i metode abstracte.</h1>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">De obicei, clasele reflect&#259; anumite obiecte din realitatea
            &icirc;nconjur&#259;toare. &Icirc;ns&#259; uneori lucr&#259;m cu entit&#259;&#539;i care nu au o
            &icirc;ntruchipare concret&#259;. De exemplu, entitatea &bdquo;animal&rdquo;. Exist&#259; animale concrete -
            pisic&#259;, c&acirc;ine &#537;i a&#537;a mai departe, dar animalul ca atare nu are o &icirc;ntruchipare
            concret&#259;. Sau entitatea &bdquo;figur&#259; geometric&#259;&rdquo;. Exist&#259; dreptunghi, p&#259;trat,
            cerc, triunghi, dar figura geometric&#259; &icirc;n sine nu are o &icirc;ntruchipare concret&#259;. De
            obicei, pentru a descrie astfel de entit&#259;&#539;i se folosesc</span><span class="c8">&nbsp;clase
            abstracte</span><span class="c11 c10">.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">&Icirc;n limbajul Python, toate instrumentele pentru crearea claselor abstracte sunt
            definite &icirc;ntr-un modul special numit </span><span class="c8">abc</span><span class="c11 c10">, care
            trebuie s&#259; fie inclus suplimentar &icirc;n aplica&#539;ie.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p><a id="t.a65d84bfc215e903130aedf1ebc03d328981c09c"></a><a
        id="t.0"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">Componenta cheie a acestui modul este clasa </span><span class="c8">ABC </span><span
            class="c10">&#537;i adnotarea</span><span class="c8">&nbsp;@abstractmethod</span><span class="c10">. Clasa
            ABC simplific&#259; crearea unei clase abstracte, iar toate clasele abstracte definite sunt derivate din
            aceast&#259; clas&#259;. Adnotarea </span><span class="c8">@abstractmethod</span><span
            class="c11 c10">&nbsp;este destinat&#259; cre&#259;rii unei metode abstracte.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">Clasele abstracte sunt definite ca &#537;i clasele obi&#537;nuite, cu excep&#539;ia
            faptului c&#259; acestea sunt derivate din clasa </span><span class="c8">ABC </span><span
            class="c11 c10">din modulul abc. De exemplu, s&#259; definim o clas&#259; abstract&#259; pentru o
            figur&#259; geometric&#259;:</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p><a id="t.70a59e89192d4750c0f7f1e2925f979818e9429e"></a><a
        id="t.1"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc<br><br></span><span
                        class="c4">class</span><span class="c0">&nbsp;</span><span class="c7">Shape</span><span
                        class="c0">(abc.ABC):<br> &nbsp; &nbsp;</span><span class="c4">pass</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">De obicei, clasele abstracte declar&#259; un anumit func&#539;ional comun pentru
            clasele derivate. &Icirc;n plus, unele func&#539;ionalit&#259;&#539;i pot s&#259; nu aib&#259; nicio
            implementare - implementarea acestora trebuie s&#259; fie definit&#259; de clasele derivate. Acest tip de
            func&#539;ionalitate este reprezentat &icirc;n cadrul clasei prin metode abstracte. De exemplu, clasa
            figurii geometrice poate avea metode pentru calcularea perimetrului, a ariei etc. Nu putem defini o
            formul&#259; general&#259; pentru calcularea ariei tuturor figurilor - pentru fiecare figur&#259;
            concret&#259;, principiul de calcul al ariei poate fi diferit. Prin urmare, &icirc;n clasa figurii putem
            defini metoda de calcul al ariei ca abstract&#259;. Pentru aceasta se folose&#537;te adnotarea </span><span
            class="c8">@abstractmethod</span><span class="c11 c10">&nbsp;din modulul abc:</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p><a id="t.9bdc159a2c14247a8f41d0f0ce23beb179b0178a"></a><a
        id="t.2"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc<br><br></span><span
                        class="c4">class</span><span class="c0">&nbsp;</span><span class="c7">Shape</span><span
                        class="c0">(abc.ABC):<br></span><span class="c15">&nbsp; &nbsp; @abc.abstractmethod</span><span
                        class="c0"><br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">pass</span><span class="c0">&nbsp; </span><span
                        class="c9"># aria figurii</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">&Icirc;n acest caz, metoda</span><span class="c10 c16">&nbsp;area()</span><span
            class="c10">&nbsp;este definit&#259; ca abstract&#259;. Deoarece nu are nevoie de o func&#539;ionalitate
            concret&#259;, &icirc;n interiorul ei este folosit operatorul </span><span class="c10 c16">pass</span><span
            class="c11 c10">.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c11 c10">Este important de men&#539;ionat c&#259; nu putem crea direct un obiect al unei
            clase abstracte cu metode abstracte, folosind constructorul s&#259;u:</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p><a id="t.07b2b964596dbbbd5151dcae552dd6ed71c2f935"></a><a
        id="t.3"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc<br><br></span><span
                        class="c4">class</span><span class="c0">&nbsp;</span><span class="c7">Shape</span><span
                        class="c0">(abc.ABC):<br></span><span class="c15">&nbsp; &nbsp; @abc.abstractmethod</span><span
                        class="c0"><br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">pass</span><span class="c0">&nbsp; </span><span
                        class="c9"># aria figurii</span><span class="c0"><br><br>shape = Shape() &nbsp;</span><span
                        class="c9"># ! Eroare - acest lucru nu este permis</span><span
                        class="c0"><br>print(shape)</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">Clasele derivate </span><span class="c8">trebuie </span><span
            class="c11 c10">s&#259; implementeze toate metodele abstracte ale clasei abstracte. De exemplu, s&#259;
            definim clasa pentru un dreptunghi:</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p><a id="t.8dcd3e1688cdbbc6e8bc9a86f5b97771469f51f6"></a><a
        id="t.4"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc<br><br></span><span
                        class="c4">class</span><span class="c0">&nbsp;</span><span class="c7">Shape</span><span
                        class="c0">(abc.ABC):<br></span><span class="c15">&nbsp; &nbsp; @abc.abstractmethod</span><span
                        class="c0"><br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">pass</span><span class="c0">&nbsp; </span><span
                        class="c9"># aria figurii</span><span class="c0"><br><br></span><span class="c9"># clasa
                        dreptunghiului</span><span class="c0"><br></span><span class="c4">class</span><span
                        class="c0">&nbsp;</span><span class="c7">Rectangle</span><span class="c0">(Shape):<br> &nbsp;
                        &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">__init__</span><span class="c0">(self, width, height):<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;self.width = width<br> &nbsp; &nbsp; &nbsp; &nbsp;self.height = height<br><br> &nbsp;
                        &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c0">&nbsp;self.width * self.height<br><br>rect =
                        Rectangle(</span><span class="c13">30</span><span class="c0">, </span><span
                        class="c13">50</span><span class="c0">)<br>print(</span><span class="c14">&quot;Rectangle
                        area:&quot;</span><span class="c0">, rect.area()) &nbsp;</span><span class="c9"># Rectangle
                        area: 1500</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c10">Aici, clasa dreptunghiului Rectangle prime&#537;te prin constructor
            l&#259;&#539;imea &#537;i &icirc;n&#259;l&#539;imea &#537;i le folose&#537;te pentru a calcula aria &icirc;n
            metoda </span><span class="c10 c16">area()</span><span class="c11 c10">.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c11 c10">&Icirc;n mod similar, putem defini &#537;i alte tipuri de figuri. De exemplu,
            s&#259; ad&#259;ug&#259;m clasa pentru un cerc:</span></p>
    <p class="c1 c12"><span class="c10 c11"></span></p><a id="t.043b2a8074235afe54c62168eb6a75c8c0935e59"></a><a
        id="t.5"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc<br><br></span><span
                        class="c4">class</span><span class="c0">&nbsp;</span><span class="c7">Shape</span><span
                        class="c0">(abc.ABC):<br></span><span class="c15">&nbsp; &nbsp; @abc.abstractmethod</span><span
                        class="c0"><br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">pass</span><span class="c0">&nbsp; </span><span
                        class="c9"># aria figurii</span><span class="c0"><br><br></span><span class="c9"># clasa
                        dreptunghiului</span><span class="c0"><br></span><span class="c4">class</span><span
                        class="c0">&nbsp;</span><span class="c7">Rectangle</span><span class="c0">(Shape):<br> &nbsp;
                        &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">__init__</span><span class="c0">(self, width, height):<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;self.width = width<br> &nbsp; &nbsp; &nbsp; &nbsp;self.height = height<br><br> &nbsp;
                        &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c4">return</span><span class="c0">&nbsp;self.width * self.height<br><br></span><span
                        class="c9"># clasa cercului</span><span class="c0"><br></span><span class="c4">class</span><span
                        class="c0">&nbsp;</span><span class="c7">Circle</span><span class="c0">(Shape):<br> &nbsp;
                        &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">__init__</span><span class="c0">(self, radius):<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;self.radius = radius<br><br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">return</span><span class="c0">&nbsp;self.radius *
                        self.radius * </span><span class="c13">3.14</span><span class="c0"><br><br></span><span
                        class="c4">def</span><span class="c0">&nbsp;</span><span class="c7">print_area</span><span
                        class="c0">(shape):<br> &nbsp; &nbsp;print(</span><span
                        class="c14">&quot;Area:&quot;</span><span class="c0">, shape.area())<br><br>rect =
                        Rectangle(</span><span class="c13">30</span><span class="c0">, </span><span
                        class="c13">50</span><span class="c0">)<br>circle = Circle(</span><span
                        class="c13">30</span><span class="c0">)<br>print_area(rect) &nbsp;</span><span class="c9">#
                        Area: 1500</span><span class="c0"><br>print_area(circle) &nbsp;</span><span class="c9"># Area:
                        2826.0</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c11 c10">&Icirc;n acest caz, pentru a afi&#537;a aria figurii, a fost definit&#259;
            func&#539;ia print_area, care accept&#259; orice figur&#259;.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c11 c10">&Icirc;n acela&#537;i timp, clasele abstracte pot defini &#537;i constructori,
            atribute, metode neabstracte, care pot fi folosite &#537;i &icirc;n clasele derivate:</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p><a id="t.59b609347abac447ea97bc96d999e715e850e86e"></a><a
        id="t.6"></a>
    <table class="c2">
        <tr class="c6">
            <td class="c3" colspan="1" rowspan="1">
                <p class="c5"><span class="c4">import</span><span class="c0">&nbsp;abc<br><br></span><span
                        class="c4">class</span><span class="c0">&nbsp;</span><span class="c7">Shape</span><span
                        class="c0">(abc.ABC):<br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">__init__</span><span class="c0">(self, x, y):<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;self.x = x<br> &nbsp; &nbsp; &nbsp; &nbsp;self.y =
                        y<br><br></span><span class="c15">&nbsp; &nbsp; @abc.abstractmethod</span><span class="c0"><br>
                        &nbsp; &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c4">pass</span><span class="c0">&nbsp; </span><span class="c9"># metod&#259;
                        abstract&#259;</span><span class="c0"><br><br> &nbsp; &nbsp;</span><span
                        class="c4">def</span><span class="c0">&nbsp;</span><span class="c7">print_point</span><span
                        class="c0">(self): &nbsp;</span><span class="c9"># metod&#259; neabstract&#259;</span><span
                        class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;print(</span><span
                        class="c14">&quot;X:&quot;</span><span class="c0">, self.x, </span><span
                        class="c14">&quot;\tY:&quot;</span><span class="c0">, self.y)<br><br></span><span class="c9">#
                        clasa dreptunghiului</span><span class="c0"><br></span><span class="c4">class</span><span
                        class="c0">&nbsp;</span><span class="c7">Rectangle</span><span class="c0">(Shape):<br> &nbsp;
                        &nbsp;</span><span class="c4">def</span><span class="c0">&nbsp;</span><span
                        class="c7">__init__</span><span class="c0">(self, x, y, width, height):<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;super().__init__(x, y)<br> &nbsp; &nbsp; &nbsp; &nbsp;self.width = width<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;self.height = height<br><br> &nbsp; &nbsp;</span><span class="c4">def</span><span
                        class="c0">&nbsp;</span><span class="c7">area</span><span class="c0">(self):<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;</span><span class="c4">return</span><span class="c0">&nbsp;self.width *
                        self.height<br><br>rect = Rectangle(</span><span class="c13">10</span><span class="c0">,
                    </span><span class="c13">20</span><span class="c0">, </span><span class="c13">100</span><span
                        class="c0">, </span><span class="c13">100</span><span class="c0">)<br>rect.print_point()
                        &nbsp;</span><span class="c9"># X: 10 &nbsp; Y: 20</span></p>
            </td>
        </tr>
    </table>
    <p class="c1 c12"><span class="c11 c10"></span></p>
    <p class="c1"><span class="c11 c10">Aici, clasa abstract&#259; Shape prime&#537;te prin constructor coordonatele X
            &#537;i Y pentru un punct, &icirc;n raport cu care este creat&#259; figura (de exemplu, pentru un
            dreptunghi, acestea pot fi coordonatele col&#539;ului din st&acirc;nga sus, pentru un cerc - centrul). De
            asemenea, este definit&#259; o metod&#259; neabstract&#259; print_point, care afi&#537;eaz&#259;
            coordonatele punctului pe consol&#259;.</span></p>
    <p class="c1 c12"><span class="c11 c10"></span></p>
</body>

</html>