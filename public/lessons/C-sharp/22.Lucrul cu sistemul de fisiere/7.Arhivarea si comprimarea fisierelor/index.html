<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ul.lst-kix_prt1ufiqdeaw-2{list-style-type:none}ul.lst-kix_prt1ufiqdeaw-3{list-style-type:none}ul.lst-kix_prt1ufiqdeaw-4{list-style-type:none}ul.lst-kix_prt1ufiqdeaw-5{list-style-type:none}ul.lst-kix_prt1ufiqdeaw-6{list-style-type:none}ul.lst-kix_prt1ufiqdeaw-7{list-style-type:none}ul.lst-kix_prt1ufiqdeaw-8{list-style-type:none}.lst-kix_prt1ufiqdeaw-1>li:before{content:"\0025cb   "}ul.lst-kix_prt1ufiqdeaw-0{list-style-type:none}.lst-kix_prt1ufiqdeaw-2>li:before{content:"\0025a0   "}ul.lst-kix_prt1ufiqdeaw-1{list-style-type:none}.lst-kix_prt1ufiqdeaw-3>li:before{content:"\0025cf   "}.lst-kix_prt1ufiqdeaw-4>li:before{content:"\0025cb   "}.lst-kix_wc52fgcv7l5p-2>li:before{content:"\0025a0   "}.lst-kix_wc52fgcv7l5p-0>li:before{content:"\0025cf   "}.lst-kix_wc52fgcv7l5p-1>li:before{content:"\0025cb   "}.lst-kix_jsgoh1xcvq1h-8>li:before{content:"\0025a0   "}ul.lst-kix_wc52fgcv7l5p-8{list-style-type:none}.lst-kix_jsgoh1xcvq1h-7>li:before{content:"\0025cb   "}ul.lst-kix_wc52fgcv7l5p-4{list-style-type:none}.lst-kix_jsgoh1xcvq1h-5>li:before{content:"\0025a0   "}ul.lst-kix_wc52fgcv7l5p-5{list-style-type:none}.lst-kix_prt1ufiqdeaw-0>li:before{content:"\0025cf   "}ul.lst-kix_wc52fgcv7l5p-6{list-style-type:none}.lst-kix_jsgoh1xcvq1h-6>li:before{content:"\0025cf   "}ul.lst-kix_wc52fgcv7l5p-7{list-style-type:none}ul.lst-kix_wc52fgcv7l5p-0{list-style-type:none}ul.lst-kix_wc52fgcv7l5p-1{list-style-type:none}ul.lst-kix_wc52fgcv7l5p-2{list-style-type:none}ul.lst-kix_wc52fgcv7l5p-3{list-style-type:none}.lst-kix_jsgoh1xcvq1h-3>li:before{content:"\0025cf   "}ul.lst-kix_jsgoh1xcvq1h-1{list-style-type:none}ul.lst-kix_jsgoh1xcvq1h-0{list-style-type:none}.lst-kix_jsgoh1xcvq1h-0>li:before{content:"\0025cf   "}.lst-kix_jsgoh1xcvq1h-4>li:before{content:"\0025cb   "}ul.lst-kix_jsgoh1xcvq1h-7{list-style-type:none}ul.lst-kix_jsgoh1xcvq1h-6{list-style-type:none}ul.lst-kix_jsgoh1xcvq1h-8{list-style-type:none}.lst-kix_jsgoh1xcvq1h-1>li:before{content:"\0025cb   "}ul.lst-kix_jsgoh1xcvq1h-3{list-style-type:none}ul.lst-kix_jsgoh1xcvq1h-2{list-style-type:none}.lst-kix_jsgoh1xcvq1h-2>li:before{content:"\0025a0   "}ul.lst-kix_jsgoh1xcvq1h-5{list-style-type:none}ul.lst-kix_jsgoh1xcvq1h-4{list-style-type:none}.lst-kix_prt1ufiqdeaw-6>li:before{content:"\0025cf   "}.lst-kix_prt1ufiqdeaw-7>li:before{content:"\0025cb   "}.lst-kix_wc52fgcv7l5p-3>li:before{content:"\0025cf   "}.lst-kix_prt1ufiqdeaw-5>li:before{content:"\0025a0   "}.lst-kix_wc52fgcv7l5p-4>li:before{content:"\0025cb   "}.lst-kix_wc52fgcv7l5p-5>li:before{content:"\0025a0   "}.lst-kix_wc52fgcv7l5p-6>li:before{content:"\0025cf   "}.lst-kix_wc52fgcv7l5p-7>li:before{content:"\0025cb   "}.lst-kix_prt1ufiqdeaw-8>li:before{content:"\0025a0   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_wc52fgcv7l5p-8>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c15{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c12{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Open Sans";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c7{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c18{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c17{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c2{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c13{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#a2fca2;font-weight:400}.c4{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c6{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c16{border-spacing:0;border-collapse:collapse;margin-right:auto}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c21{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c22{color:#000000;text-decoration:none;vertical-align:baseline}.c9{font-size:12pt;font-family:"Open Sans";font-weight:700}.c1{font-size:12pt;font-family:"Open Sans";font-weight:400}.c3{padding:0;margin:0}.c11{margin-left:36pt;padding-left:0pt}.c19{height:0pt}.c8{font-style:italic}.c10{height:11pt}.c20{margin-left:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c21 doc-content"><p class="c5"><span class="c7">Arhivarea &#537;i comprimarea fi&#537;ierelor. &nbsp;</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Pe l&acirc;ng&#259; clasele de citire &#537;i scriere, .NET ofer&#259; &#537;i clase care permit comprimarea fi&#537;ierelor &#537;i apoi restaurarea lor &icirc;n starea ini&#539;ial&#259;.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Aceste clase sunt </span><span class="c9">ZipFile</span><span class="c1">, </span><span class="c9">DeflateStream </span><span class="c1">&#537;i </span><span class="c9">GZipStream</span><span class="c1">, care se afl&#259; &icirc;n spa&#539;iul de nume </span><span class="c9">System.IO.Compression</span><span class="c0">&nbsp;&#537;i implementeaz&#259; algoritmi de comprimare precum Deflate sau GZip.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c12">GZipStream &#537;i DeflateStream.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Pentru a crea un obiect </span><span class="c9">GZipStream</span><span class="c0">, se poate folosi unul dintre constructorii s&#259;i:</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">GZipStream(Stream stream, CompressionLevel level)</span><span class="c0">: stream reprezint&#259; datele, iar level seteaz&#259; nivelul de comprimare.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">GZipStream(Stream stream, CompressionMode mode)</span><span class="c0">: mode indic&#259; dac&#259; datele vor fi comprimate sau restaurate &#537;i poate avea dou&#259; valori:</span></p><p class="c5 c10"><span class="c0"></span></p><ul class="c3 lst-kix_jsgoh1xcvq1h-0 start"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; </span><span class="c1 c8">&nbsp;CompressionMode.Compress</span><span class="c0">: datele sunt comprimate.</span></li></ul><p class="c5 c10 c20"><span class="c0"></span></p><ul class="c3 lst-kix_jsgoh1xcvq1h-0"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c8">CompressionMode.Decompress</span><span class="c0">: datele sunt restaurate.</span></li></ul><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Dac&#259; datele sunt comprimate, stream indic&#259; fluxul datelor care urmeaz&#259; s&#259; fie arhivate. Dac&#259; datele sunt restaurate, stream indic&#259; fluxul &icirc;n care vor fi transferate datele restaurate.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">GZipStream(Stream stream, CompressionLevel level, bool leaveOpen)</span><span class="c0">: parametrul leaveOpen indic&#259; dac&#259; fluxul stream trebuie l&#259;sat deschis dup&#259; ce obiectul GZipStream este eliminat. Dac&#259; valoarea este true, fluxul r&#259;m&acirc;ne deschis.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8 c22">GZipStream(Stream stream, CompressionMode mode, bool leaveOpen)</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Pentru a gestiona comprimarea/restaurarea datelor, GZipStream ofer&#259; o serie de metode esen&#539;iale:</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">-</span><span class="c1 c8">&nbsp;void CopyTo(Stream destination)</span><span class="c0">: copiaz&#259; toate datele &icirc;n fluxul destination.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">Task CopyToAsync(Stream destination)</span><span class="c0">: versiunea asincron&#259; a metodei CopyTo.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">void Flush()</span><span class="c0">: cur&#259;&#539;&#259; bufferul, scriind toate datele &icirc;n fi&#537;ier.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">Task FlushAsync()</span><span class="c0">: versiunea asincron&#259; a metodei Flush.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">- int Read(byte[] array, int offset, int count): cite&#537;te datele din fi&#537;ier &icirc;ntr-un array de bytes &#537;i returneaz&#259; num&#259;rul de bytes citite. Prime&#537;te trei parametri:</span></p><p class="c5 c10"><span class="c0"></span></p><ul class="c3 lst-kix_wc52fgcv7l5p-0 start"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c8">array</span><span class="c0">: array-ul de bytes &icirc;n care vor fi plasate datele citite din fi&#537;ier.</span></li></ul><p class="c5 c10 c20"><span class="c0"></span></p><ul class="c3 lst-kix_wc52fgcv7l5p-0"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c8">offset</span><span class="c0">: deplasarea &icirc;n bytes &icirc;n array-ul array, &icirc;n care vor fi plasate bytes-ii citi&#539;i.</span></li></ul><p class="c5 c10 c20"><span class="c0"></span></p><ul class="c3 lst-kix_wc52fgcv7l5p-0"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c8">count</span><span class="c0">: num&#259;rul maxim de bytes care urmeaz&#259; s&#259; fie citi&#539;i. Dac&#259; &icirc;n fi&#537;ier exist&#259; mai pu&#539;ini bytes, ace&#537;tia vor fi citi&#539;i to&#539;i.</span></li></ul><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">Task&lt;int&gt; ReadAsync(byte[] array, int offset, int count)</span><span class="c0">: versiunea asincron&#259; a metodei Read.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">-</span><span class="c1 c8">&nbsp;long Seek(long offset, SeekOrigin origin)</span><span class="c0">: seteaz&#259; pozi&#539;ia &icirc;n flux cu o deplasare de num&#259;rul de bytes specificat &icirc;n parametrul offset.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">void Write(byte[] array, int offset, int count)</span><span class="c0">: scrie datele din array-ul de bytes &icirc;n fi&#537;ier. Prime&#537;te trei parametri:</span></p><p class="c5 c10"><span class="c0"></span></p><ul class="c3 lst-kix_prt1ufiqdeaw-0 start"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; </span><span class="c1 c8">array</span><span class="c0">: array-ul de bytes din care datele vor fi scrise &icirc;n fi&#537;ier.</span></li></ul><p class="c5 c10 c20"><span class="c0"></span></p><ul class="c3 lst-kix_prt1ufiqdeaw-0"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; </span><span class="c1 c8">offset</span><span class="c0">: deplasarea &icirc;n bytes &icirc;n array-ul array, de unde &icirc;ncepe scrierea bytes-ilor &icirc;n flux.</span></li></ul><p class="c5 c10 c20"><span class="c0"></span></p><ul class="c3 lst-kix_prt1ufiqdeaw-0"><li class="c5 c11 li-bullet-0"><span class="c1">&nbsp; </span><span class="c1 c8">count</span><span class="c0">: num&#259;rul maxim de bytes care urmeaz&#259; s&#259; fie scri&#537;i.</span></li></ul><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">-</span><span class="c1 c8">&nbsp;Task WriteAsync(byte[] array, int offset, int count)</span><span class="c0">: versiunea asincron&#259; a metodei Write.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">S&#259; vedem un exemplu de utilizare a clasei GZipStream:</span></p><p class="c5 c10"><span class="c0"></span></p><a id="t.a96dad2f96101dfbf572f88aae3ecb7d2b380a58"></a><a id="t.0"></a><table class="c16"><tr class="c19"><td class="c15" colspan="1" rowspan="1"><p class="c14"><span class="c4">using</span><span class="c2">&nbsp;System.IO.Compression;<br> <br></span><span class="c4">string</span><span class="c2">&nbsp;sourceFile = </span><span class="c13">&quot;book.pdf&quot;</span><span class="c2">; </span><span class="c6">// fi&#537;ierul surs&#259;</span><span class="c2"><br></span><span class="c4">string</span><span class="c2">&nbsp;compressedFile = </span><span class="c13">&quot;book.gz&quot;</span><span class="c2">; </span><span class="c6">// fi&#537;ierul comprimat</span><span class="c2"><br></span><span class="c4">string</span><span class="c2">&nbsp;targetFile = </span><span class="c13">&quot;book_new.pdf&quot;</span><span class="c2">; </span><span class="c6">// fi&#537;ierul restaurat</span><span class="c2"><br> <br></span><span class="c6">// crearea fi&#537;ierului comprimat</span><span class="c2"><br></span><span class="c4">await</span><span class="c2">&nbsp;CompressAsync(sourceFile, compressedFile);<br></span><span class="c6">// citirea din fi&#537;ierul comprimat</span><span class="c2"><br></span><span class="c4">await</span><span class="c2">&nbsp;DecompressAsync(compressedFile, targetFile);<br> <br></span><span class="c4">async</span><span class="c2">&nbsp;Task </span><span class="c18">CompressAsync</span><span class="c2">(</span><span class="c4">string</span><span class="c2">&nbsp;sourceFile, </span><span class="c4">string</span><span class="c2">&nbsp;compressedFile)<br>{<br> &nbsp; &nbsp;</span><span class="c6">// flux pentru citirea fi&#537;ierului surs&#259;</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c4">using</span><span class="c2">&nbsp;FileStream sourceStream = </span><span class="c4">new</span><span class="c2">&nbsp;FileStream(sourceFile, FileMode.OpenOrCreate);<br> &nbsp; &nbsp;</span><span class="c6">// flux pentru scrierea fi&#537;ierului comprimat</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c4">using</span><span class="c2">&nbsp;FileStream targetStream = File.Create(compressedFile);<br> <br> &nbsp; &nbsp;</span><span class="c6">// fluxul de comprimare</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c4">using</span><span class="c2">&nbsp;GZipStream compressionStream = </span><span class="c4">new</span><span class="c2">&nbsp;GZipStream(targetStream, CompressionMode.Compress);<br> &nbsp; &nbsp;</span><span class="c4">await</span><span class="c2">&nbsp;sourceStream.CopyToAsync(compressionStream); </span><span class="c6">// copiem bytes dintr-un flux &icirc;n altul</span><span class="c2"><br> <br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;Comprimarea fi&#537;ierului {sourceFile} a fost finalizat&#259;.&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;Dimensiunea original&#259;: {sourceStream.Length} &nbsp;dimensiunea comprimat&#259;: {targetStream.Length}&quot;</span><span class="c2">);<br>}<br> <br></span><span class="c4">async</span><span class="c2">&nbsp;Task </span><span class="c18">DecompressAsync</span><span class="c2">(</span><span class="c4">string</span><span class="c2">&nbsp;compressedFile, </span><span class="c4">string</span><span class="c2">&nbsp;targetFile)<br>{<br> &nbsp; &nbsp;</span><span class="c6">// flux pentru citirea din fi&#537;ierul comprimat</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c4">using</span><span class="c2">&nbsp;FileStream sourceStream = </span><span class="c4">new</span><span class="c2">&nbsp;FileStream(compressedFile, FileMode.OpenOrCreate);<br> &nbsp; &nbsp;</span><span class="c6">// flux pentru scrierea fi&#537;ierului restaurat</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c4">using</span><span class="c2">&nbsp;FileStream targetStream = File.Create(targetFile);<br> &nbsp; &nbsp;</span><span class="c6">// fluxul de decomprimare</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c4">using</span><span class="c2">&nbsp;GZipStream decompressionStream = </span><span class="c4">new</span><span class="c2">&nbsp;GZipStream(sourceStream, CompressionMode.Decompress);<br> &nbsp; &nbsp;</span><span class="c4">await</span><span class="c2">&nbsp;decompressionStream.CopyToAsync(targetStream);<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;Fi&#537;ierul a fost restaurat: {targetFile}&quot;</span><span class="c2">);<br>}</span></p></td></tr></table><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">&Icirc;n acest exemplu, se presupune c&#259; &icirc;n folderul cu programul se afl&#259; fi&#537;ierul book.pdf, care va fi arhivat.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Metoda </span><span class="c1 c8">CompressAsync </span><span class="c0">prime&#537;te numele fi&#537;ierului surs&#259; care trebuie arhivat &#537;i numele viitorului fi&#537;ier comprimat.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Mai &icirc;nt&acirc;i, se creeaz&#259; un flux pentru citirea din fi&#537;ierul surs&#259; - </span><span class="c1 c8">FileStream sourceStream</span><span class="c1">. Apoi se creeaz&#259; un flux pentru scrierea &icirc;n fi&#537;ierul comprimat - </span><span class="c1 c8">FileStream targetStream</span><span class="c1">. Fluxul de arhivare</span><span class="c1 c8">&nbsp;GZipStream compressionStream</span><span class="c1">&nbsp;este ini&#539;ializat cu fluxul targetStream &#537;i, cu ajutorul metodei </span><span class="c1 c8">CopyToAsync()</span><span class="c0">, prime&#537;te date din fluxul sourceStream.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Metoda </span><span class="c1 c8">DecompressAsync </span><span class="c0">efectueaz&#259; opera&#539;ia invers&#259; de restaurare a fi&#537;ierului comprimat &icirc;n starea sa ini&#539;ial&#259;. Ea prime&#537;te ca parametri c&#259;ile c&#259;tre fi&#537;ierul comprimat &#537;i fi&#537;ierul restaurat.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Aici, mai &icirc;nt&acirc;i se creeaz&#259; un flux pentru citirea din fi&#537;ierul comprimat </span><span class="c1 c8">FileStream sourceStream</span><span class="c1">, apoi un flux pentru scrierea &icirc;n fi&#537;ierul restaurat </span><span class="c1 c8">FileStream targetStream</span><span class="c1">. La final, se creeaz&#259; fluxul </span><span class="c1 c8">GZipStream decompressionStream</span><span class="c1">, care, cu ajutorul metodei </span><span class="c1 c8">CopyToAsync()</span><span class="c0">, copiaz&#259; datele restaurate &icirc;n fluxul targetStream.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Pentru a specifica scopul fluxului GZipStream - comprimare sau restaurare - &icirc;n constructorul s&#259;u se transmite parametrul </span><span class="c1 c8">CompressionMode</span><span class="c0">, care poate lua dou&#259; valori: Compress &#537;i Decompress.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Exemplu de ie&#537;ire &icirc;n consol&#259;:</span></p><p class="c5 c10"><span class="c0"></span></p><a id="t.647685c26de7aa94eb117a765263122d3971a4ed"></a><a id="t.1"></a><table class="c16"><tr class="c19"><td class="c15" colspan="1" rowspan="1"><p class="c14"><span class="c2">Comprimarea fi&#537;ierului book.pdf a fost finalizat&#259;.<br>Dimensiunea original&#259;: </span><span class="c17">3235353</span><span class="c2">&nbsp; dimensiunea comprimat&#259;: </span><span class="c17">2574401</span><span class="c2"><br>Fi&#537;ierul a fost restaurat: book_new.pdf</span></p></td></tr></table><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Dac&#259; dorim s&#259; folosim alt&#259; clas&#259; de comprimare, cum ar fi DeflateStream, putem pur &#537;i simplu s&#259; &icirc;nlocuim &icirc;n cod referin&#539;ele la GZipStream cu DeflateStream, f&#259;r&#259; a modifica restul codului. Utilizarea lor este identic&#259;.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Totu&#537;i, folosirea acestor clase are unele limit&#259;ri; de exemplu, putem comprima doar un singur fi&#537;ier. Pentru arhivarea unui grup de fi&#537;iere, este mai bine s&#259; utiliz&#259;m alte instrumente, cum ar fi ZipFile.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c12">ZipFile.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">Clasa static&#259; </span><span class="c9">ZipFile </span><span class="c0">din spa&#539;iul de nume System.IO.Compression ofer&#259; func&#539;ionalit&#259;&#539;i suplimentare pentru crearea arhivelor. Aceasta permite crearea unei arhive din directoare. Principalele sale metode sunt:</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">- </span><span class="c1 c8">void CreateFromDirectory(string sourceDirectoryName, string destinationFileName)</span><span class="c0">: arhiveaz&#259; un folder de la calea sourceDirectoryName &icirc;ntr-un fi&#537;ier cu numele destinationFileName.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">-</span><span class="c1 c8">&nbsp;void ExtractToDirectory(string sourceFileName, string destinationDirectoryName)</span><span class="c0">: extrage toate fi&#537;ierele din fi&#537;ierul zip sourceFileName &icirc;n directorul destinationDirectoryName.</span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c0">Ambele metode au mai multe versiuni supra&icirc;nc&#259;rcate. S&#259; vedem un exemplu de utilizare:</span></p><p class="c5 c10"><span class="c0"></span></p><a id="t.b962b35c0ed5a834579aca096233a335fa38bb33"></a><a id="t.2"></a><table class="c16"><tr class="c19"><td class="c15" colspan="1" rowspan="1"><p class="c14"><span class="c4">using</span><span class="c2">&nbsp;System.IO.Compression;<br> <br></span><span class="c4">string</span><span class="c2">&nbsp;sourceFolder = </span><span class="c13">&quot;D://test/&quot;</span><span class="c2">; </span><span class="c6">// folderul surs&#259;</span><span class="c2"><br></span><span class="c4">string</span><span class="c2">&nbsp;zipFile = </span><span class="c13">&quot;D://test.zip&quot;</span><span class="c2">; </span><span class="c6">//</span><span class="c2"><br><br> fi&#537;ierul comprimat<br></span><span class="c4">string</span><span class="c2">&nbsp;targetFolder = </span><span class="c13">&quot;D://newtest&quot;</span><span class="c2">; </span><span class="c6">// folderul &icirc;n care va fi extras fi&#537;ierul</span><span class="c2"><br> <br>ZipFile.CreateFromDirectory(sourceFolder, zipFile);<br>Console.WriteLine(</span><span class="c13">$&quot;Folderul {sourceFolder} a fost arhivat &icirc;n fi&#537;ierul {zipFile}&quot;</span><span class="c2">);<br>ZipFile.ExtractToDirectory(zipFile, targetFolder);<br> <br>Console.WriteLine(</span><span class="c13">$&quot;Fi&#537;ierul {zipFile} a fost extras &icirc;n folderul {targetFolder}&quot;</span><span class="c2">);</span></p></td></tr></table><p class="c5 c10"><span class="c0"></span></p><p class="c5 c10"><span class="c0"></span></p><p class="c5"><span class="c1">&Icirc;n acest exemplu, folderul &quot;D://test/&quot; este arhivat &icirc;n fi&#537;ierul test.zip folosind metoda ZipFile.CreateFromDirectory. Apoi, metoda</span><span class="c1 c8">&nbsp;ZipFile.ExtractToDirectory()</span><span class="c0">&nbsp;extrage acest fi&#537;ier &icirc;n folderul &quot;D://newtest&quot; (dac&#259; acest folder nu exist&#259;, va fi creat).</span></p><p class="c5 c10"><span class="c0"></span></p></body></html>