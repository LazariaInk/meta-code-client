<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ol{margin:0;padding:0}table td,table th{padding:0}.c11{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c15{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c2{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c12{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c1{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c8{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#a2fca2;font-weight:400}.c13{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c0{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c16{border-spacing:0;border-collapse:collapse;margin-right:auto}.c7{font-size:12pt;font-family:"Open Sans";font-weight:400}.c3{font-size:12pt;font-family:"Open Sans";font-weight:700}.c5{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c10{height:11pt}.c14{height:0pt}.c17{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5 doc-content"><p class="c6"><span class="c15">Monitoare.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">Pe l&acirc;ng&#259; operatorul lock pentru sincronizarea thread-urilor, putem folosi </span><span class="c3">monitoarele</span><span class="c7">, reprezentate de clasa </span><span class="c3">System.Threading.Monitor</span><span class="c4">. Pentru gestionarea sincroniz&#259;rii, aceast&#259; clas&#259; ofer&#259; urm&#259;toarele metode:</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;void Enter(object obj)</span><span class="c4">: ob&#539;ine &icirc;n posesie exclusiv&#259; obiectul transmis ca parametru.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">- </span><span class="c3">void Enter(object obj, bool acquiredLock)</span><span class="c4">: &icirc;n plus, prime&#537;te un al doilea parametru - o valoare boolean&#259; care indic&#259; dac&#259; posesia asupra obiectului din primul parametru a fost ob&#539;inut&#259;.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;void Exit(object obj)</span><span class="c4">: elibereaz&#259; obiectul capturat anterior.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;bool IsEntered(object obj)</span><span class="c4">: returneaz&#259; true dac&#259; monitorul a capturat obiectul obj.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;void Pulse(object obj)</span><span class="c4">: notific&#259; thread-ul din coada de a&#537;teptare c&#259; thread-ul curent a eliberat obiectul obj.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;void PulseAll(object obj)</span><span class="c4">: notific&#259; toate thread-urile din coada de a&#537;teptare c&#259; thread-ul curent a eliberat obiectul obj. Dup&#259; aceasta, unul dintre thread-urile din coada de a&#537;teptare captureaz&#259; obiectul obj.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;bool TryEnter(object obj)</span><span class="c4">: &icirc;ncearc&#259; s&#259; captureze obiectul obj. Dac&#259; posesia asupra obiectului este ob&#539;inut&#259; cu succes, returneaz&#259; valoarea true.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">-</span><span class="c3">&nbsp;bool Wait(object obj)</span><span class="c4">: elibereaz&#259; blocarea obiectului &#537;i pune thread-ul &icirc;n coada de a&#537;teptare a obiectului. Urm&#259;torul thread din coada de a&#537;teptare captureaz&#259; acest obiect. Toate thread-urile care au apelat metoda Wait r&#259;m&acirc;n &icirc;n coada de a&#537;teptare p&acirc;n&#259; c&acirc;nd primesc un semnal de la metoda Monitor.Pulse sau Monitor.PulseAll, transmis de de&#539;in&#259;torul bloc&#259;rii.</span></p><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">Merit&#259; men&#539;ionat c&#259;, &icirc;n fapt, construc&#539;ia operatorului lock &icirc;ncapsuleaz&#259; sintaxa de utilizare a monitoarelor. De exemplu, &icirc;n tema anterioar&#259;, pentru sincronizarea thread-urilor a fost folosit operatorul </span><span class="c3">lock</span><span class="c4">:</span></p><p class="c6 c10"><span class="c4"></span></p><a id="t.7b897154188d46b449bf96acc2ffd27b541408e8"></a><a id="t.0"></a><table class="c16"><tr class="c14"><td class="c11" colspan="1" rowspan="1"><p class="c9"><span class="c2">int</span><span class="c0">&nbsp;x = </span><span class="c1">0</span><span class="c0">;<br></span><span class="c2">object</span><span class="c0">&nbsp;locker = </span><span class="c2">new</span><span class="c0">(); &nbsp;</span><span class="c13">// obiect placeholder</span><span class="c0"><br><br></span><span class="c13">// pornim cinci thread-uri</span><span class="c0"><br></span><span class="c2">for</span><span class="c0">&nbsp;(</span><span class="c2">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; </span><span class="c1">6</span><span class="c0">; i++)<br>{<br> &nbsp; &nbsp;Thread myThread = </span><span class="c2">new</span><span class="c0">(Print);<br> &nbsp; &nbsp;myThread.Name = </span><span class="c8">$&quot;Thread {i}&quot;</span><span class="c0">;<br> &nbsp; &nbsp;myThread.Start();<br>}<br><br></span><span class="c2">void</span><span class="c0">&nbsp;</span><span class="c12">Print</span><span class="c0">()<br>{<br> &nbsp; &nbsp;</span><span class="c2">lock</span><span class="c0">&nbsp;(locker)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;x = </span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">for</span><span class="c0">&nbsp;(</span><span class="c2">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; </span><span class="c1">6</span><span class="c0">; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">$&quot;{Thread.CurrentThread.Name}: {x}&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c1">100</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c4">De fapt, acest exemplu este echivalent cu urm&#259;torul cod:</span></p><p class="c6 c10"><span class="c4"></span></p><a id="t.6922feb439b810f46d7e0ba5a029a9a071c77204"></a><a id="t.1"></a><table class="c16"><tr class="c14"><td class="c11" colspan="1" rowspan="1"><p class="c9"><span class="c2">int</span><span class="c0">&nbsp;x = </span><span class="c1">0</span><span class="c0">;<br></span><span class="c2">object</span><span class="c0">&nbsp;locker = </span><span class="c2">new</span><span class="c0">(); &nbsp;</span><span class="c13">// obiect placeholder</span><span class="c0"><br><br></span><span class="c13">// pornim cinci thread-uri</span><span class="c0"><br></span><span class="c2">for</span><span class="c0">&nbsp;(</span><span class="c2">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; </span><span class="c1">6</span><span class="c0">; i++)<br>{<br> &nbsp; &nbsp;Thread myThread = </span><span class="c2">new</span><span class="c0">(Print);<br> &nbsp; &nbsp;myThread.Name = </span><span class="c8">$&quot;Thread {i}&quot;</span><span class="c0">;<br> &nbsp; &nbsp;myThread.Start();<br>}<br><br></span><span class="c2">void</span><span class="c0">&nbsp;</span><span class="c12">Print</span><span class="c0">()<br>{<br> &nbsp; &nbsp;</span><span class="c2">bool</span><span class="c0">&nbsp;acquiredLock = </span><span class="c2">false</span><span class="c0">;<br> &nbsp; &nbsp;</span><span class="c2">try</span><span class="c0"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Monitor.Enter(locker, </span><span class="c2">ref</span><span class="c0">&nbsp;acquiredLock);<br> &nbsp; &nbsp; &nbsp; &nbsp;x = </span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">for</span><span class="c0">&nbsp;(</span><span class="c2">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; </span><span class="c1">6</span><span class="c0">; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">$&quot;{Thread.CurrentThread.Name}: {x}&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c1">100</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c2">finally</span><span class="c0"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">if</span><span class="c0">&nbsp;(acquiredLock) Monitor.Exit(locker);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c6 c10"><span class="c4"></span></p><p class="c6"><span class="c7">Metoda</span><span class="c3">&nbsp;Monitor.Enter</span><span class="c7">&nbsp;accept&#259; doi parametri: obiectul de blocare &#537;i o valoare boolean&#259; care indic&#259; rezultatul bloc&#259;rii (dac&#259; este true, blocarea a fost realizat&#259; cu succes). De fapt, aceast&#259; metod&#259; blocheaz&#259; obiectul locker la fel cum face operatorul lock. Iar &icirc;n blocul try...finally, cu ajutorul metodei </span><span class="c7 c17">Monitor.Exit</span><span class="c4">, obiectul locker este eliberat dac&#259; blocarea a fost realizat&#259; cu succes, &#537;i devine disponibil pentru alte thread-uri.</span></p><p class="c6 c10"><span class="c4"></span></p></body></html>