<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ol{margin:0;padding:0}table td,table th{padding:0}.c4{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c17{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c5{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c0{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c9{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c6{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#a2fca2;font-weight:400}.c16{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c7{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c10{font-size:12pt;font-family:"Open Sans";font-style:italic;font-weight:400}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c15{border-spacing:0;border-collapse:collapse;margin-right:auto}.c2{font-size:12pt;font-family:"Open Sans";font-weight:700}.c8{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c13{font-size:12pt;font-family:"Open Sans";font-weight:400}.c11{height:11pt}.c12{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c8 doc-content"><p class="c1"><span class="c17">Clasa AutoResetEvent.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">Clasa </span><span class="c2">AutoResetEvent </span><span class="c3">serve&#537;te &#537;i ea scopurilor de sincronizare a thread-urilor. Aceast&#259; clas&#259; reprezint&#259; un eveniment de sincronizare a thread-urilor, care permite la primirea unui semnal s&#259; schimbe starea obiectului eveniment dintr-o stare semnalizat&#259; &icirc;ntr-o stare nesemnalizat&#259;.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c3">Pentru gestionarea sincroniz&#259;rii, clasa AutoResetEvent ofer&#259; o serie de metode:</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">-</span><span class="c2">&nbsp;Reset()</span><span class="c3">: seteaz&#259; starea nesemnalizat&#259; a obiectului, bloc&acirc;nd thread-urile.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">- </span><span class="c2">Set()</span><span class="c3">: seteaz&#259; starea semnalizat&#259; a obiectului, permi&#539;&acirc;nd unuia sau mai multor thread-uri &icirc;n a&#537;teptare s&#259;-&#537;i continue activitatea.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">- </span><span class="c2">WaitOne()</span><span class="c3">: seteaz&#259; starea nesemnalizat&#259; &#537;i blocheaz&#259; thread-ul curent p&acirc;n&#259; c&acirc;nd obiectul AutoResetEvent prime&#537;te un semnal.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c3">Evenimentul de sincronizare poate fi &icirc;ntr-o stare semnalizat&#259; sau nesemnalizat&#259;. Dac&#259; starea evenimentului este nesemnalizat&#259;, thread-ul care apeleaz&#259; metoda WaitOne va fi blocat p&acirc;n&#259; c&acirc;nd starea evenimentului devine semnalizat&#259;. Metoda Set seteaz&#259; starea semnalizat&#259; a evenimentului.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c3">Astfel, &icirc;n unul dintre exemplele anterioare, pentru sincronizarea thread-urilor s-a utilizat operatorul lock:</span></p><p class="c1 c11"><span class="c3"></span></p><a id="t.7b897154188d46b449bf96acc2ffd27b541408e8"></a><a id="t.0"></a><table class="c15"><tr class="c12"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c5">int</span><span class="c0">&nbsp;x = </span><span class="c9">0</span><span class="c0">;<br></span><span class="c5">object</span><span class="c0">&nbsp;locker = </span><span class="c5">new</span><span class="c0">(); &nbsp;</span><span class="c7">// obiect placeholder</span><span class="c0"><br><br></span><span class="c7">// pornim cinci thread-uri</span><span class="c0"><br></span><span class="c5">for</span><span class="c0">&nbsp;(</span><span class="c5">int</span><span class="c0">&nbsp;i = </span><span class="c9">1</span><span class="c0">; i &lt; </span><span class="c9">6</span><span class="c0">; i++)<br>{<br> &nbsp; &nbsp;Thread myThread = </span><span class="c5">new</span><span class="c0">(Print);<br> &nbsp; &nbsp;myThread.Name = </span><span class="c6">$&quot;Thread {i}&quot;</span><span class="c0">;<br> &nbsp; &nbsp;myThread.Start();<br>}<br><br></span><span class="c5">void</span><span class="c0">&nbsp;</span><span class="c16">Print</span><span class="c0">()<br>{<br> &nbsp; &nbsp;</span><span class="c5">lock</span><span class="c0">&nbsp;(locker)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;x = </span><span class="c9">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c5">for</span><span class="c0">&nbsp;(</span><span class="c5">int</span><span class="c0">&nbsp;i = </span><span class="c9">1</span><span class="c0">; i &lt; </span><span class="c9">6</span><span class="c0">; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c6">$&quot;{Thread.CurrentThread.Name}: {x}&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c9">100</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">Rescriem acest exemplu utiliz&acirc;nd </span><span class="c2">AutoResetEvent</span><span class="c3">:</span></p><p class="c1 c11"><span class="c3"></span></p><a id="t.5e788b276fa64a366326718ee6e74942fb31f37d"></a><a id="t.1"></a><table class="c15"><tr class="c12"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c5">int</span><span class="c0">&nbsp;x = </span><span class="c9">0</span><span class="c0">; &nbsp;</span><span class="c7">// resurs&#259; comun&#259;</span><span class="c0"><br><br>AutoResetEvent waitHandler = </span><span class="c5">new</span><span class="c0">&nbsp;AutoResetEvent(</span><span class="c5">true</span><span class="c0">); &nbsp;</span><span class="c7">// obiect-eveniment</span><span class="c0"><br><br></span><span class="c7">// pornim cinci thread-uri</span><span class="c0"><br></span><span class="c5">for</span><span class="c0">&nbsp;(</span><span class="c5">int</span><span class="c0">&nbsp;i = </span><span class="c9">1</span><span class="c0">; i &lt; </span><span class="c9">6</span><span class="c0">; i++)<br>{<br> &nbsp; &nbsp;Thread myThread = </span><span class="c5">new</span><span class="c0">(Print);<br> &nbsp; &nbsp;myThread.Name = </span><span class="c6">$&quot;Thread {i}&quot;</span><span class="c0">;<br> &nbsp; &nbsp;myThread.Start();<br>}<br><br></span><span class="c5">void</span><span class="c0">&nbsp;</span><span class="c16">Print</span><span class="c0">()<br>{<br> &nbsp; &nbsp;waitHandler.WaitOne(); &nbsp;</span><span class="c7">// a&#537;tept&#259;m semnalul</span><span class="c0"><br> &nbsp; &nbsp;x = </span><span class="c9">1</span><span class="c0">;<br> &nbsp; &nbsp;</span><span class="c5">for</span><span class="c0">&nbsp;(</span><span class="c5">int</span><span class="c0">&nbsp;i = </span><span class="c9">1</span><span class="c0">; i &lt; </span><span class="c9">6</span><span class="c0">; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c6">$&quot;{Thread.CurrentThread.Name}: {x}&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;x++;<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c9">100</span><span class="c0">);<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;waitHandler.Set(); &nbsp;</span><span class="c7">// semnaliz&#259;m c&#259; waitHandler este &icirc;n stare semnalizat&#259;</span><span class="c0"><br>}</span></p></td></tr></table><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">&Icirc;n primul r&acirc;nd, cre&#259;m o variabil&#259; de tip </span><span class="c10">AutoResetEvent</span><span class="c3">. Prin transmiterea valorii true &icirc;n constructor, indic&#259;m c&#259; obiectul creat va fi ini&#539;ial &icirc;n stare semnalizat&#259;.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">C&acirc;nd &icirc;ncepe s&#259; ruleze un thread, prima opera&#539;ie efectuat&#259; &icirc;n metoda Print este apelul</span><span class="c10">&nbsp;waitHandler.WaitOne()</span><span class="c3">. Metoda WaitOne indic&#259; faptul c&#259; thread-ul curent este pus &icirc;n stare de a&#537;teptare p&acirc;n&#259; c&acirc;nd obiectul waitHandler va fi setat &icirc;n stare semnalizat&#259;. Astfel, toate thread-urile sunt puse &icirc;n stare de a&#537;teptare.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">Dup&#259; finalizarea activit&#259;&#539;ii, se apeleaz&#259; metoda</span><span class="c10">&nbsp;waitHandler.Set</span><span class="c3">, care notific&#259; toate thread-urile &icirc;n a&#537;teptare c&#259; obiectul waitHandler este din nou &icirc;n stare semnalizat&#259;, iar unul dintre thread-uri &quot;captureaz&#259;&quot; acest obiect, &icirc;l trece &icirc;n stare nesemnalizat&#259; &#537;i &icirc;&#537;i execut&#259; codul. Celelalte thread-uri a&#537;teapt&#259; din nou.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c3">Deoarece &icirc;n constructorul AutoResetEvent am indicat c&#259; obiectul este ini&#539;ial &icirc;n stare semnalizat&#259;, primul thread din coad&#259; captureaz&#259; obiectul &#537;i &icirc;ncepe s&#259;-&#537;i execute codul.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">Dar dac&#259; am fi scris</span><span class="c10">&nbsp;AutoResetEvent waitHandler = new AutoResetEvent(false)</span><span class="c13">, obiectul ar fi fost ini&#539;ial &icirc;n stare nesemnalizat&#259;, iar deoarece toate thread-urile sunt blocate de metoda </span><span class="c10">waitHandler.WaitOne()</span><span class="c3">&nbsp;&icirc;n a&#537;teptarea semnalului, programul ar fi fost blocat &#537;i nu ar fi executat nicio ac&#539;iune.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c13">Dac&#259; &icirc;n programul nostru sunt utilizate mai multe obiecte AutoResetEvent, putem folosi pentru monitorizarea st&#259;rii acestor obiecte metodele statice </span><span class="c2">WaitAll </span><span class="c13">&#537;i </span><span class="c2">WaitAny</span><span class="c3">, care accept&#259; ca parametru un array de obiecte de tip WaitHandle - clasa de baz&#259; pentru AutoResetEvent.</span></p><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c3">Astfel, putem folosi &#537;i WaitAll &icirc;n exemplul de mai sus. Pentru aceasta, trebuie s&#259; &icirc;nlocuim linia:</span></p><p class="c1 c11"><span class="c3"></span></p><a id="t.157b4de96c4301e19931ceb568f949f72b3d9c96"></a><a id="t.2"></a><table class="c15"><tr class="c12"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">waitHandler.WaitOne();</span></p></td></tr></table><p class="c1 c11"><span class="c3"></span></p><p class="c1"><span class="c3">cu urm&#259;toarea:</span></p><p class="c1 c11"><span class="c3"></span></p><a id="t.a1a617dbf39c750a3202b3b0d4d26e3754a5ae3e"></a><a id="t.3"></a><table class="c15"><tr class="c12"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">AutoResetEvent.WaitAll(</span><span class="c5">new</span><span class="c0">&nbsp;WaitHandle[] {waitHandler});</span></p></td></tr></table><p class="c1 c11"><span class="c3"></span></p><p class="c1 c11"><span class="c3"></span></p></body></html>