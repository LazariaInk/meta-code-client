<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ol{margin:0;padding:0}table td,table th{padding:0}.c0{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left;height:11pt}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c17{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Open Sans";font-style:normal}.c18{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c6{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#a2fca2;font-weight:400}.c3{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c14{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c5{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c11{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c9{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c16{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fc9b9b;font-weight:400}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c7{border-spacing:0;border-collapse:collapse;margin-right:auto}.c10{font-size:12pt;font-family:"Open Sans";font-weight:400}.c13{font-size:12pt;font-family:"Open Sans";font-weight:700}.c19{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{height:0pt}.c15{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c19 doc-content"><p class="c2"><span class="c18">Execu&#539;ie secven&#539;ial&#259; &#537;i paralel&#259;. Task.WhenAll &#537;i Task.WhenAny.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">O metod&#259; asincron&#259; poate con&#539;ine multe expresii await. C&acirc;nd sistemul &icirc;nt&acirc;lne&#537;te operatorul await &icirc;ntr-un bloc de cod, execu&#539;ia &icirc;n metoda asincron&#259; se opre&#537;te p&acirc;n&#259; c&acirc;nd sarcina asincron&#259; se finalizeaz&#259;. Dup&#259; finalizarea sarcinii, controlul trece la urm&#259;torul operator await &#537;i a&#537;a mai departe. Acest lucru permite apelarea sarcinilor asincrone &icirc;n mod secven&#539;ial, &icirc;ntr-o anumit&#259; ordine. De exemplu:</span></p><p class="c1"><span class="c4"></span></p><a id="t.54279681b546a7fdd9988c4cdf1238c255ee857a"></a><a id="t.0"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c3">await</span><span class="c5">&nbsp;PrintAsync(</span><span class="c6">&quot;Hello C#&quot;</span><span class="c5">);<br></span><span class="c3">await</span><span class="c5">&nbsp;PrintAsync(</span><span class="c6">&quot;Hello World&quot;</span><span class="c5">);<br></span><span class="c3">await</span><span class="c5">&nbsp;PrintAsync(</span><span class="c6">&quot;Hello FDC.COM&quot;</span><span class="c5">);<br><br></span><span class="c3">async</span><span class="c5">&nbsp;Task </span><span class="c9">PrintAsync</span><span class="c5">(</span><span class="c3">string</span><span class="c5">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c5">&nbsp;Task.Delay(</span><span class="c14">2000</span><span class="c5">); &nbsp; &nbsp; </span><span class="c11">// imita&#539;ia unei opera&#539;ii de lung&#259; durat&#259;</span><span class="c5"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">Afi&#537;area pe consol&#259; a acestui program:</span></p><p class="c1"><span class="c4"></span></p><a id="t.35e5913b8657f3815dbd99cc4aff52200f8c4a06"></a><a id="t.1"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c5">Hello C</span><span class="c16">#</span><span class="c5"><br>Hello World<br>Hello FDC.COM</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">Adic&#259;, vedem c&#259; apelurile PrintAsync se execut&#259; secven&#539;ial &icirc;n ordinea &icirc;n care sunt definite &icirc;n cod. Fiecare sarcin&#259; se execut&#259; cel pu&#539;in 2 secunde, astfel timpul total de execu&#539;ie al celor trei sarcini va fi de cel pu&#539;in 6 secunde. &#536;i &icirc;n acest caz, afi&#537;area este strict determinist&#259;.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">Deseori, aceast&#259; secven&#539;&#259; este necesar&#259; dac&#259; o sarcin&#259; depinde de rezultatele altei sarcini.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">Totu&#537;i, acest lucru nu este &icirc;ntotdeauna necesar. &Icirc;n astfel de cazuri, putem lansa toate sarcinile &icirc;n paralel &#537;i aplica operatorul await acolo unde este necesar s&#259; garant&#259;m finalizarea unei sarcini, de exemplu, la sf&acirc;r&#537;itul programului.</span></p><p class="c1"><span class="c4"></span></p><a id="t.d9f995a58412435bff4b25709cac5a930554eb53"></a><a id="t.2"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c11">// definim &#537;i lans&#259;m sarcinile</span><span class="c5"><br></span><span class="c3">var</span><span class="c5">&nbsp;task1 = PrintAsync(</span><span class="c6">&quot;Hello C#&quot;</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task2 = PrintAsync(</span><span class="c6">&quot;Hello World&quot;</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task3 = PrintAsync(</span><span class="c6">&quot;Hello FDC.COM&quot;</span><span class="c5">);<br><br></span><span class="c11">// a&#537;tept&#259;m finalizarea sarcinilor</span><span class="c5"><br></span><span class="c3">await</span><span class="c5">&nbsp;task1;<br></span><span class="c3">await</span><span class="c5">&nbsp;task2;<br></span><span class="c3">await</span><span class="c5">&nbsp;task3;<br><br></span><span class="c3">async</span><span class="c5">&nbsp;Task </span><span class="c9">PrintAsync</span><span class="c5">(</span><span class="c3">string</span><span class="c5">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c5">&nbsp;Task.Delay(</span><span class="c14">2000</span><span class="c5">); &nbsp; &nbsp; </span><span class="c11">// imita&#539;ia unei opera&#539;ii de lung&#259; durat&#259;</span><span class="c5"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">&Icirc;n acest caz, toate sarcinile se lanseaz&#259; &#537;i se execut&#259; &icirc;n paralel, astfel timpul total de execu&#539;ie va fi mai mic de 6 secunde, iar afi&#537;area pe consol&#259; a programului este nedeterminist&#259;. De exemplu, poate fi urm&#259;toarea:</span></p><p class="c1"><span class="c4"></span></p><a id="t.859a4f97455ecac17a24993c5f118e802315934e"></a><a id="t.3"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c5">Hello FDC.COM<br>Hello C</span><span class="c16">#</span><span class="c5"><br>Hello World</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c10">Totu&#537;i, .NET permite simplificarea monitoriz&#259;rii execu&#539;iei unui set de sarcini cu ajutorul metodei</span><span class="c13">&nbsp;Task.WhenAll</span><span class="c10">. Aceast&#259; metod&#259; prime&#537;te un set de sarcini asincrone &#537;i a&#537;teapt&#259; finalizarea tuturor acestor sarcini. Aceasta este echivalentul metodei statice</span><span class="c10 c15">&nbsp;Task.WaitAll()</span><span class="c4">, dar destinat&#259; &icirc;n mod special metodelor asincrone &#537;i permite aplicarea operatorului await:</span></p><p class="c1"><span class="c4"></span></p><a id="t.b827423424dd9819f3a78cbc3c8fb891a984ccfb"></a><a id="t.4"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c11">// definim &#537;i lans&#259;m sarcinile</span><span class="c5"><br></span><span class="c3">var</span><span class="c5">&nbsp;task1 = PrintAsync(</span><span class="c6">&quot;Hello C#&quot;</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task2 = PrintAsync(</span><span class="c6">&quot;Hello World&quot;</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task3 = PrintAsync(</span><span class="c6">&quot;Hello FDC.COM&quot;</span><span class="c5">);<br><br></span><span class="c11">// a&#537;tept&#259;m finalizarea tuturor sarcinilor</span><span class="c5"><br></span><span class="c3">await</span><span class="c5">&nbsp;Task.WhenAll(task1, task2, task3);<br><br></span><span class="c3">async</span><span class="c5">&nbsp;Task </span><span class="c9">PrintAsync</span><span class="c5">(</span><span class="c3">string</span><span class="c5">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c5">&nbsp;Task.Delay(</span><span class="c14">2000</span><span class="c5">); &nbsp; &nbsp; </span><span class="c11">// imita&#539;ia unei opera&#539;ii de lung&#259; durat&#259;</span><span class="c5"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">&Icirc;nceputul programului lanseaz&#259; trei sarcini. Apoi Task.WhenAll creeaz&#259; o nou&#259; sarcin&#259;, care va fi executat&#259; automat dup&#259; finalizarea tuturor sarcinilor furnizate, adic&#259; sarcinile task1, task2, task3. &#536;i cu ajutorul operatorului await a&#537;tept&#259;m finalizarea acesteia.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c10">Dac&#259; trebuie s&#259; a&#537;tept&#259;m finalizarea a cel pu&#539;in unei sarcini dintr-un set de sarcini, putem folosi metoda</span><span class="c13">&nbsp;Task.WhenAny()</span><span class="c10">. Aceasta este echivalentul metodei </span><span class="c10 c15">Task.WaitAny()</span><span class="c4">&nbsp;- se finalizeaz&#259; c&acirc;nd se finalizeaz&#259; cel pu&#539;in o sarcin&#259;. Dar pentru a a&#537;tepta finalizarea, la Task.WhenAny() se aplic&#259; operatorul await:</span></p><p class="c1"><span class="c4"></span></p><a id="t.dfff9abf670f382c7cee446849618cda07e54e7b"></a><a id="t.5"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c11">// definim &#537;i lans&#259;m sarcinile</span><span class="c5"><br></span><span class="c3">var</span><span class="c5">&nbsp;task1 = PrintAsync(</span><span class="c6">&quot;Hello C#&quot;</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task2 = PrintAsync(</span><span class="c6">&quot;Hello World&quot;</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task3 = PrintAsync(</span><span class="c6">&quot;Hello FDC.COM&quot;</span><span class="c5">);<br><br></span><span class="c11">// a&#537;tept&#259;m finalizarea a cel pu&#539;in unei sarcini</span><span class="c5"><br></span><span class="c3">await</span><span class="c5">&nbsp;Task.WhenAny(task1, task2, task3);<br><br></span><span class="c3">async</span><span class="c5">&nbsp;Task </span><span class="c9">PrintAsync</span><span class="c5">(</span><span class="c3">string</span><span class="c5">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c5">&nbsp;Task.Delay(</span><span class="c3">new</span><span class="c5">&nbsp;Random().Next(</span><span class="c14">1000</span><span class="c5">, </span><span class="c14">2000</span><span class="c5">)); &nbsp; &nbsp; </span><span class="c11">// imita&#539;ia unei opera&#539;ii de lung&#259; durat&#259;</span><span class="c5"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c17">Ob&#539;inerea rezultatului.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c10">Sarcinile transmise la </span><span class="c10 c15">Task.WhenAll</span><span class="c10">&nbsp;&#537;i </span><span class="c10 c15">Task.WhenAny</span><span class="c4">&nbsp;pot returna o anumit&#259; valoare. &Icirc;n acest caz, din metodele Task.WhenAll &#537;i Task.WhenAny putem ob&#539;ine un array care va con&#539;ine rezultatele sarcinilor:</span></p><p class="c1"><span class="c4"></span></p><a id="t.ba057e4ef9a1e84472ce08f3416d1c57ad04d238"></a><a id="t.6"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c11">// definim &#537;i lans&#259;m sarcinile</span><span class="c5"><br></span><span class="c3">var</span><span class="c5">&nbsp;task1 = SquareAsync(</span><span class="c14">4</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task2 = SquareAsync(</span><span class="c14">5</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task3 = SquareAsync(</span><span class="c14">6</span><span class="c5">);<br><br></span><span class="c11">// a&#537;tept&#259;m finalizarea tuturor sarcinilor</span><span class="c5"><br></span><span class="c3">int</span><span class="c5">[] results = </span><span class="c3">await</span><span class="c5">&nbsp;Task.WhenAll(task1, task2, task3);<br></span><span class="c11">// ob&#539;inem rezultatele:</span><span class="c5"><br></span><span class="c3">foreach</span><span class="c5">&nbsp;(</span><span class="c3">int</span><span class="c5">&nbsp;result </span><span class="c3">in</span><span class="c5">&nbsp;results)<br> &nbsp; &nbsp;Console.WriteLine(result);<br><br></span><span class="c3">async</span><span class="c5">&nbsp;Task&lt;</span><span class="c3">int</span><span class="c5">&gt; </span><span class="c9">SquareAsync</span><span class="c5">(</span><span class="c3">int</span><span class="c5">&nbsp;n)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c5">&nbsp;Task.Delay(</span><span class="c14">1000</span><span class="c5">);<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c5">&nbsp;n * n;<br>}</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">&Icirc;n acest caz, metoda Square returneaz&#259; un num&#259;r de tip int - p&#259;tratul num&#259;rului transmis metodei. &#536;i variabila results va con&#539;ine rezultatul apelului Task.WhenAll - de fapt rezultatele celor trei sarcini lansate. Deoarece toate sarcinile transmise la Task.WhenAll returneaz&#259; int, rezultatul Task.WhenAll va fi un array de valori int.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">De asemenea, dup&#259; finalizarea unei sarcini, rezultatul acesteia poate fi ob&#539;inut &icirc;n mod standard prin proprietatea Result:</span></p><p class="c1"><span class="c4"></span></p><a id="t.4c08c3df6e88638760d17776857ef622618b3ed4"></a><a id="t.7"></a><table class="c7"><tr class="c8"><td class="c0" colspan="1" rowspan="1"><p class="c12"><span class="c11">// definim &#537;i lans&#259;m sarcinile</span><span class="c5"><br></span><span class="c3">var</span><span class="c5">&nbsp;task1 = SquareAsync(</span><span class="c14">4</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task2 = SquareAsync(</span><span class="c14">5</span><span class="c5">);<br></span><span class="c3">var</span><span class="c5">&nbsp;task3 = SquareAsync(</span><span class="c14">6</span><span class="c5">);<br><br></span><span class="c3">await</span><span class="c5">&nbsp;Task.WhenAll(task1, task2, task3);<br></span><span class="c11">// ob&#539;inem rezultatul sarcinii task2</span><span class="c5"><br>Console.WriteLine(</span><span class="c6">$&quot;task2 result: {task2.Result}&quot;</span><span class="c5">); </span><span class="c11">// task2 result: 25</span><span class="c5"><br><br></span><span class="c3">async</span><span class="c5">&nbsp;Task&lt;</span><span class="c3">int</span><span class="c5">&gt; </span><span class="c9">SquareAsync</span><span class="c5">(</span><span class="c3">int</span><span class="c5">&nbsp;n)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c5">&nbsp;Task.Delay(</span><span class="c14">1000</span><span class="c5">);<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c5">&nbsp;n * n;<br>}</span></p></td></tr></table><p class="c1"><span class="c4"></span></p><p class="c1"><span class="c4"></span></p></body></html>