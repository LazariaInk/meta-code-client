<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ol{margin:0;padding:0}table td,table th{padding:0}.c8{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c13{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Open Sans";font-style:normal}.c18{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left;height:11pt}.c6{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c4{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c10{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c2{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c3{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c7{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c11{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#a2fca2;font-weight:400}.c12{border-spacing:0;border-collapse:collapse;margin-right:auto}.c15{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c16{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c14{font-size:12pt;font-family:"Open Sans";font-weight:400}.c17{font-size:12pt;font-family:"Open Sans";font-weight:700}.c9{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c16 doc-content"><p class="c5"><span class="c18">Returnarea rezultatului din metoda asincron&#259;.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c14">Ca tip de returnare &icirc;n metoda asincron&#259; trebuie s&#259; se foloseasc&#259; tipurile </span><span class="c17">void</span><span class="c14">, </span><span class="c17">Task</span><span class="c14">, </span><span class="c17">Task&lt;T&gt;</span><span class="c14">&nbsp;sau </span><span class="c6">ValueTask&lt;T&gt;</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c13">Void</span></p><p class="c1"><span class="c13"></span></p><p class="c5"><span class="c14">La utilizarea cuv&acirc;ntului cheie </span><span class="c17">void</span><span class="c0">, metoda asincron&#259; nu returneaz&#259; nimic:</span></p><p class="c1"><span class="c0"></span></p><a id="t.07b22adb372a5bd0ea4bf51412322d738940fa5c"></a><a id="t.0"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c2">PrintAsync(</span><span class="c11">&quot;Hello World&quot;</span><span class="c2">);<br>PrintAsync(</span><span class="c11">&quot;Hello FDC.COM&quot;</span><span class="c2">);<br> <br>Console.WriteLine(</span><span class="c11">&quot;Main End&quot;</span><span class="c2">);<br></span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">3000</span><span class="c2">); </span><span class="c7">// a&#537;tept&#259;m finalizarea sarcinilor</span><span class="c2"><br> <br></span><span class="c7">// definirea metodei asincrone</span><span class="c2"><br></span><span class="c3">async</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c4">PrintAsync</span><span class="c2">(</span><span class="c3">string</span><span class="c2">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">1000</span><span class="c2">); &nbsp; &nbsp; </span><span class="c7">// imita&#539;ia unei lucr&#259;ri de lung&#259; durat&#259;</span><span class="c2"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Totu&#537;i, metodele asincrone void ar trebui evitate &#537;i utilizate doar acolo unde astfel de metode reprezint&#259; singura modalitate posibil&#259; de a defini o metod&#259; asincron&#259;. &Icirc;n primul r&acirc;nd, nu putem aplica operatorul await acestor metode. De asemenea, pentru c&#259; excep&#539;iile din astfel de metode sunt dificil de gestionat, deoarece nu pot fi capturate &icirc;n afara metodei. &Icirc;n plus, astfel de metode void sunt greu de testat.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Totu&#537;i, exist&#259; situa&#539;ii &icirc;n care astfel de metode sunt inevitabile - de exemplu, la gestionarea evenimentelor:</span></p><p class="c1"><span class="c0"></span></p><a id="t.6c921fc481ecc0fe0b61ea95ad38a1d7346714ac"></a><a id="t.1"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c2">Account account = </span><span class="c3">new</span><span class="c2">&nbsp;Account();<br>account.Added += PrintAsync;<br> <br>account.Put(</span><span class="c10">500</span><span class="c2">);<br> <br></span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">2000</span><span class="c2">); </span><span class="c7">// a&#537;tept&#259;m finalizarea</span><span class="c2"><br> <br></span><span class="c7">// definirea metodei asincrone</span><span class="c2"><br></span><span class="c3">async</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c4">PrintAsync</span><span class="c2">(</span><span class="c3">object</span><span class="c2">? obj, </span><span class="c3">string</span><span class="c2">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">1000</span><span class="c2">); &nbsp; &nbsp; </span><span class="c7">// imita&#539;ia unei lucr&#259;ri de lung&#259; durat&#259;</span><span class="c2"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}<br> <br></span><span class="c3">class</span><span class="c2">&nbsp;</span><span class="c4">Account</span><span class="c2"><br>{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">&nbsp;sum = </span><span class="c10">0</span><span class="c2">;<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">event</span><span class="c2">&nbsp;EventHandler&lt;</span><span class="c3">string</span><span class="c2">&gt;? Added;<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c2">&nbsp;</span><span class="c3">void</span><span class="c2">&nbsp;</span><span class="c4">Put</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;sum)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">this</span><span class="c2">.sum += sum;<br> &nbsp; &nbsp; &nbsp; &nbsp;Added?.Invoke(</span><span class="c3">this</span><span class="c2">, </span><span class="c11">$&quot;&Icirc;n cont au fost depu&#537;i {sum} $&quot;</span><span class="c2">);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">&Icirc;n acest caz, evenimentul Added &icirc;n clasa Account reprezint&#259; un delegat EventHandler, care are tipul void. &Icirc;n consecin&#539;&#259;, pentru acest eveniment se poate defini doar o metod&#259; handler cu tipul void.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c13">Task</span></p><p class="c1"><span class="c13"></span></p><p class="c5"><span class="c0">Returnarea unui obiect de tip Task:</span></p><p class="c1"><span class="c0"></span></p><a id="t.1bcb45a7c3f6a8974b669774754fd173b4c90083"></a><a id="t.2"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">await</span><span class="c2">&nbsp;PrintAsync(</span><span class="c11">&quot;Hello FDC.com&quot;</span><span class="c2">);<br> <br></span><span class="c7">// definirea metodei asincrone</span><span class="c2"><br></span><span class="c3">async</span><span class="c2">&nbsp;Task </span><span class="c4">PrintAsync</span><span class="c2">(</span><span class="c3">string</span><span class="c2">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">1000</span><span class="c2">); &nbsp; &nbsp; </span><span class="c7">// imita&#539;ia unei lucr&#259;ri de lung&#259; durat&#259;</span><span class="c2"><br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Aici, formal, metoda PrintAsync nu folose&#537;te operatorul return pentru a returna un rezultat. Totu&#537;i, dac&#259; &icirc;n metoda asincron&#259; se execut&#259; o opera&#539;ie asincron&#259; &icirc;n expresia await, putem returna un obiect Task din metod&#259;.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c14">Pentru a a&#537;tepta finalizarea unei sarcini asincrone se poate folosi operatorul </span><span class="c17">await</span><span class="c0">. De altfel, nu este obligatoriu s&#259;-l folosim direct la apelul sarcinii. &Icirc;l putem aplica doar acolo unde trebuie s&#259; ob&#539;inem garantat rezultatul sarcinii sau s&#259; ne asigur&#259;m c&#259; sarcina este finalizat&#259;.</span></p><p class="c1"><span class="c0"></span></p><a id="t.f3040d745ed1ded5c1a714de08046e665eb3ec62"></a><a id="t.3"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">var</span><span class="c2">&nbsp;task = PrintAsync(</span><span class="c11">&quot;Hello FDC.com&quot;</span><span class="c2">); </span><span class="c7">// sarcina &icirc;ncepe s&#259; se execute</span><span class="c2"><br>Console.WriteLine(</span><span class="c11">&quot;Main Works&quot;</span><span class="c2">);<br> <br></span><span class="c3">await</span><span class="c2">&nbsp;task; </span><span class="c7">// a&#537;tept&#259;m finalizarea sarcinii</span><span class="c2"><br> <br></span><span class="c7">// definirea metodei asincrone</span><span class="c2"><br></span><span class="c3">async</span><span class="c2">&nbsp;Task </span><span class="c4">PrintAsync</span><span class="c2">(</span><span class="c3">string</span><span class="c2">&nbsp;message)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">0</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(message);<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c13">Task&lt;T&gt;</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c14">Metoda poate returna o anumit&#259; valoare. Atunci valoarea returnat&#259; este &icirc;nf&#259;&#537;urat&#259; &icirc;ntr-un obiect Task, iar tipul returnat este</span><span class="c17">&nbsp;Task&lt;T&gt;</span><span class="c0">:</span></p><p class="c1"><span class="c0"></span></p><a id="t.9bcd0a096a76080b501178cd8520e5914674b3bf"></a><a id="t.4"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">int</span><span class="c2">&nbsp;n1 = </span><span class="c3">await</span><span class="c2">&nbsp;SquareAsync(</span><span class="c10">5</span><span class="c2">);<br></span><span class="c3">int</span><span class="c2">&nbsp;n2 = </span><span class="c3">await</span><span class="c2">&nbsp;SquareAsync(</span><span class="c10">6</span><span class="c2">);<br>Console.WriteLine(</span><span class="c11">$&quot;n1={n1} &nbsp;n2={n2}&quot;</span><span class="c2">); </span><span class="c7">// n1=25 &nbsp;n2=36</span><span class="c2"><br> <br></span><span class="c3">async</span><span class="c2">&nbsp;Task&lt;</span><span class="c3">int</span><span class="c2">&gt; </span><span class="c4">SquareAsync</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;n)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">0</span><span class="c2">);<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;n * n;<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">&Icirc;n acest caz, metoda Square returneaz&#259; o valoare de tip int - p&#259;tratul num&#259;rului. Prin urmare, tipul returnat este Task&lt;int&gt;.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Pentru a ob&#539;ine rezultatul metodei asincrone aplic&#259;m operatorul await la apelul SquareAsync:</span></p><p class="c1"><span class="c0"></span></p><a id="t.8948af304e45caf4992fcc58c8bfba5aea7c3b0f"></a><a id="t.5"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">int</span><span class="c2">&nbsp;n1 = </span><span class="c3">await</span><span class="c2">&nbsp;SquareAsync(</span><span class="c10">5</span><span class="c2">);</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">&Icirc;n mod similar, putem ob&#539;ine date de alte tipuri:</span></p><p class="c1"><span class="c0"></span></p><a id="t.632909e142700d6f191d100e3cfbfc22dd5cb66b"></a><a id="t.6"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c2">Person person = </span><span class="c3">await</span><span class="c2">&nbsp;GetPersonAsync(</span><span class="c11">&quot;Tom&quot;</span><span class="c2">);<br>Console.WriteLine(person.Name); </span><span class="c7">// Tom</span><span class="c2"><br><br></span><span class="c7">// definirea metodei asincrone</span><span class="c2"><br></span><span class="c3">async</span><span class="c2">&nbsp;Task&lt;Person&gt; </span><span class="c4">GetPersonAsync</span><span class="c2">(</span><span class="c3">string</span><span class="c2">&nbsp;name)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">0</span><span class="c2">);<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;</span><span class="c3">new</span><span class="c2">&nbsp;Person(name);<br>}<br><br>record class </span><span class="c4">Person</span><span class="c2">(</span><span class="c3">string</span><span class="c2">&nbsp;Name);</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Din nou, ob&#539;inerea rezultatelor directe ale sarcinii asincrone poate fi am&acirc;nat&#259; p&acirc;n&#259; &icirc;n momentul &icirc;n care acestea sunt necesare:</span></p><p class="c1"><span class="c0"></span></p><a id="t.4cf763d0bf9040b7fdd1f1e9052dd11fb21c4070"></a><a id="t.7"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">var</span><span class="c2">&nbsp;square5 = SquareAsync(</span><span class="c10">5</span><span class="c2">);<br></span><span class="c3">var</span><span class="c2">&nbsp;square6 = SquareAsync(</span><span class="c10">6</span><span class="c2">);<br> <br>Console.WriteLine(</span><span class="c11">&quot;Alte ac&#539;iuni &icirc;n metoda Main&quot;</span><span class="c2">);<br> <br></span><span class="c3">int</span><span class="c2">&nbsp;n1 = </span><span class="c3">await</span><span class="c2">&nbsp;square5;<br></span><span class="c3">int</span><span class="c2">&nbsp;n2 = </span><span class="c3">await</span><span class="c2">&nbsp;square6;<br>Console.WriteLine(</span><span class="c11">$&quot;n1={n1} &nbsp;n2={n2}&quot;</span><span class="c2">); </span><span class="c7">// n1=25 &nbsp;n2=36</span><span class="c2"><br> <br></span><span class="c3">async</span><span class="c2">&nbsp;Task&lt;</span><span class="c3">int</span><span class="c2">&gt; </span><span class="c4">SquareAsync</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;n)<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">0</span><span class="c2">);<br> &nbsp; &nbsp;</span><span class="c3">var</span><span class="c2">&nbsp;result = n * n;<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c11">$&quot;P&#259;tratul num&#259;rului {n} este {result}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;result;<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Exemplu de lucru al programului (afi&#537;ajul nu este determinist):</span></p><p class="c1"><span class="c0"></span></p><a id="t.3177fb8c9292a86617064a547da4ece5a7ef3e9d"></a><a id="t.8"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c2">P&#259;tratul num&#259;rului </span><span class="c10">5</span><span class="c2">&nbsp;este </span><span class="c10">25</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c10">6</span><span class="c2">&nbsp;este </span><span class="c10">36</span><span class="c2"><br>Alte ac&#539;iuni &icirc;n metoda Main<br>n1=</span><span class="c10">25</span><span class="c2">&nbsp; n2=</span><span class="c10">36</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c13">ValueTask&lt;T&gt;</span></p><p class="c1"><span class="c13"></span></p><p class="c5"><span class="c0">Utilizarea tipului ValueTask&lt;T&gt; este &icirc;n mare parte similar&#259; cu utilizarea Task&lt;T&gt;, cu unele diferen&#539;e &icirc;n ceea ce prive&#537;te gestionarea memoriei, deoarece ValueTask este o structur&#259; care con&#539;ine un num&#259;r mai mare de c&acirc;mpuri. De aceea, utilizarea ValueTask &icirc;n loc de Task duce la copierea unui num&#259;r mai mare de date &#537;i, &icirc;n consecin&#539;&#259;, genereaz&#259; unele costuri suplimentare.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">Avantajul ValueTask fa&#539;&#259; de Task este c&#259; acest tip permite evitarea aloc&#259;rilor suplimentare de memorie &icirc;n heap. De exemplu, uneori este necesar s&#259; return&#259;m sincron o anumit&#259; valoare. S&#259; lu&#259;m urm&#259;torul exemplu:</span></p><p class="c1"><span class="c0"></span></p><a id="t.cc7835f7478c4a8beb3f8a086325f24179a72047"></a><a id="t.9"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">var</span><span class="c2">&nbsp;result = </span><span class="c3">await</span><span class="c2">&nbsp;AddAsync(</span><span class="c10">4</span><span class="c2">, </span><span class="c10">5</span><span class="c2">);<br>Console.WriteLine(result);<br> <br>Task&lt;</span><span class="c3">int</span><span class="c2">&gt; </span><span class="c4">AddAsync</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;a, </span><span class="c3">int</span><span class="c2">&nbsp;b)<br>{<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;Task.FromResult(a + b);<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c14">Aici metoda AddAsync returneaz&#259; sincron o anumit&#259; valoare - &icirc;n acest caz suma a dou&#259; numere. Cu ajutorul metodei statice</span><span class="c17">&nbsp;Task.FromResult</span><span class="c0">&nbsp;putem returna sincron o anumit&#259; valoare. Totu&#537;i, utilizarea tipului Task va duce la alocarea unei sarcini suplimentare cu aloc&#259;rile de memorie aferente &icirc;n heap. ValueTask rezolv&#259; aceast&#259; problem&#259;:</span></p><p class="c1"><span class="c0"></span></p><a id="t.9b847424a7fc66cc5df59d6344e140e493537729"></a><a id="t.10"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">var</span><span class="c2">&nbsp;result = </span><span class="c3">await</span><span class="c2">&nbsp;AddAsync(</span><span class="c10">4</span><span class="c2">, </span><span class="c10">5</span><span class="c2">);<br>Console.WriteLine(result);<br> <br>ValueTask&lt;</span><span class="c3">int</span><span class="c2">&gt; </span><span class="c4">AddAsync</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;a, </span><span class="c3">int</span><span class="c2">&nbsp;b)<br>{<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;</span><span class="c3">new</span><span class="c2">&nbsp;ValueTask&lt;</span><span class="c3">int</span><span class="c2">&gt;(a + b);<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c0">&Icirc;n acest caz, un obiect Task suplimentar nu va fi creat &#537;i, &icirc;n consecin&#539;&#259;, memoria suplimentar&#259; nu va fi alocat&#259;. De aceea, ValueTask este de obicei utilizat atunci c&acirc;nd rezultatul opera&#539;iei asincrone este deja disponibil.</span></p><p class="c1"><span class="c0"></span></p><p class="c5"><span class="c14">Dac&#259; este necesar, se poate transforma un ValueTask &icirc;ntr-un obiect Task cu ajutorul metodei </span><span class="c17">AsTask()</span><span class="c0">:</span></p><p class="c1"><span class="c0"></span></p><a id="t.086af89ad4a9a4987124d0a9f80b293a12011ca3"></a><a id="t.11"></a><table class="c12"><tr class="c9"><td class="c8" colspan="1" rowspan="1"><p class="c15"><span class="c3">var</span><span class="c2">&nbsp;getMessage = GetMessageAsync();<br></span><span class="c3">string</span><span class="c2">&nbsp;message = </span><span class="c3">await</span><span class="c2">&nbsp;getMessage.AsTask();<br>Console.WriteLine(message); </span><span class="c7">// Hello</span><span class="c2"><br> <br></span><span class="c3">async</span><span class="c2">&nbsp;ValueTask&lt;</span><span class="c3">string</span><span class="c2">&gt; </span><span class="c4">GetMessageAsync</span><span class="c2">()<br>{<br> &nbsp; &nbsp;</span><span class="c3">await</span><span class="c2">&nbsp;Task.Delay(</span><span class="c10">0</span><span class="c2">);<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;</span><span class="c11">&quot;Hello&quot;</span><span class="c2">;<br>}</span></p></td></tr></table><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p></body></html>