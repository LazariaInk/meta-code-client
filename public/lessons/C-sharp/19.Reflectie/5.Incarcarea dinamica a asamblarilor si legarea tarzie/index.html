<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c19 doc-content"><p class="c0"><span class="c3">&Icirc;nc&#259;rcarea dinamic&#259; a asambl&#259;rilor &#537;i legarea t&acirc;rzie.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">La crearea unei aplica&#539;ii, se define&#537;te un set de asambl&#259;ri care vor fi utilizate. &Icirc;n proiect se specific&#259; referin&#539;ele c&#259;tre aceste asambl&#259;ri, iar c&acirc;nd aplica&#539;ia este executat&#259;, la accesarea func&#539;ionalit&#259;&#539;ii acestor asambl&#259;ri, acestea sunt &icirc;nc&#259;rcate automat.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Totu&#537;i, putem &icirc;nc&#259;rca dinamic &#537;i alte asambl&#259;ri, pentru care nu exist&#259; referin&#539;e &icirc;n proiect.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Pentru gestionarea asambl&#259;rilor, &icirc;n spa&#539;iul de nume</span><span class="c6 c14">&nbsp;System.Reflection</span><span class="c6">&nbsp;exist&#259; clasa </span><span class="c7">Assembly</span><span class="c10 c6">. Cu ajutorul acesteia, putem &icirc;nc&#259;rca &#537;i examina o asamblare.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Pentru a &icirc;nc&#259;rca dinamic o asamblare &icirc;n aplica&#539;ie, trebuie s&#259; folosim metodele statice</span><span class="c7">&nbsp;Assembly.LoadFrom() </span><span class="c6">sau</span><span class="c7">&nbsp;Assembly.Load()</span><span class="c10 c6">.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Metoda</span><span class="c6 c14">&nbsp;LoadFrom()</span><span class="c10 c6">&nbsp;prime&#537;te ca parametru calea c&#259;tre asamblare.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">S&#259; presupunem c&#259; avem dou&#259; proiecte:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 106.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 106.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">S&#259; presupunem c&#259; &icirc;n proiectul MyApp, care este compilat &icirc;ntr-o asamblare MyApp.dll, avem un fi&#537;ier Program.cs cu urm&#259;torul cod:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.f68e117ee8f3e286592c68716fa2b60cd397233a"></a><a id="t.0"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c8">Person tom = </span><span class="c1">new</span><span class="c8">&nbsp;Person(</span><span class="c11">&quot;Tom&quot;</span><span class="c8">);<br>Console.WriteLine(</span><span class="c11">$&quot;Hello, {tom.Name}&quot;</span><span class="c8">);<br> <br></span><span class="c1">class</span><span class="c8">&nbsp;</span><span class="c16">Person</span><span class="c8"><br>{<br> &nbsp; &nbsp;</span><span class="c1">public</span><span class="c8">&nbsp;</span><span class="c1">string</span><span class="c8">&nbsp;Name { </span><span class="c1">get</span><span class="c8">; }<br> &nbsp; &nbsp;</span><span class="c1">public</span><span class="c8">&nbsp;</span><span class="c16">Person</span><span class="c8">(</span><span class="c1">string</span><span class="c8">&nbsp;name) =&gt; Name = name;<br>}</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">&Icirc;n alt proiect, vom examina asamblarea MyApp.dll pentru a vedea ce tipuri con&#539;ine:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.9eb5f750cd349bb33c53a2b4c50d5bdff1649860"></a><a id="t.1"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c1">using</span><span class="c8">&nbsp;System.Reflection;<br><br></span><span class="c1">string</span><span class="c8">&nbsp;dllPath = </span><span class="c11">@&quot;C:\Users\Petrea\source\repos\MyApp\MyApp\bin\Debug\net8.0\MyApp.dll&quot;</span><span class="c8">;<br>Assembly asm = Assembly.LoadFrom(dllPath);<br><br>Console.WriteLine(asm.FullName);<br></span><span class="c15">// ob&#539;inem toate tipurile din asamblarea MyApp.dll</span><span class="c8"><br>Type[] types = asm.GetTypes();<br></span><span class="c1">foreach</span><span class="c8">&nbsp;(Type t </span><span class="c1">in</span><span class="c8">&nbsp;types)<br>{<br> &nbsp; &nbsp;Console.WriteLine(t.Name);<br>}<br></span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">&Icirc;n acest caz, se specific&#259; asamblarea MyApp.dll pentru examinare. Aici este folosit&#259; calea relativ&#259;, deoarece asamblarea se afl&#259; &icirc;n acela&#537;i folder cu aplica&#539;ia - &icirc;n proiect, &icirc;n directorul </span><span class="c6 c14">bin/Debug/net8.0</span><span class="c10 c6">. Se poate specifica &#537;i numele aplica&#539;iei curente, caz &icirc;n care programul se va examina pe sine. Oricum, trebuie avut &icirc;n vedere c&#259; se pot &icirc;nc&#259;rca (cel pu&#539;in &icirc;n .NET 8.0) asambl&#259;ri cu extensia .dll, dar nu &#537;i .exe.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">&Icirc;n cazul meu, voi ob&#539;ine urm&#259;toarea ie&#537;ire &icirc;n consol&#259;:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.2cf4e7a6efa185c962d8f3fcb4de3a995625f544"></a><a id="t.2"></a><table class="c4"><tr class="c18"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c8 c17">MyApp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span></p><p class="c9"><span class="c8 c17">Program</span></p><p class="c9"><span class="c8 c17">Person</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Dup&#259; cum se poate observa din ie&#537;ire, denumirea complet&#259; a asambl&#259;rii este: MyApp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null. Iar asamblarea MyApp.dll con&#539;ine patru tipuri - pe l&acirc;ng&#259; clasa Person &#537;i clasa Program definit&#259; implicit.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Metoda </span><span class="c6 c14">Load() </span><span class="c6">func&#539;ioneaz&#259; similar, doar c&#259; prime&#537;te ca parametru un nume prietenos al asambl&#259;rii, care deseori coincide cu numele aplica&#539;iei: </span><span class="c6 c14">Assembly asm = Assembly.Load(&quot;MyApp&quot;)</span><span class="c10 c6">;</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Dup&#259; ce am ob&#539;inut toate tipurile asambl&#259;rii cu ajutorul metodei</span><span class="c6 c14">&nbsp;GetTypes()</span><span class="c10 c6">, putem aplica fiec&#259;rui tip toate metodele discutate &icirc;n tema anterioar&#259;.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c21">Legarea t&acirc;rzie.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Cu ajutorul &icirc;nc&#259;rc&#259;rii dinamice, putem implementa tehnologia leg&#259;rii t&acirc;rzii.</span><span class="c7">&nbsp;Legarea t&acirc;rzie</span><span class="c10 c6">&nbsp;permite crearea instan&#539;elor unui anumit tip &#537;i utilizarea acestora &icirc;n timpul execu&#539;iei aplica&#539;iei.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Utilizarea leg&#259;rii t&acirc;rzii este mai pu&#539;in sigur&#259;, deoarece &icirc;n cazul codific&#259;rii stricte a tuturor tipurilor (legare timpurie) la etapa de compilare, putem detecta multe erori. Totu&#537;i, legarea t&acirc;rzie permite crearea aplica&#539;iilor extensibile, unde func&#539;ionalitatea suplimentar&#259; a programului nu este cunoscut&#259; &#537;i poate fi dezvoltat&#259; &#537;i conectat&#259; de dezvoltatori ter&#539;i.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Rolul cheie &icirc;n legarea t&acirc;rzie &icirc;l joac&#259; clasa </span><span class="c7">System.Activator</span><span class="c6">. Cu ajutorul metodei sale statice</span><span class="c7">&nbsp;Activator.CreateInstance()</span><span class="c10 c6">, se pot crea instan&#539;e ale unui tip specificat.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">De exemplu, s&#259; &icirc;nc&#259;rc&#259;m dinamic o asamblare &#537;i s&#259; apel&#259;m o metod&#259; din aceasta. S&#259; presupunem c&#259; asamblarea MyApp.exe con&#539;ine urm&#259;torul program:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.f639ac81eac6ae0e0dda8dc2d6a9426413d4b92d"></a><a id="t.3"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c1">class</span><span class="c8">&nbsp;</span><span class="c16">Program</span><span class="c8"><br>{<br> &nbsp; &nbsp;</span><span class="c1">static</span><span class="c8">&nbsp;</span><span class="c1">void</span><span class="c8">&nbsp;</span><span class="c16">Main</span><span class="c8">(</span><span class="c1">string</span><span class="c8">[] args)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">var</span><span class="c8">&nbsp;number = </span><span class="c13">5</span><span class="c8">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">var</span><span class="c8">&nbsp;result = Square(number);<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c11">$&quot;P&#259;tratul lui {number} este {result}&quot;</span><span class="c8">);<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c1">static</span><span class="c8">&nbsp;</span><span class="c1">int</span><span class="c8">&nbsp;</span><span class="c16">Square</span><span class="c8">(</span><span class="c1">int</span><span class="c8">&nbsp;n) =&gt; n * n;<br>}</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">&Icirc;n acest caz, am definit explicit clasa Program cu metoda Main. De asemenea, &icirc;n clasa Program am definit o metod&#259; static&#259; Square, care prime&#537;te un num&#259;r ca parametru &#537;i returneaz&#259; p&#259;tratul acestuia.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Acum, s&#259; &icirc;nc&#259;rc&#259;m dinamic asamblarea cu acest program &icirc;ntr-un alt program &#537;i s&#259; apel&#259;m metodele sale.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">S&#259; presupunem c&#259; programul nostru principal arat&#259; astfel:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.bbf93f9034364db94b3d9735ba91b86c223970d0"></a><a id="t.4"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c1">using</span><span class="c8">&nbsp;System.Reflection;<br> <br>Assembly asm = Assembly.LoadFrom(</span><span class="c11">&quot;MyApp.dll&quot;</span><span class="c8">);<br> <br>Type? t = asm.GetType(</span><span class="c11">&quot;Program&quot;</span><span class="c8">);<br></span><span class="c1">if</span><span class="c8">&nbsp;(t </span><span class="c1">is</span><span class="c8">&nbsp;not </span><span class="c1">null</span><span class="c8">)<br>{<br> &nbsp; &nbsp;</span><span class="c15">// ob&#539;inem metoda Square</span><span class="c8"><br> &nbsp; &nbsp;MethodInfo? square = t.GetMethod(</span><span class="c11">&quot;Square&quot;</span><span class="c8">, BindingFlags.NonPublic | BindingFlags.Static);<br> <br> &nbsp; &nbsp;</span><span class="c15">// apel&#259;m metoda, &icirc;i transmitem valori pentru parametri &#537;i ob&#539;inem rezultatul</span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c1">object</span><span class="c8">? result = square?.Invoke(</span><span class="c1">null</span><span class="c8">, </span><span class="c1">new</span><span class="c8">&nbsp;</span><span class="c1">object</span><span class="c8">[] { </span><span class="c13">7</span><span class="c8">&nbsp;});<br> &nbsp; &nbsp;Console.WriteLine(result); </span><span class="c15">// 49</span><span class="c8"><br>}</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Mai &icirc;nt&acirc;i ob&#539;inem o referin&#539;&#259; la asamblarea pe care o examin&#259;m &icirc;n variabila asm:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.1f3213fd0bcf2ce5fde2ccdfe6c11fd9a411d185"></a><a id="t.5"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c8">Assembly asm = Assembly.LoadFrom(</span><span class="c11">&quot;MyApp.dll&quot;</span><span class="c8">);</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Apoi, cu ajutorul metodei GetType, ob&#539;inem tipul - clasa Program, care se afl&#259; &icirc;n asamblarea MyApp.dll:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.ed3938e8f41217070af8bad34823427d27c93ad2"></a><a id="t.6"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c8">Type? t = asm.GetType(</span><span class="c11">&quot;Program&quot;</span><span class="c8">);</span></p></td></tr></table><p class="c0 c2"><span class="c6 c10"></span></p><p class="c0"><span class="c10 c6">&Icirc;n cele din urm&#259;, apel&#259;m metoda. &Icirc;n primul r&acirc;nd, ob&#539;inem metoda propriu-zis&#259;:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.70f314301a1994aba769cc24e3a47561932159cf"></a><a id="t.7"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c8">MethodInfo? square = t.GetMethod(</span><span class="c11">&quot;Square&quot;</span><span class="c8">, BindingFlags.NonPublic | BindingFlags.Static);</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Deoarece metoda Square este privat&#259; &#537;i static&#259;, se transmit flagurile </span><span class="c6 c14">BindingFlags.NonPublic | BindingFlags.Static</span><span class="c10 c6">&nbsp;ca al doilea parametru al metodei.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Apoi, apel&#259;m metoda folosind Invoke:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.0f05e5156e3cb267d375805d9e12620844b2bb66"></a><a id="t.8"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c1">object</span><span class="c8">? result = square?.Invoke(</span><span class="c1">null</span><span class="c8">, </span><span class="c1">new</span><span class="c8">&nbsp;</span><span class="c1">object</span><span class="c8">[] { </span><span class="c13">7</span><span class="c8">&nbsp;});</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Aici, primul parametru reprezint&#259; obiectul pentru care este apelat&#259; metoda, iar al doilea - setul de parametri sub forma unei matrice object[]. Totu&#537;i, deoarece metoda apelat&#259; este static&#259; &#537;i nu apar&#539;ine unui anumit obiect, se transmite null ca prim argument &icirc;n metod&#259;.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">Deoarece metoda Square returneaz&#259; o valoare, putem ob&#539;ine aceast&#259; valoare din metod&#259; sub forma unui obiect de tip object.</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Dac&#259; metoda nu ar fi primit parametri, &icirc;n locul matricei de obiecte s-ar fi folosit valoarea </span><span class="c6 c14 c20">null: method.Invoke(null, null).</span></p><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c10 c6">&Icirc;n asamblarea MyApp.exe, &icirc;n clasa Program exist&#259; &#537;i o alt&#259; metod&#259; - metoda Main, care de asemenea efectueaz&#259; anumite opera&#539;iuni. S&#259; o apel&#259;m acum:</span></p><p class="c0 c2"><span class="c10 c6"></span></p><a id="t.5ef16d18b326cb99f2942d7b4e2c9fa168894ae5"></a><a id="t.9"></a><table class="c4"><tr class="c5"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c1">using</span><span class="c8">&nbsp;System.Reflection;<br> <br>Assembly asm = Assembly.LoadFrom(</span><span class="c11">&quot;MyApp.dll&quot;</span><span class="c8">);<br> <br>Type? program = asm.GetType(</span><span class="c11">&quot;Program&quot;</span><span class="c8">);<br></span><span class="c1">if</span><span class="c8">&nbsp;(program </span><span class="c1">is</span><span class="c8">&nbsp;not </span><span class="c1">null</span><span class="c8">)<br>{<br> &nbsp; &nbsp;</span><span class="c15">// ob&#539;inem metoda Main</span><span class="c8"><br> &nbsp; &nbsp;MethodInfo? main = program.GetMethod(</span><span class="c11">&quot;Main&quot;</span><span class="c8">, BindingFlags.NonPublic | BindingFlags.Static);<br> <br> &nbsp; &nbsp;</span><span class="c15">// apel&#259;m metoda Main</span><span class="c8"><br> &nbsp; &nbsp;main?.Invoke(</span><span class="c1">null</span><span class="c8">, </span><span class="c1">new</span><span class="c8">&nbsp;</span><span class="c1">object</span><span class="c8">[] { </span><span class="c1">new</span><span class="c8">&nbsp;</span><span class="c1">string</span><span class="c8">[] { } }); &nbsp; </span><span class="c15">// P&#259;tratul lui 5 este 25</span><span class="c8"><br>}</span></p></td></tr></table><p class="c0 c2"><span class="c10 c6"></span></p><p class="c0"><span class="c6">Deoarece metoda Main este static&#259; &#537;i non-public&#259;, se aplic&#259; &#537;i aici masca de bi&#539;i </span><span class="c6 c14">BindingFlags.NonPublic | BindingFlags.Static</span><span class="c6">. &#536;i deoarece ea prime&#537;te ca parametru un &#537;ir de stringuri, la apelarea metodei se transmite o valoare corespunz&#259;toare: </span><span class="c6 c14">main.Invoke(null, new object[]{new string[]{}})</span><span class="c10 c6">.</span></p><p class="c0 c2"><span class="c10 c6"></span></p></body></html>