<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <style type="text/css">
        @import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);

        ol {
            margin: 0;
            padding: 0
        }

        table td,
        table th {
            padding: 0
        }

        .c17 {
            border-right-style: solid;
            padding: 5pt 5pt 5pt 5pt;
            border-bottom-color: #000000;
            border-top-width: 0pt;
            border-right-width: 0pt;
            border-left-color: #000000;
            vertical-align: top;
            border-right-color: #000000;
            border-left-width: 0pt;
            border-top-style: solid;
            background-color: #333333;
            border-left-style: solid;
            border-bottom-width: 0pt;
            width: 468pt;
            border-top-color: #000000;
            border-bottom-style: solid
        }

        .c2 {
            padding-top: 0pt;
            padding-bottom: 0pt;
            line-height: 1.5;
            orphans: 2;
            widows: 2;
            text-align: left;
            height: 11pt
        }

        .c5 {
            padding-top: 0pt;
            padding-bottom: 0pt;
            line-height: 1.5;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        .c6 {
            background-color: #333333;
            font-size: 12pt;
            font-family: "Consolas";
            color: #fcc28c;
            font-weight: 400
        }

        .c14 {
            background-color: #333333;
            font-size: 12pt;
            font-family: "Consolas";
            color: #d36363;
            font-weight: 400
        }

        .c10 {
            background-color: #333333;
            font-size: 12pt;
            font-family: "Consolas";
            color: #888888;
            font-weight: 400
        }

        .c11 {
            background-color: #333333;
            font-size: 12pt;
            font-family: "Consolas";
            color: #a2fca2;
            font-weight: 400
        }

        .c4 {
            background-color: #333333;
            font-size: 12pt;
            font-family: "Consolas";
            color: #ffffaa;
            font-weight: 400
        }

        .c0 {
            background-color: #333333;
            font-size: 12pt;
            font-family: "Consolas";
            color: #ffffff;
            font-weight: 400
        }

        .c8 {
            padding-top: 0pt;
            padding-bottom: 0pt;
            line-height: 1.15;
            text-align: left
        }

        .c3 {
            color: #000000;
            text-decoration: none;
            vertical-align: baseline;
            font-style: normal
        }

        .c9 {
            border-spacing: 0;
            border-collapse: collapse;
            margin-right: auto
        }

        .c16 {
            font-weight: 700;
            font-size: 15pt;
            font-family: "Open Sans"
        }

        .c19 {
            background-color: #ffffff;
            max-width: 468pt;
            padding: 72pt 72pt 72pt 72pt
        }

        .c18 {
            font-weight: 700;
            font-size: 27pt;
            font-family: "Open Sans"
        }

        .c1 {
            font-size: 12pt;
            font-family: "Open Sans";
            font-weight: 400
        }

        .c13 {
            color: #000000;
            text-decoration: none;
            vertical-align: baseline
        }

        .c15 {
            font-size: 12pt;
            font-family: "Open Sans";
            font-weight: 700
        }

        .c7 {
            height: 0pt
        }

        .c12 {
            font-style: italic
        }

        .title {
            padding-top: 0pt;
            color: #000000;
            font-size: 26pt;
            padding-bottom: 3pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        .subtitle {
            padding-top: 0pt;
            color: #666666;
            font-size: 15pt;
            padding-bottom: 16pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        li {
            color: #000000;
            font-size: 11pt;
            font-family: "Arial"
        }

        p {
            margin: 0;
            color: #000000;
            font-size: 11pt;
            font-family: "Arial"
        }

        h1 {
            padding-top: 20pt;
            color: #000000;
            font-size: 20pt;
            padding-bottom: 6pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h2 {
            padding-top: 18pt;
            color: #000000;
            font-size: 16pt;
            padding-bottom: 6pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h3 {
            padding-top: 16pt;
            color: #434343;
            font-size: 14pt;
            padding-bottom: 4pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h4 {
            padding-top: 14pt;
            color: #666666;
            font-size: 12pt;
            padding-bottom: 4pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h5 {
            padding-top: 12pt;
            color: #666666;
            font-size: 11pt;
            padding-bottom: 4pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h6 {
            padding-top: 12pt;
            color: #666666;
            font-size: 11pt;
            padding-bottom: 4pt;
            font-family: "Arial";
            line-height: 1.15;
            page-break-after: avoid;
            font-style: italic;
            orphans: 2;
            widows: 2;
            text-align: left
        }
    </style>
</head>

<body class="c19 doc-content">
    <h1 class="c5 c3 c18">Tipuri de valori și tipuri de referințe.</h1>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Anterior am examinat urm&#259;toarele tipuri elementare de date: int, byte, double,
            string, object &#537;i altele. De asemenea, exist&#259; tipuri complexe: structuri, enumer&#259;ri, clase.
            Toate aceste tipuri de date pot fi &icirc;mp&#259;r&#539;ite &icirc;n tipuri de valori, cunoscute &#537;i
            sub denumirea de </span><span class="c1 c12">tipuri valorice </span><span class="c1">(value types)
            &#537;i</span><span class="c1 c12">&nbsp;tipuri de referin&#539;e</span><span class="c3 c1">&nbsp;(reference
            types). Este important s&#259; &icirc;n&#539;elegem diferen&#539;ele dintre ele.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Tipuri de valori:</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">1. Tipuri &icirc;ntregi (</span><span class="c1 c12">byte, sbyte, short, ushort, int,
            uint, long, ulong</span><span class="c3 c1">)</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">2. Tipuri cu virgul&#259; mobil&#259; (</span><span class="c1 c12">float,
            double</span><span class="c3 c1">)</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">3. Tipul </span><span class="c1 c12 c13">decimal</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">4. Tipul </span><span class="c1 c13 c12">bool</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">5. Tipul </span><span class="c1 c13 c12">char</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">6. Enumer&#259;ri (</span><span class="c1 c12">enum</span><span
            class="c3 c1">)</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">7. Structuri (</span><span class="c1 c12">struct</span><span class="c3 c1">)</span>
    </p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Tipuri de referin&#539;e:</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">1. Tipul </span><span class="c1 c13 c12">object</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">2. Tipul </span><span class="c1 c13 c12">string</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">3. Clase (</span><span class="c1 c12">class</span><span class="c3 c1">)</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">4. Interfe&#539;e (</span><span class="c1 c12">interface</span><span
            class="c3 c1">)</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">5. Delega&#539;i (</span><span class="c1 c12">delegate</span><span
            class="c3 c1">)</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Care sunt diferen&#539;ele dintre ele? Pentru aceasta trebuie s&#259;
            &icirc;n&#539;elegem organizarea memoriei &icirc;n .NET. Aici memoria este &icirc;mp&#259;r&#539;it&#259;
            &icirc;n dou&#259; tipuri: stiv&#259; (</span><span class="c15">stack</span><span class="c1">) &#537;i
            gr&#259;mad&#259; (</span><span class="c15">heap</span><span class="c1">). Parametrii &#537;i variabilele
            metodei, care reprezint&#259; tipuri de valori, &icirc;&#537;i plaseaz&#259; valoarea &icirc;n </span><span
            class="c1 c12">stiv&#259;</span><span class="c3 c1">. Stiva reprezint&#259; o structur&#259; de date care
            cre&#537;te de jos &icirc;n sus: fiecare element nou ad&#259;ugat este plasat deasupra celui precedent.
            Durata de via&#539;&#259; a variabilelor acestor tipuri este limitat&#259; la contextul lor. Fizic, stiva
            este o anumit&#259; zon&#259; de memorie &icirc;n spa&#539;iul de adrese.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">C&acirc;nd programul este lansat pentru execu&#539;ie, la sf&acirc;r&#537;itul
            blocului de memorie rezervat pentru stiv&#259; este setat un indicator al stivei. La plasarea datelor
            &icirc;n stiv&#259;, indicatorul este resetat astfel &icirc;nc&acirc;t s&#259; indice din nou locul liber.
            La apelarea fiec&#259;rei metode individuale, &icirc;n stiv&#259; va fi alocat&#259; o zon&#259; de memorie
            sau un cadru de stiv&#259; unde vor fi stocate valorile parametrilor &#537;i variabilelor sale.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">De exemplu:</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.87081d4f6b5cf2eb14695fc27f79d8c3f74b8dca"></a><a id="t.0"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c6">class</span><span class="c0">&nbsp;</span><span
                        class="c4">Program</span><span class="c0"><br>{<br> &nbsp; &nbsp;</span><span
                        class="c6">static</span><span class="c0">&nbsp;</span><span class="c6">void</span><span
                        class="c0">&nbsp;</span><span class="c4">Main</span><span class="c0">(</span><span
                        class="c6">string</span><span class="c0">[] args)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;
                        &nbsp;Calculate(</span><span class="c14">5</span><span class="c0">);<br> &nbsp; &nbsp;}<br><br>
                        &nbsp; &nbsp;</span><span class="c6">static</span><span class="c0">&nbsp;</span><span
                        class="c6">void</span><span class="c0">&nbsp;</span><span class="c4">Calculate</span><span
                        class="c0">(</span><span class="c6">int</span><span class="c0">&nbsp;t)<br> &nbsp; &nbsp;{<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">int</span><span class="c0">&nbsp;x =
                    </span><span class="c14">6</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span
                        class="c6">int</span><span class="c0">&nbsp;y = </span><span class="c14">7</span><span
                        class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;z = y + t;<br> &nbsp; &nbsp;}<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">La rularea unui astfel de program, &icirc;n stiv&#259; vor fi definite dou&#259;
            cadre - pentru metoda Main (deoarece este apelat&#259; la lansarea programului) &#537;i pentru metoda
            Calculate:</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 449.00px; height: 393.00px;"><img
                alt="" src="images/image2.png"
                style="width: 449.00px; height: 393.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">La apelarea metodei Calculate, &icirc;n cadrul s&#259;u din stiv&#259; vor fi
            plasate valorile t, x, y &#537;i z. Acestea sunt definite &icirc;n contextul metodei respective. C&acirc;nd
            metoda se termin&#259;, zona de memorie alocat&#259; stivei poate fi ulterior utilizat&#259; de alte
            metode.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">&Icirc;n cazul &icirc;n care parametrul sau variabila metodei reprezint&#259; un
            tip valoric, &icirc;n stiv&#259; va fi stocat&#259; valoarea direct&#259; a acestui parametru sau
            variabil&#259;. De exemplu, &icirc;n acest caz, variabilele &#537;i parametrii metodei Calculate
            reprezint&#259; tipul valoric - tipul int, astfel &icirc;nc&acirc;t &icirc;n stiv&#259; vor fi stocate
            valorile lor numerice.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Tipurile de referin&#539;e sunt stocate &icirc;n gr&#259;mad&#259; (heap), care
            poate fi reprezentat&#259; ca un set neordonat de obiecte eterogene. Fizic, aceasta este restul memoriei
            disponibile procesului.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">La crearea unui obiect de tip referin&#539;&#259;, &icirc;n stiv&#259; este
            plasat&#259; o referin&#539;&#259; la adresa din gr&#259;mad&#259; (heap). C&acirc;nd un obiect de tip
            referin&#539;&#259; nu mai este utilizat, intervine colectorul automat de gunoi: acesta observ&#259; c&#259;
            nu mai exist&#259; referin&#539;e la obiectul din heap, elimin&#259; condi&#539;ionat acest obiect &#537;i
            elibereaz&#259; memoria - marc&acirc;nd de fapt c&#259; segmentul respectiv de memorie poate fi utilizat
            pentru stocarea altor date.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Astfel, dac&#259; modific&#259;m metoda Calculate astfel:</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.3ee2157b5df33235f8217f0aba769d807546befe"></a><a id="t.1"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c6">static</span><span class="c0">&nbsp;</span><span
                        class="c6">void</span><span class="c0">&nbsp;</span><span class="c4">Calculate</span><span
                        class="c0">(</span><span class="c6">int</span><span class="c0">&nbsp;t)<br>{<br> &nbsp;
                        &nbsp;</span><span class="c6">object</span><span class="c0">&nbsp;x = </span><span
                        class="c14">6</span><span class="c0">;<br> &nbsp; &nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;y = </span><span class="c14">7</span><span class="c0">;<br> &nbsp;
                        &nbsp;</span><span class="c6">int</span><span class="c0">&nbsp;z = y + t;<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Valoarea variabilei x va fi acum stocat&#259; &icirc;n gr&#259;mad&#259;, deoarece
            reprezint&#259; tipul de referin&#539;&#259; object, iar &icirc;n stiv&#259; va fi stocat&#259;
            referin&#539;a la obiectul din gr&#259;mad&#259;.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 595.00px; height: 371.00px;"><img
                alt="" src="images/image4.png"
                style="width: 595.00px; height: 371.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c16">Structuri compuse.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Acum s&#259; consider&#259;m situa&#539;ia &icirc;n care un tip de valori &#537;i
            un tip de referin&#539;&#259; reprezint&#259; structuri compuse - structura &#537;i clasa:</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.e59ac594985cba92772a0a552faefe1ddbb5bdcf"></a><a id="t.2"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c0">State state1 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;State(); </span><span class="c10">// State - structur&#259;, datele sale sunt
                        plasate &icirc;n stiv&#259;</span><span class="c0"><br>Country country1 = </span><span
                        class="c6">new</span><span class="c0">&nbsp;Country(); </span><span class="c10">// Country -
                        clas&#259;, &icirc;n stiv&#259; este plasat&#259; referin&#539;a la adresa din heap</span><span
                        class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c10">// iar &icirc;n heap sunt
                        plasate toate datele obiectului country1</span><span class="c0"><br></span><span
                        class="c6">struct</span><span class="c0">&nbsp;State<br>{<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;x;<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;y;<br>}<br></span><span class="c6">class</span><span
                        class="c0">&nbsp;</span><span class="c4">Country</span><span class="c0"><br>{<br> &nbsp;
                        &nbsp;</span><span class="c6">public</span><span class="c0">&nbsp;</span><span
                        class="c6">int</span><span class="c0">&nbsp;x;<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;y;<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Aici, &icirc;n metoda Main, &icirc;n stiv&#259; este alocat&#259; memorie pentru
            obiectul state1. Apoi, &icirc;n stiv&#259; este creat&#259; o referin&#539;&#259; pentru obiectul country1
            (</span><span class="c1 c12">Country country1</span><span class="c1">), iar cu ajutorul constructorului
            cuv&acirc;ntului cheie </span><span class="c1 c12">new </span><span class="c1">se aloc&#259; loc &icirc;n
            heap (</span><span class="c1 c12">new Country()</span><span class="c3 c1">). Referin&#539;a din stiv&#259;
            pentru obiectul country1 va reprezenta adresa locului din heap unde este plasat obiectul respectiv.</span>
    </p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 602.00px; height: 416.00px;"><img
                alt="" src="images/image5.png"
                style="width: 602.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Astfel, &icirc;n stiv&#259; vor ajunge toate c&acirc;mpurile structurii state1
            &#537;i referin&#539;a la obiectul country1 din heap.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Dar, s&#259; presupunem c&#259; &icirc;n structura State este de asemenea
            definit&#259; o variabil&#259; de tip referin&#539;&#259; Country. Unde va stoca ea valoarea sa dac&#259;
            este definit&#259; &icirc;n tipul valoric?</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.d91cce8d455ed654296559850a6856bcd40affe7"></a><a id="t.3"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c0">State state1 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;State();<br>Country country1 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;Country();<br><br></span><span class="c6">struct</span><span
                        class="c0">&nbsp;State<br>{<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;</span><span class="c6">int</span><span class="c0">&nbsp;x;<br> &nbsp;
                        &nbsp;</span><span class="c6">public</span><span class="c0">&nbsp;</span><span
                        class="c6">int</span><span class="c0">&nbsp;y;<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;Country country;<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c4">State</span><span
                        class="c0">()<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;x = </span><span
                        class="c14">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;y = </span><span
                        class="c14">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;country = </span><span
                        class="c6">new</span><span class="c0">&nbsp;Country();<br> &nbsp; &nbsp;}<br>}<br></span><span
                        class="c6">class</span><span class="c0">&nbsp;</span><span class="c4">Country</span><span
                        class="c0"><br>{<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;</span><span class="c6">int</span><span class="c0">&nbsp;x;<br> &nbsp;
                        &nbsp;</span><span class="c6">public</span><span class="c0">&nbsp;</span><span
                        class="c6">int</span><span class="c0">&nbsp;y;<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Valoarea variabilei state1.country va fi de asemenea stocat&#259; &icirc;n
            gr&#259;mad&#259;, deoarece aceast&#259; variabil&#259; reprezint&#259; un tip de
            referin&#539;&#259;:</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 533.00px; height: 370.00px;"><img
                alt="" src="images/image1.png"
                style="width: 533.00px; height: 370.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c16">Copierea valorilor.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Tipul de date trebuie luat &icirc;n considerare la copierea valorilor. La
            atribuirea datelor unui obiect de tip valoric, acesta prime&#537;te o copie a datelor. La atribuirea datelor
            unui obiect de tip referin&#539;&#259;, acesta prime&#537;te nu o copie a obiectului, ci o
            referin&#539;&#259; la acel obiect din heap. De exemplu:</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.648907c926f0ec3f9c7d69e9de517acdceda9ba4"></a><a id="t.4"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c0">State state1 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;State(); </span><span class="c10">// Structura State</span><span
                        class="c0"><br>State state2 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;State();<br>state2.x = </span><span class="c14">1</span><span
                        class="c0">;<br>state2.y = </span><span class="c14">2</span><span class="c0">;<br>state1 =
                        state2;<br>state2.x = </span><span class="c14">5</span><span class="c0">; </span><span
                        class="c10">// state1.x = 1 r&#259;m&acirc;ne neschimbat</span><span
                        class="c0"><br>Console.WriteLine(state1.x); </span><span class="c10">// 1</span><span
                        class="c0"><br>Console.WriteLine(state2.x); </span><span class="c10">// 5</span><span
                        class="c0"><br><br>Country country1 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;Country(); </span><span class="c10">// Clasa Country</span><span
                        class="c0"><br>Country country2 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;Country();<br>country2.x = </span><span class="c14">1</span><span
                        class="c0">;<br>country2.y = </span><span class="c14">4</span><span class="c0">;<br>country1 =
                        country2;<br>country2.x = </span><span class="c14">7</span><span class="c0">; </span><span
                        class="c10">// acum &#537;i country1.x = 7, deoarece ambele referin&#539;e &#537;i country1
                        &#537;i country2</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp;</span><span class="c10">// indic&#259; acela&#537;i obiect din heap</span><span
                        class="c0"><br>Console.WriteLine(country1.x); </span><span class="c10">// 7</span><span
                        class="c0"><br>Console.WriteLine(country2.x); </span><span class="c10">// 7</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Deoarece state1 este o structur&#259;, la atribuirea</span><span
            class="c1 c12">&nbsp;state1 = state2 </span><span class="c1">aceasta prime&#537;te o copie a structurii
        </span><span class="c1 c12">state2</span><span class="c1">. Iar obiectul clasei country1 la atribuirea
        </span><span class="c1 c12">country1 = country2</span><span class="c1">&nbsp;prime&#537;te o referin&#539;&#259;
            la acela&#537;i obiect la care indic&#259; </span><span class="c1 c12">country2</span><span class="c3 c1">.
            Prin urmare, schimbarea country2 va afecta &#537;i country1.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c16">Tipuri de referin&#539;e &icirc;n cadrul tipurilor valorice.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Acum s&#259; examin&#259;m un exemplu mai complex, &icirc;n care &icirc;n cadrul
            unei structuri avem o variabil&#259; de tip referin&#539;&#259;, de exemplu, a unei clase:</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.0aa684dfa1e84bba30101ea52913061950dee94a"></a><a id="t.5"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c0">State state1 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;State();<br>State state2 = </span><span class="c6">new</span><span
                        class="c0">&nbsp;State();<br><br>state2.country.x = </span><span class="c14">5</span><span
                        class="c0">;<br>state1 = state2;<br>state2.country.x = </span><span class="c14">8</span><span
                        class="c0">; </span><span class="c10">// acum &#537;i state1.country.x = 8, deoarece
                        state1.country &#537;i state2.country</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;
                        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c10">// indic&#259;
                        acela&#537;i obiect din heap</span><span
                        class="c0"><br>Console.WriteLine(state<br><br></span><span class="c14">1.</span><span
                        class="c0">country.x); </span><span class="c10">// 8</span><span
                        class="c0"><br>Console.WriteLine(state2.country.x); </span><span class="c10">// 8</span><span
                        class="c0"><br><br></span><span class="c6">struct</span><span class="c0">&nbsp;State<br>{<br>
                        &nbsp; &nbsp;</span><span class="c6">public</span><span class="c0">&nbsp;</span><span
                        class="c6">int</span><span class="c0">&nbsp;x;<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;y;<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;Country country;<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;</span><span class="c4">State</span><span class="c0">()<br> &nbsp; &nbsp;{<br>
                        &nbsp; &nbsp; &nbsp; &nbsp;x = </span><span class="c14">0</span><span class="c0">;<br> &nbsp;
                        &nbsp; &nbsp; &nbsp;y = </span><span class="c14">0</span><span class="c0">;<br> &nbsp; &nbsp;
                        &nbsp; &nbsp;country = </span><span class="c6">new</span><span class="c0">&nbsp;Country();
                    </span><span class="c10">// alocarea memoriei pentru obiectul Country</span><span class="c0"><br>
                        &nbsp; &nbsp;}<br>}<br></span><span class="c6">class</span><span class="c0">&nbsp;</span><span
                        class="c4">Country</span><span class="c0"><br>{<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;x;<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;</span><span class="c6">int</span><span class="c0">&nbsp;y;<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Variabilele de tip referin&#539;&#259; din structuri p&#259;streaz&#259; &icirc;n
            stiv&#259; referin&#539;a la obiectul din heap. &#536;i la atribuirea a dou&#259; structuri</span><span
            class="c1 c12">&nbsp;state1 = state2</span><span class="c3 c1">, structura state1 prime&#537;te de asemenea
            referin&#539;a la obiectul country din heap. Prin urmare, schimbarea state2.country va determina de asemenea
            schimbarea state1.country.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 558.00px; height: 378.00px;"><img
                alt="" src="images/image3.png"
                style="width: 558.00px; height: 378.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c16">Obiectele claselor ca parametri ai metodelor.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c3 c1">Organizarea obiectelor &icirc;n memorie trebuie luat&#259; &icirc;n considerare la
            transmiterea parametrilor prin valoare &#537;i prin referin&#539;&#259;. Dac&#259; parametrii metodelor
            reprezint&#259; obiecte ale claselor, utilizarea parametrilor are anumite particularit&#259;&#539;i. De
            exemplu, s&#259; cre&#259;m o metod&#259; care ca parametru prime&#537;te un obiect Person:</span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.bdf6cde14597a175e74bd7a5ba39de18b452dc52"></a><a id="t.6"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c0">Person p = </span><span class="c6">new</span><span
                        class="c0">&nbsp;Person { name = </span><span class="c11">&quot;Tom&quot;</span><span
                        class="c0">, age = </span><span class="c14">23</span><span
                        class="c0">&nbsp;};<br>ChangePerson(p);<br><br>Console.WriteLine(p.name); </span><span
                        class="c10">// Alice</span><span class="c0"><br>Console.WriteLine(p.age); </span><span
                        class="c10">// 23</span><span class="c0"><br><br></span><span class="c6">void</span><span
                        class="c0">&nbsp;</span><span class="c4">ChangePerson</span><span class="c0">(Person
                        person)<br>{<br> &nbsp; &nbsp;</span><span class="c10">// func&#539;ioneaz&#259;</span><span
                        class="c0"><br> &nbsp; &nbsp;person.name = </span><span
                        class="c11">&quot;Alice&quot;</span><span class="c0">;<br> &nbsp; &nbsp;</span><span
                        class="c10">// func&#539;ioneaz&#259; doar &icirc;n cadrul metodei respective</span><span
                        class="c0"><br> &nbsp; &nbsp;person = </span><span class="c6">new</span><span
                        class="c0">&nbsp;Person { name = </span><span class="c11">&quot;Bill&quot;</span><span
                        class="c0">, age = </span><span class="c14">45</span><span class="c0">&nbsp;};<br> &nbsp;
                        &nbsp;Console.WriteLine(person.name); </span><span class="c10">// Bill</span><span
                        class="c0"><br>}<br><br></span><span class="c6">class</span><span class="c0">&nbsp;</span><span
                        class="c4">Person</span><span class="c0"><br>{<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c6">string</span><span
                        class="c0">&nbsp;name = </span><span class="c11">&quot;&quot;</span><span class="c0">;<br>
                        &nbsp; &nbsp;</span><span class="c6">public</span><span class="c0">&nbsp;</span><span
                        class="c6">int</span><span class="c0">&nbsp;age;<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c1 c3"></span></p>
    <p class="c5"><span class="c1">La transmiterea unui obiect al clasei prin valoare, &icirc;n metod&#259; este
            transmis&#259; o copie a referin&#539;ei la obiect. Aceast&#259; copie indic&#259; acela&#537;i obiect ca
            &#537;i referin&#539;a original&#259;, astfel &icirc;nc&acirc;t putem modifica c&acirc;mpurile &#537;i
            propriet&#259;&#539;ile obiectului, dar nu putem modifica obiectul &icirc;n sine. Prin urmare, &icirc;n
            exemplul de mai sus, va func&#539;iona doar linia </span><span class="c1 c12">person.name =
            &quot;Alice&quot;</span><span class="c3 c1">.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">O alt&#259; linie</span><span class="c1 c12">&nbsp;person = new Person { name =
            &quot;Bill&quot;, age = 45 }</span><span class="c3 c1">&nbsp;va crea un nou obiect &icirc;n memorie, iar
            person va indica acum noul obiect din memorie. Chiar dac&#259; ulterior &icirc;l modific&#259;m, acest lucru
            nu va afecta referin&#539;a p din metoda Main, deoarece referin&#539;a p &icirc;nc&#259; indic&#259; vechiul
            obiect din memorie.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Dar, la transmiterea parametrului prin referin&#539;&#259; (cu ajutorul
            cuv&acirc;ntului cheie </span><span class="c15">ref</span><span class="c3 c1">) &icirc;n metod&#259; este
            transmis&#259; referin&#539;a la obiectul din memorie. Astfel, putem modifica at&acirc;t c&acirc;mpurile
            &#537;i propriet&#259;&#539;ile obiectului, c&acirc;t &#537;i obiectul &icirc;n sine:</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c2"><span class="c3 c1"></span></p><a id="t.aa92e8eb2e49e9cd74b3f042577e79aa00273c59"></a><a id="t.7"></a>
    <table class="c9">
        <tr class="c7">
            <td class="c17" colspan="1" rowspan="1">
                <p class="c8"><span class="c0">Person p = </span><span class="c6">new</span><span
                        class="c0">&nbsp;Person { name = </span><span class="c11">&quot;Tom&quot;</span><span
                        class="c0">, age = </span><span class="c14">23</span><span
                        class="c0">&nbsp;};<br>ChangePerson(</span><span class="c6">ref</span><span
                        class="c0">&nbsp;p);<br><br>Console.WriteLine(p.name); </span><span class="c10">//
                        Bill</span><span class="c0"><br>Console.WriteLine(p.age); </span><span class="c10">//
                        45</span><span class="c0"><br><br></span><span class="c6">void</span><span
                        class="c0">&nbsp;</span><span class="c4">ChangePerson</span><span class="c0">(</span><span
                        class="c6">ref</span><span class="c0">&nbsp;Person person)<br>{<br> &nbsp; &nbsp;</span><span
                        class="c10">// func&#539;ioneaz&#259;</span><span class="c0"><br> &nbsp; &nbsp;person.name =
                    </span><span class="c11">&quot;Alice&quot;</span><span class="c0">;<br> &nbsp; &nbsp;</span><span
                        class="c10">// func&#539;ioneaz&#259;</span><span class="c0"><br> &nbsp; &nbsp;person =
                    </span><span class="c6">new</span><span class="c0">&nbsp;Person { name = </span><span
                        class="c11">&quot;Bill&quot;</span><span class="c0">, age = </span><span
                        class="c14">45</span><span class="c0">&nbsp;};<br>}<br><br></span><span
                        class="c6">class</span><span class="c0">&nbsp;</span><span class="c4">Person</span><span
                        class="c0"><br>{<br> &nbsp; &nbsp;</span><span class="c6">public</span><span
                        class="c0">&nbsp;</span><span class="c6">string</span><span class="c0">&nbsp;name = </span><span
                        class="c11">&quot;&quot;</span><span class="c0">;<br> &nbsp; &nbsp;</span><span
                        class="c6">public</span><span class="c0">&nbsp;</span><span class="c6">int</span><span
                        class="c0">&nbsp;age;<br>}</span></p>
            </td>
        </tr>
    </table>
    <p class="c2"><span class="c3 c1"></span></p>
    <p class="c5"><span class="c1">Opera&#539;ia </span><span class="c1 c12">new </span><span class="c1">va crea un nou
            obiect &icirc;n memorie, iar referin&#539;a </span><span class="c1 c12">person </span><span
            class="c3 c1">(aceea&#537;i referin&#539;&#259; p din metoda Main) va indica acum noul obiect din
            memorie.</span></p>
    <p class="c2"><span class="c3 c1"></span></p>
</body>

</html>