<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c8 doc-content"><p class="c6"><span class="c16 c19">Pointeri c&#259;tre Structuri, Membri ai Claselor &#537;i Tablouri.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c0">Pointeri c&#259;tre Tipuri &#537;i Opera&#539;ia -&gt;.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Pe l&acirc;ng&#259; pointerii c&#259;tre tipuri simple, se pot folosi pointeri c&#259;tre structuri. Pentru a accesa c&acirc;mpurile structurii la care face referire un pointer, se folose&#537;te opera&#539;ia</span><span class="c17">&nbsp;-&gt;</span><span class="c1">:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.5a39baa2744fcf66db63513a020024e54d40dc75"></a><a id="t.0"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c5">unsafe</span><span class="c2"><br>{<br> &nbsp; &nbsp;Point point = </span><span class="c5">new</span><span class="c2">&nbsp;Point(</span><span class="c3">0</span><span class="c2">, </span><span class="c3">0</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(point); &nbsp; </span><span class="c12">// X: 0 &nbsp;Y: 0</span><span class="c2"><br> &nbsp; &nbsp;Point* p = &amp;point;<br> <br> &nbsp; &nbsp;p-&gt;X = </span><span class="c3">30</span><span class="c2">;<br> &nbsp; &nbsp;Console.WriteLine(p-&gt;X); &nbsp; &nbsp;</span><span class="c12">// 30</span><span class="c2"><br> <br> &nbsp; &nbsp;</span><span class="c12">// dereferen&#539;ierea pointerului</span><span class="c2"><br> &nbsp; &nbsp;(*p).Y = </span><span class="c3">180</span><span class="c2">;<br> &nbsp; &nbsp;Console.WriteLine((*p).Y); &nbsp;</span><span class="c12">// 180</span><span class="c2"><br> <br> &nbsp; &nbsp;Console.WriteLine(point); &nbsp; </span><span class="c12">// X: 30 &nbsp;Y: 180</span><span class="c2"><br>}<br></span><span class="c5">struct</span><span class="c2">&nbsp;Point<br>{<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;X { </span><span class="c5">get</span><span class="c2">; </span><span class="c5">set</span><span class="c2">; }<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;Y { </span><span class="c5">get</span><span class="c2">; </span><span class="c5">set</span><span class="c2">; }<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c4">Point</span><span class="c2">(</span><span class="c5">int</span><span class="c2">&nbsp;x, </span><span class="c5">int</span><span class="c2">&nbsp;y)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;X = x; Y = y;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c5">override</span><span class="c2">&nbsp;</span><span class="c5">string</span><span class="c2">&nbsp;</span><span class="c4">ToString</span><span class="c2">() =&gt; </span><span class="c18">$&quot;X: {X} &nbsp;Y: {Y}&quot;</span><span class="c2">;<br>}</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Prin accesarea pointerului p-&gt;X = 30;, putem ob&#539;ine sau seta valoarea unei propriet&#259;&#539;i a structurii la care face referire pointerul. Este important de men&#539;ionat c&#259; nu putem scrie simplu p.X=30, deoarece p nu este structura Point, ci un pointer c&#259;tre aceast&#259; structur&#259;.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">O alternativ&#259; este opera&#539;ia de dereferen&#539;iere: (*p).X = 30;.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Trebuie men&#539;ionat c&#259; un pointer poate face referire doar la acele structuri care nu au c&acirc;mpuri de tip referen&#539;ial (inclusiv c&acirc;mpuri generate automat de compilator pentru propriet&#259;&#539;ile auto-implementate).</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c0">Pointeri c&#259;tre Tablouri &#537;i stackalloc.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Cu ajutorul cuv&acirc;ntului cheie </span><span class="c17">stackalloc</span><span class="c1">, se poate aloca memorie pentru un tablou &icirc;n stiv&#259;. Alocarea memoriei &icirc;n stiv&#259; este util&#259; pentru cre&#537;terea performan&#539;ei codului. S&#259; vedem un exemplu de calcul al p&#259;tratelor numerelor:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.ca1baf7ea85ece59c1aec9231961fc670d604ff9"></a><a id="t.1"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c5">unsafe</span><span class="c2"><br>{<br> &nbsp; &nbsp;</span><span class="c5">const</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;size = </span><span class="c3">7</span><span class="c2">;<br> &nbsp; &nbsp;</span><span class="c5">int</span><span class="c2">* square = </span><span class="c5">stackalloc</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">[size]; </span><span class="c12">// aloc&#259;m memorie &icirc;n stiv&#259; pentru &#537;apte obiecte de tip int</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c5">int</span><span class="c2">* p = square;<br> &nbsp; &nbsp;</span><span class="c12">// calcul&#259;m p&#259;tratele numerelor de la 1 la 7 inclusiv</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c5">for</span><span class="c2">&nbsp;(</span><span class="c5">int</span><span class="c2">&nbsp;i = </span><span class="c3">1</span><span class="c2">; i &lt;= size; i++, p++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c12">// calcul&#259;m p&#259;tratul num&#259;rului</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;*p = i * i;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c5">for</span><span class="c2">&nbsp;(</span><span class="c5">int</span><span class="c2">&nbsp;i = </span><span class="c3">0</span><span class="c2">; i &lt; size; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(square[i]);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Operatorul stackalloc este urmat de un tablou la care va face referire pointerul: int* square = stackalloc int[size];.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Pentru a manipula tabloul, cre&#259;m un pointer</span><span class="c7">&nbsp;p: int* p = square;</span><span class="c1">, care indic&#259; primul element al tabloului ce con&#539;ine &#537;apte elemente. Cu ajutorul pointerului p, putem naviga prin tabloul square.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">&Icirc;n continuare, ciclul calculeaz&#259; p&#259;tratele numerelor de la 1 la 7. &Icirc;n ciclu, pentru a seta valoarea (p&#259;tratul num&#259;rului - i * i) la adresa stocat&#259; de pointer, se execut&#259; expresia:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.d4fc7d0d488f0a20d7418fcfe1c50ec61e4e7f36"></a><a id="t.2"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c2">*p = i * i;</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Apoi are loc incrementarea pointerului p++, &#537;i pointerul p se deplaseaz&#259; la urm&#259;torul element din tabloul square.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Un exemplu mai complex - calculul factorialului:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.a6f846a31e9e250b73ef707cde43c7a94adf72af"></a><a id="t.3"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c5">unsafe</span><span class="c2"><br>{<br> &nbsp; &nbsp;</span><span class="c5">const</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;size = </span><span class="c3">7</span><span class="c2">;<br> &nbsp; &nbsp;</span><span class="c5">int</span><span class="c2">* factorial = </span><span class="c5">stackalloc</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">[size]; </span><span class="c12">// aloc&#259;m memorie &icirc;n stiv&#259; pentru &#537;apte obiecte de tip int</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c5">int</span><span class="c2">* p = factorial;<br> <br> &nbsp; &nbsp;*(p++) = </span><span class="c3">1</span><span class="c2">; </span><span class="c12">// atribuim primei celule valoarea 1 &#537;i</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c12">// increment&#259;m pointerul cu 1</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c5">for</span><span class="c2">&nbsp;(</span><span class="c5">int</span><span class="c2">&nbsp;i = </span><span class="c3">2</span><span class="c2">; i &lt;= size; i++, p++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c12">// calcul&#259;m factorialul num&#259;rului</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;*p = p[</span><span class="c3">-1</span><span class="c2">] * i;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c5">for</span><span class="c2">&nbsp;(</span><span class="c5">int</span><span class="c2">&nbsp;i = </span><span class="c3">0</span><span class="c2">; i &lt; size; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(factorial[i]);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Cu ajutorul operatorului stackalloc se aloc&#259; memorie pentru 7 elemente ale tabloului. De asemenea, pentru manipularea tabloului, cre&#259;m un pointer </span><span class="c7">p: int* p = factorial;</span><span class="c1">, care indic&#259; primul element al tabloului, ce con&#539;ine 7 elemente.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">&Icirc;n continuare, &icirc;ncepem opera&#539;iile cu pointerul &#537;i calculul factorialului. Deoarece factorialul lui 1 este 1, atribuim primului element indicat de pointerul p valoarea 1 prin opera&#539;ia de dereferen&#539;iere:</span><span class="c7 c16">&nbsp;*(p++)= 1;.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Pentru a seta o anumit&#259; valoare la adresa indicat&#259; de pointer, se folose&#537;te expresia: </span><span class="c7">*p=1;</span><span class="c15">. &Icirc;n plus, pointerul este incrementat</span><span class="c7">&nbsp;p++</span><span class="c1">. A&#537;adar, &icirc;nt&acirc;i se atribuie valoarea 1 primului element al tabloului, apoi pointerul p se deplaseaz&#259; &#537;i &icirc;ncepe s&#259; indice c&#259;tre al doilea element. Am putea scrie aceasta astfel:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.bfd93cdcefca0dfffdb0e797baa9df4a4f603b1e"></a><a id="t.4"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c2">*p= </span><span class="c3">1</span><span class="c2">;<br>p++;</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Pentru a ob&#539;ine elementul anterior &#537;i a ne deplasa &icirc;napoi, putem folosi opera&#539;ia de decrementare: </span><span class="c7">Console.WriteLine(*(--p));</span><span class="c15">. Observa&#539;i c&#259; opera&#539;iile </span><span class="c7">*(--p) &#537;i *(p--) </span><span class="c1">sunt diferite, deoarece &icirc;n primul caz mai &icirc;nt&acirc;i se deplaseaz&#259; pointerul &#537;i apoi se dereferen&#539;iaz&#259;, &icirc;n timp ce &icirc;n al doilea caz se &icirc;nt&acirc;mpl&#259; invers.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">&Icirc;n final, calcul&#259;m factorialul celorlalte &#537;ase numere:</span><span class="c7">&nbsp;*p = p[-1] *i;</span><span class="c1">. Accesarea pointerilor ca &#537;i cum ar fi tablouri reprezint&#259; o alternativ&#259; la opera&#539;ia de dereferen&#539;iere pentru a ob&#539;ine valoarea. &Icirc;n acest caz, ob&#539;inem valoarea elementului anterior.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">&Icirc;n final, folosind pointerul factorial, afi&#537;&#259;m factorialele celor &#537;apte numere.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c0">Operatorul fixed &#537;i Fixarea Pointerilor.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Anterior, am v&#259;zut cum s&#259; cre&#259;m pointeri pentru tipuri valoare, cum ar fi int sau structuri. Cu toate acestea, pe l&acirc;ng&#259; structuri, &icirc;n C# exist&#259; &#537;i clase, care, spre deosebire de tipurile valoare, stocheaz&#259; toate valorile asociate &icirc;n heap. &Icirc;n orice moment, colectorul de gunoi poate interveni &icirc;n opera&#539;iunile claselor, cur&#259;&#539;&acirc;nd periodic heap-ul. Pentru a fixa pointerii pe obiecte ale claselor pe toat&#259; durata execu&#539;iei, se folose&#537;te operatorul </span><span class="c17">fixed</span><span class="c1">.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">S&#259; presupunem c&#259; avem clasa Point:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.15487dec9f60dbf43b33aa3ffac9567ce7b5d03f"></a><a id="t.5"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c5">class</span><span class="c2">&nbsp;</span><span class="c4">Point</span><span class="c2"><br>{<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;x;<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;y;<br> &nbsp; &nbsp;</span><span class="c5">public</span><span class="c2">&nbsp;</span><span class="c5">override</span><span class="c2">&nbsp;</span><span class="c5">string</span><span class="c2">&nbsp;</span><span class="c4">ToString</span><span class="c2">() =&gt; </span><span class="c18">$&quot;x: {x} &nbsp;y: {y}&quot;</span><span class="c2">;<br>}</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Fix&#259;m pointerul folosind operatorul fixed:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.74261f51758bab495666e3c330eed6e9c3d3308e"></a><a id="t.6"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c5">unsafe</span><span class="c2"><br>{<br> &nbsp; &nbsp;Point point = </span><span class="c5">new</span><span class="c2">&nbsp;Point();<br> <br> &nbsp; &nbsp;</span><span class="c12">// bloc de fixare a pointerului</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c5">fixed</span><span class="c2">&nbsp;(</span><span class="c5">int</span><span class="c2">* pX = &amp;point.x)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;*pX = </span><span class="c3">30</span><span class="c2">;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c5">fixed</span><span class="c2">&nbsp;(</span><span class="c5">int</span><span class="c2">* pY = &amp;point.y)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;*pY = </span><span class="c3">150</span><span class="c2">;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c12">// putem combina ambele blocuri</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c12">/*fixed (int* pX = &amp;point.x, pY = &amp;point.y)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;*pX = 30;<br> &nbsp; &nbsp; &nbsp; &nbsp;*pY = 150;<br> &nbsp; &nbsp;}*/</span><span class="c2"><br> &nbsp; &nbsp;Console.WriteLine(point); </span><span class="c12">// x: 30 &nbsp;y: 150</span><span class="c2"><br>}</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">Operatorul </span><span class="c7">fixed </span><span class="c1">creeaz&#259; un bloc &icirc;n care pointerul pe c&acirc;mpul obiectului point este fixat. Dup&#259; finalizarea blocului fixed, fixarea variabilelor este anulat&#259; &#537;i acestea pot fi supuse colect&#259;rii de gunoi.</span></p><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c1">Pe l&acirc;ng&#259; adresa variabilei, putem ini&#539;ializa pointerul folosind un tablou, un &#537;ir de caractere sau un buffer de dimensiune fix&#259;:</span></p><p class="c6 c9"><span class="c1"></span></p><a id="t.76d8dcb5ab08daf7e5f4170d426808abc1dfa2a2"></a><a id="t.7"></a><table class="c10"><tr class="c11"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span class="c5">unsafe</span><span class="c2"><br>{<br> &nbsp; &nbsp;</span><span class="c5">int</span><span class="c2">[] nums = { </span><span class="c3">0</span><span class="c2">, </span><span class="c3">1</span><span class="c2">, </span><span class="c3">2</span><span class="c2">, </span><span class="c3">3</span><span class="c2">, </span><span class="c3">7</span><span class="c2">, </span><span class="c3">88</span><span class="c2">&nbsp;};<br> &nbsp; &nbsp;</span><span class="c5">string</span><span class="c2">&nbsp;str = </span><span class="c18">&quot;&#1055;&#1088;&#1080;&#1074;&#1077;&#1090; &#1084;&#1080;&#1088;&quot;</span><span class="c2">;<br> &nbsp; &nbsp;</span><span class="c5">fixed</span><span class="c2">(</span><span class="c5">int</span><span class="c2">* p = nums)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c5">int</span><span class="c2">&nbsp;third = *(p+</span><span class="c3">2</span><span class="c2">); &nbsp; &nbsp; </span><span class="c12">// ob&#539;inem al treilea element</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(third); </span><span class="c12">// 2</span><span class="c2"><br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c5">fixed</span><span class="c2">(</span><span class="c5">char</span><span class="c2">* p = str)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c5">char</span><span class="c2">&nbsp;forth = *(p + </span><span class="c3">3</span><span class="c2">); &nbsp; &nbsp; </span><span class="c12">// ob&#539;inem al patrulea element</span><span class="c2"><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(forth); </span><span class="c12">// &#1074;</span><span class="c2"><br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c6 c9"><span class="c1"></span></p><p class="c6"><span class="c15">La ini&#539;ializarea pointerilor pentru un &#537;ir de caractere, trebuie s&#259; &#539;inem cont c&#259; pointerul trebuie s&#259; fie de tip</span><span class="c7">&nbsp;char*</span><span class="c1">.</span></p><p class="c6 c9"><span class="c1"></span></p></body></html>