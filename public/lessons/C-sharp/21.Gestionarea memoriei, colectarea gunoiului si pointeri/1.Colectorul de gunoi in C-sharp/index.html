<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c15 doc-content"><p class="c3"><span class="c9">Colectorul de gunoi &icirc;n C#.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">Anterior, &icirc;n tema</span><span class="c0">&nbsp;Tipuri de valori &#537;i tipuri de referin&#539;e</span><span class="c5">, am analizat diferite tipuri de date &#537;i modul &icirc;n care acestea sunt plasate &icirc;n memorie. Astfel, c&acirc;nd folosim variabile de tip valoare &icirc;ntr-o metod&#259;, toate valorile acestor variabile sunt stocate &icirc;n stiv&#259;. Dup&#259; finalizarea execu&#539;iei metodei, stiva este cur&#259;&#539;at&#259;.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">&Icirc;n cazul tipurilor de referin&#539;&#259;, cum ar fi obiectele claselor, pentru acestea va fi alocat spa&#539;iu &icirc;n stiv&#259;, dar acolo va fi stocat&#259; doar adresa sec&#539;iunii de memorie din heap sau gr&#259;mad&#259;, unde se afl&#259; efectiv valorile obiectului respectiv. &#536;i dac&#259; un obiect de tip clas&#259; nu mai este utilizat, odat&#259; cu cur&#259;&#539;area stivei, referin&#539;a c&#259;tre sec&#539;iunea de memorie este, de asemenea, cur&#259;&#539;at&#259;, &icirc;ns&#259; acest lucru nu duce la o cur&#259;&#539;are imediat&#259; a sec&#539;iunii de memorie din heap. Ulterior, colectorul de gunoi (garbage collector) va observa c&#259; nu mai exist&#259; referin&#539;e c&#259;tre sec&#539;iunea de memorie respectiv&#259; &#537;i o va cur&#259;&#539;a.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">De exemplu:</span></p><p class="c3 c4"><span class="c5"></span></p><a id="t.86edd950fadd4b353d4e91af5e8487475719f2db"></a><a id="t.0"></a><table class="c20"><tr class="c17"><td class="c11" colspan="1" rowspan="1"><p class="c8"><span class="c2">Test();<br> <br></span><span class="c10">void</span><span class="c2">&nbsp;</span><span class="c13">Test</span><span class="c2">()<br>{<br> &nbsp; &nbsp;Person tom = </span><span class="c10">new</span><span class="c2">&nbsp;Person(</span><span class="c12">&quot;Tom&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(tom.Name);<br>}<br>record class </span><span class="c13">Person</span><span class="c2">(</span><span class="c10">string</span><span class="c2">&nbsp;Name);</span></p></td></tr></table><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">&Icirc;n metoda Test este creat un obiect Person. Cu ajutorul operatorului </span><span class="c0">new</span><span class="c5">, &icirc;n heap este alocat&#259; o sec&#539;iune de memorie pentru a stoca obiectul. Iar &icirc;n stiv&#259; se adaug&#259; adresa acestei sec&#539;iuni de memorie. &Icirc;n metoda Main, definit&#259; implicit, apel&#259;m metoda Test. &#536;i dup&#259; ce metoda Test se &icirc;ncheie, spa&#539;iul din stiv&#259; este cur&#259;&#539;at, iar colectorul de gunoi elibereaz&#259; sec&#539;iunea de memorie alocat&#259; anterior pentru obiectul Person.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">Colectorul de gunoi nu este lansat imediat dup&#259; &#537;tergerea din stiv&#259; a referin&#539;ei c&#259;tre obiectul plasat &icirc;n heap. Este lansat atunci c&acirc;nd mediul CLR detecteaz&#259; necesitatea, de exemplu, c&acirc;nd programul are nevoie de memorie suplimentar&#259;.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">De regul&#259;, obiectele din heap sunt plasate neordonat, &icirc;ntre ele put&acirc;nd exista goluri. Heap-ul este destul de fragmentat. Prin urmare, dup&#259; cur&#259;&#539;area memoriei ca urmare a unei colect&#259;ri de gunoi, obiectele r&#259;mase sunt mutate &icirc;ntr-un bloc de memorie continuu. Odat&#259; cu aceasta, referin&#539;ele sunt actualizate pentru a indica corect noile adrese ale obiectelor.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">De asemenea, trebuie men&#539;ionat c&#259; pentru obiectele mari exist&#259; un heap separat - </span><span class="c0">Large Object Heap</span><span class="c5">. &Icirc;n acest heap sunt plasate obiectele a c&#259;ror dimensiune dep&#259;&#537;e&#537;te 85.000 de bi&#539;i. Particularitatea acestui heap este c&#259; &icirc;n timpul colect&#259;rii de gunoi nu se efectueaz&#259; comprimarea memoriei din cauza costurilor mari asociate dimensiunii obiectelor.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">De&#537;i comprimarea spa&#539;iului ocupat necesit&#259; timp &#537;i aplica&#539;ia nu poate continua s&#259; ruleze p&acirc;n&#259; c&acirc;nd colectorul de gunoi nu &icirc;&#537;i termin&#259; sarcina, acest proces optimizeaz&#259;, de asemenea, aplica&#539;ia. Acum, pentru a g&#259;si spa&#539;iu liber &icirc;n heap, mediul CLR nu trebuie s&#259; caute insule de spa&#539;iu liber &icirc;ntre blocurile ocupate. Este suficient s&#259; se adreseze pointerului heap-ului, care indic&#259; sec&#539;iunea de memorie liber&#259;, ceea ce reduce num&#259;rul de acces&#259;ri ale memoriei.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">&Icirc;n plus, pentru a reduce costurile asociate cu colectorul de gunoi, toate obiectele din heap sunt &icirc;mp&#259;r&#539;ite pe genera&#539;ii. Exist&#259; trei genera&#539;ii de obiecte: 0, 1 &#537;i 2.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">La genera&#539;ia 0 apar&#539;in obiectele noi, care nu au fost &icirc;nc&#259; supuse colect&#259;rii de gunoi. La genera&#539;ia 1 apar&#539;in obiectele care au supravie&#539;uit unei colect&#259;ri, iar la genera&#539;ia 2 - obiectele care au trecut prin mai multe colect&#259;ri de gunoi.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">C&acirc;nd colectorul de gunoi &icirc;ncepe s&#259; lucreze, acesta analizeaz&#259; mai &icirc;nt&acirc;i obiectele din genera&#539;ia 0. Obiectele care r&#259;m&acirc;n relevante dup&#259; cur&#259;&#539;are sunt promovate la genera&#539;ia 1.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">Dac&#259;, dup&#259; procesarea obiectelor din genera&#539;ia 0, este &icirc;nc&#259; necesar&#259; memorie suplimentar&#259;, colectorul de gunoi trece la obiectele din genera&#539;ia 1. Obiectele care nu mai au referin&#539;e sunt distruse, iar cele care r&#259;m&acirc;n relevante sunt promovate la genera&#539;ia 2.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">Deoarece obiectele din genera&#539;ia 0 sunt mai noi &#537;i, adesea, se afl&#259; &icirc;n spa&#539;iul de memorie apropiat unul de altul, eliminarea lor se face cu costuri minime.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c19">Clasa System.GC.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">Func&#539;ionalitatea colectorului de gunoi &icirc;n biblioteca de clase .NET este reprezentat&#259; de clasa</span><span class="c0">&nbsp;System.GC.</span><span class="c5">&nbsp;Prin metodele statice, aceast&#259; clas&#259; permite accesul la colectorul de gunoi. De regul&#259;, nu este necesar&#259; utilizarea acestei clase. Cel mai frecvent caz de utilizare este colectarea de gunoi &icirc;n timpul lucrului cu resurse neadministrate, c&acirc;nd sunt alocate cantit&#259;&#539;i mari de memorie &#537;i este necesar&#259; eliberarea lor rapid&#259;.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">S&#259; analiz&#259;m c&acirc;teva metode &#537;i propriet&#259;&#539;i ale clasei System.GC:</span></p><p class="c3 c4"><span class="c5"></span></p><ul class="c16 lst-kix_wki0n8ndyybs-0 start"><li class="c1 li-bullet-0"><span class="c7">Metoda </span><span class="c0">AddMemoryPressure </span><span class="c7">informeaz&#259; mediul CLR despre alocarea unei cantit&#259;&#539;i mari de memorie neadministrat&#259;, care trebuie luat&#259; &icirc;n considerare la planificarea colect&#259;rii de gunoi. &Icirc;n asociere cu aceast&#259; metod&#259;, se folose&#537;te metoda </span><span class="c0">RemoveMemoryPressure</span><span class="c5">, care indic&#259; CLR c&#259; memoria alocat&#259; anterior a fost eliberat&#259; &#537;i nu mai trebuie luat&#259; &icirc;n considerare la colectarea de gunoi.</span></li></ul><p class="c3 c14 c4"><span class="c5"></span></p><ul class="c16 lst-kix_wki0n8ndyybs-0"><li class="c1 li-bullet-0"><span class="c7">Metoda </span><span class="c0">Collect </span><span class="c5">declan&#537;eaz&#259; mecanismul de colectare a gunoiului. Versiunile supra&icirc;nc&#259;rcate ale metodei permit specificarea genera&#539;iei de obiecte p&acirc;n&#259; la care trebuie efectuat&#259; colectarea de gunoi.</span></li></ul><p class="c3 c14 c4"><span class="c5"></span></p><ul class="c16 lst-kix_wki0n8ndyybs-0"><li class="c1 li-bullet-0"><span class="c7">Metoda </span><span class="c0">GetGeneration(Object)</span><span class="c5">&nbsp;permite determinarea genera&#539;iei la care apar&#539;ine obiectul transmis ca parametru.</span></li></ul><p class="c3 c14 c4"><span class="c5"></span></p><ul class="c16 lst-kix_wki0n8ndyybs-0"><li class="c1 li-bullet-0"><span class="c7">Metoda </span><span class="c0">GetTotalMemory </span><span class="c5">returneaz&#259; cantitatea de memorie &icirc;n bi&#539;i care este ocupat&#259; &icirc;n heap-ul administrat.</span></li></ul><p class="c3 c4 c14"><span class="c5"></span></p><ul class="c16 lst-kix_wki0n8ndyybs-0"><li class="c1 li-bullet-0"><span class="c7">Metoda </span><span class="c0">WaitForPendingFinalizers </span><span class="c5">suspend&#259; activitatea thread-ului curent p&acirc;n&#259; c&acirc;nd toate obiectele pentru care se efectueaz&#259; colectarea de gunoi sunt eliberate.</span></li></ul><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c5">Lucrul cu metodele System.GC este simplu:</span></p><p class="c3 c4"><span class="c5"></span></p><a id="t.748513099146d640439eacbca80ba914b4b347d4"></a><a id="t.1"></a><table class="c20"><tr class="c17"><td class="c11" colspan="1" rowspan="1"><p class="c8"><span class="c18">// .................................</span><span class="c2"><br></span><span class="c10">long</span><span class="c2">&nbsp;totalMemory = GC.GetTotalMemory(</span><span class="c10">false</span><span class="c2">);<br> <br>GC.Collect();<br>GC.WaitForPendingFinalizers();<br></span><span class="c18">//......................................</span></p></td></tr></table><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">Cu ajutorul versiunilor supra&icirc;nc&#259;rcate ale metodei </span><span class="c6">GC.Collect</span><span class="c7">, se poate efectua o configurare mai precis&#259; a colect&#259;rii de gunoi. De exemplu, versiunea supra&icirc;nc&#259;rcat&#259; a acestei metode prime&#537;te ca parametru un num&#259;r - genera&#539;ia p&acirc;n&#259; la care trebuie efectuat&#259; cur&#259;&#539;area. De exemplu,</span><span class="c6">&nbsp;GC.Collect(0)</span><span class="c5">&nbsp;- vor fi eliminate doar obiectele din genera&#539;ia 0.</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">O alt&#259; versiune supra&icirc;nc&#259;rcat&#259; prime&#537;te &#537;i un al doilea parametru - o enumerare </span><span class="c0">GCCollectionMode</span><span class="c5">. Aceast&#259; enumerare poate avea trei valori:</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">- </span><span class="c0">Default</span><span class="c5">: valoare implicit&#259; pentru aceast&#259; enumerare (Forced)</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">- </span><span class="c0">Forced</span><span class="c5">: declan&#537;eaz&#259; imediat execu&#539;ia colect&#259;rii de gunoi</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">- </span><span class="c0">Optimized</span><span class="c5">: permite colectorului de gunoi s&#259; determine dac&#259; momentul curent este optim pentru colectarea de gunoi</span></p><p class="c3 c4"><span class="c5"></span></p><p class="c3"><span class="c7">De exemplu, colectarea imediat&#259; a gunoiului p&acirc;n&#259; la prima genera&#539;ie de obiecte: </span><span class="c6">GC.Collect(1, GCCollectionMode.Forced)</span><span class="c5">;.</span></p><p class="c3 c4"><span class="c5"></span></p></body></html>