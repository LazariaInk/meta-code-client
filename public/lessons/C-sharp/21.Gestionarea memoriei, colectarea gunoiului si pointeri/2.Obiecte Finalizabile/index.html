<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c17 doc-content"><p class="c1"><span class="c9">Obiecte Finalizabile.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Majoritatea obiectelor utilizate &icirc;n programele C# sunt parte a codului gestionat (managed code). Aceste obiecte sunt gestionate de CLR &#537;i sunt u&#537;or cur&#259;&#539;ate de colectorul de gunoi. Cu toate acestea, exist&#259; &#537;i obiecte care utilizeaz&#259; resurse neadministrate (cum ar fi conexiunile la fi&#537;iere, baze de date, conexiuni de re&#539;ea etc.). Aceste obiecte neadministrate apeleaz&#259; la API-ul sistemului de operare. Colectorul de gunoi poate gestiona obiectele administrate, dar nu &#537;tie cum s&#259; elimine obiectele neadministrate. &Icirc;n acest caz, dezvoltatorul trebuie s&#259; implementeze manual mecanismele de cur&#259;&#539;are la nivelul codului programului.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Eliberarea resurselor neadministrate implic&#259; implementarea unuia dintre cele dou&#259; mecanisme:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">- Crearea unui destructor</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">- Implementarea de c&#259;tre clas&#259; a interfe&#539;ei System.IDisposable</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">Crearea Destructorilor.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Dac&#259; a&#539;i programat &icirc;n C++, probabil c&#259; sunte&#539;i deja familiarizat cu conceptul de destructori. Metoda destructor poart&#259; numele clasei (la fel ca &#537;i constructorul), dar este precedat&#259; de simbolul tilde (~).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Destructorii pot fi defini&#539;i doar &icirc;n clase. Destructorul, spre deosebire de constructor, nu poate avea modificatori de acces &#537;i parametri. De asemenea, fiecare clas&#259; poate avea un singur destructor.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">De exemplu, s&#259; definim un destructor simplu &icirc;n clasa Person:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.0b25b59fe0f59aff2838ca8869a58352ae2d7610"></a><a id="t.0"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c2">class</span><span class="c3">&nbsp;</span><span class="c14">Person</span><span class="c3"><br>{<br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">string</span><span class="c3">&nbsp;Name { </span><span class="c2">get</span><span class="c3">;}<br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c14">Person</span><span class="c3">(</span><span class="c2">string</span><span class="c3">&nbsp;name) =&gt; Name = name;<br> <br> &nbsp; &nbsp;~Person()<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;{Name} has deleted&quot;</span><span class="c3">);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&Icirc;n acest caz, destructorul doar afi&#537;eaz&#259; un mesaj &icirc;n consol&#259; pentru a informa c&#259; obiectul a fost &#537;ters. Dar &icirc;n programele reale, destructorul con&#539;ine logica de eliberare a resurselor neadministrate.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c10">Cu toate acestea, &icirc;n practic&#259;, colectorul de gunoi nu apeleaz&#259; destructorul direct, ci metoda </span><span class="c15">Finalize</span><span class="c0">. Acest lucru se datoreaz&#259; faptului c&#259; compilatorul C# compileaz&#259; destructorul &icirc;ntr-o construc&#539;ie echivalent&#259; cu urm&#259;toarea:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.06bc26ebf4208f9f6ad68c6d30d4463e990f20c3"></a><a id="t.1"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c2">protected</span><span class="c3">&nbsp;</span><span class="c2">override</span><span class="c3">&nbsp;</span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Finalize</span><span class="c3">()<br>{<br> &nbsp; &nbsp;</span><span class="c2">try</span><span class="c3"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// aici sunt instruc&#539;iunile destructorului</span><span class="c3"><br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c2">finally</span><span class="c3"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">base</span><span class="c3">.Finalize();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Metoda Finalize este deja definit&#259; &icirc;n clasa de baz&#259; Object, care este comun&#259; pentru toate tipurile de clase, dar aceast&#259; metod&#259; nu poate fi suprascris&#259; direct. Implementarea sa real&#259; se face prin crearea unui destructor.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Folosind clasa Person &icirc;n program, dup&#259; terminarea acestuia, se poate vedea &icirc;n consol&#259; un mesaj care anun&#539;&#259; &#537;tergerea obiectului tom:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.90242e9d021b066214a4557fdd2fc45ddb8ec80b"></a><a id="t.2"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c3">Test(); &nbsp; &nbsp; &nbsp; &nbsp;<br>GC.Collect(); &nbsp; </span><span class="c6">// cur&#259;&#539;area memoriei ocupate de obiectul tom</span><span class="c3"><br>Console.Read(); </span><span class="c6">// a&#537;teptare la final</span><span class="c3"><br><br></span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Test</span><span class="c3">()<br>{<br> &nbsp; &nbsp;Person tom = </span><span class="c2">new</span><span class="c3">&nbsp;Person(</span><span class="c16">&quot;Tom&quot;</span><span class="c3">);<br>}<br> <br></span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">class</span><span class="c3">&nbsp;</span><span class="c14">Person</span><span class="c3"><br>{<br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">string</span><span class="c3">&nbsp;Name { </span><span class="c2">get</span><span class="c3">;}<br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c14">Person</span><span class="c3">(</span><span class="c2">string</span><span class="c3">&nbsp;name) =&gt; Name = name;<br> <br> &nbsp; &nbsp;~Person()<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;{Name} has been deleted&quot;</span><span class="c3">);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c10">Este important de men&#539;ionat c&#259;, chiar &#537;i dup&#259; terminarea metodei Test &#537;i eliminarea referin&#539;ei din stiv&#259; la obiectul Person din heap, destructorul poate s&#259; nu fie apelat imediat. Doar la finalul &icirc;ntregului program, memoria este garantat cur&#259;&#539;at&#259;. Cu toate acestea, &icirc;n .NET 5 &#537;i versiunile ulterioare, destructorii nu sunt apela&#539;i la terminarea programului. De aceea, &icirc;n programul de mai sus, pentru o cur&#259;&#539;are mai rapid&#259; a memoriei, se utilizeaz&#259; metoda GC.Collect &#537;i, pentru a garanta apelarea destructorului, se introduce o pauz&#259; cu ajutorul </span><span class="c8">Console.Read()</span><span class="c0">, care a&#537;teapt&#259; un input de la utilizator.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c10">La nivel de memorie, acest proces func&#539;ioneaz&#259; astfel: colectorul de gunoi, atunci c&acirc;nd plaseaz&#259; un obiect &icirc;n heap, determin&#259; dac&#259; obiectul respectiv implementeaz&#259; metoda </span><span class="c8">Finalize</span><span class="c0">. Dac&#259; obiectul are metoda Finalize, un pointer c&#259;tre acesta este salvat &icirc;ntr-o tabel&#259; special&#259;, numit&#259; coada de finalizare. C&acirc;nd vine momentul colect&#259;rii gunoiului, colectorul vede c&#259; obiectul trebuie distrus &#537;i, dac&#259; are metoda Finalize, acesta este copiat &icirc;ntr-o alt&#259; tabel&#259; &#537;i este distrus complet abia la urm&#259;toarea trecere a colectorului de gunoi.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Trebuie men&#539;ionat c&#259; momentul exact al apel&#259;rii destructorului nu este definit. &Icirc;n plus, &icirc;n cazul finaliz&#259;rii a dou&#259; obiecte asociate, ordinea apel&#259;rii destructorilor nu este garantat&#259;. De exemplu, dac&#259; obiectul A de&#539;ine o referin&#539;&#259; la obiectul B &#537;i ambele obiecte au destructori, este posibil ca destructorul pentru obiectul B s&#259; fie apelat &icirc;nainte ca destructorul pentru obiectul A s&#259; &icirc;nceap&#259; s&#259; func&#539;ioneze.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Aici ne putem confrunta cu urm&#259;toarea problem&#259;: ce facem dac&#259; trebuie s&#259; apel&#259;m imediat destructorul &#537;i s&#259; eliber&#259;m toate resursele neadministrate asociate cu obiectul? &Icirc;n acest caz, putem folosi l doua abordare - implementarea interfe&#539;ei IDisposable.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">Interfa&#539;a IDisposable.</span></p><p class="c1 c4"><span class="c11"></span></p><p class="c1"><span class="c10">Interfa&#539;a IDisposable declar&#259; o singur&#259; metod&#259;, </span><span class="c15">Dispose</span><span class="c0">, &icirc;n care, la implementarea interfe&#539;ei &icirc;ntr-o clas&#259;, trebuie s&#259; se fac&#259; eliberarea resurselor neadministrate. De exemplu:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.46c3a82ea9f780c7e7c17fac5105658729ed64d8"></a><a id="t.3"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c3">Test();<br> <br></span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Test</span><span class="c3">()<br>{<br> &nbsp; &nbsp;Person? tom = </span><span class="c2">null</span><span class="c3">;<br> &nbsp; &nbsp;</span><span class="c2">try</span><span class="c3"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;tom = </span><span class="c2">new</span><span class="c3">&nbsp;Person(</span><span class="c16">&quot;Tom&quot;</span><span class="c3">);<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c2">finally</span><span class="c3"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;tom?.Dispose();<br> &nbsp; &nbsp;}<br>}<br> <br></span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">class</span><span class="c3">&nbsp;</span><span class="c14">Person</span><span class="c3">&nbsp;: </span><span class="c14">IDisposable</span><span class="c3"><br>{<br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">string</span><span class="c3">&nbsp;Name { </span><span class="c2">get</span><span class="c3">;}<br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c14">Person</span><span class="c3">(</span><span class="c2">string</span><span class="c3">&nbsp;name) =&gt; Name = name;<br> <br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Dispose</span><span class="c3">()<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;{Name} has been disposed&quot;</span><span class="c3">);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&Icirc;n acest cod, se folose&#537;te construc&#539;ia try...finally. &Icirc;n esen&#539;&#259;, aceast&#259; construc&#539;ie este echivalent&#259; cu urm&#259;toarele dou&#259; linii de cod:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.bebdcb81ddc6a1c75dd7530825b2329bf4232b18"></a><a id="t.4"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c3">Person tom = </span><span class="c2">new</span><span class="c3">&nbsp;Person(</span><span class="c16">&quot;Tom&quot;</span><span class="c3">);<br>tom.Dispose();</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&Icirc;ns&#259;, construc&#539;ia try...finally este preferabil&#259; atunci c&acirc;nd apel&#259;m metoda Dispose, deoarece garanteaz&#259; c&#259;, chiar &#537;i &icirc;n cazul unei excep&#539;ii, resursele vor fi eliberate &icirc;n metoda Dispose.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">Combinarea abord&#259;rilor.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Am analizat dou&#259; abord&#259;ri. Care dintre ele este mai bun&#259;? Pe de o parte, metoda Dispose permite eliberarea resurselor asociate &icirc;n orice moment, iar pe de alt&#259; parte, programatorul care folose&#537;te clasa noastr&#259; poate uita s&#259; apeleze metoda Dispose. &Icirc;n general, pot ap&#259;rea situa&#539;ii variate. &#536;i pentru a combina avantajele ambelor abord&#259;ri, putem folosi o abordare combinat&#259;. Microsoft ne ofer&#259; urm&#259;torul &#537;ablon formalizat:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.0367bab86c7a4aeced31084e78531ac1a7d6cc6f"></a><a id="t.5"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">class</span><span class="c3">&nbsp;</span><span class="c14">SomeClass</span><span class="c3">: </span><span class="c14">IDisposable</span><span class="c3"><br>{<br> &nbsp; &nbsp;</span><span class="c2">private</span><span class="c3">&nbsp;</span><span class="c2">bool</span><span class="c3">&nbsp;disposed = </span><span class="c2">false</span><span class="c3">;<br> <br> &nbsp; &nbsp;</span><span class="c6">// Implementarea interfe&#539;ei IDisposable</span><span class="c3"><br> &nbsp; &nbsp;</span><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Dispose</span><span class="c3">()<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// Eliber&#259;m resursele neadministrate</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;Dispose(</span><span class="c2">true</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// Suprim&#259;m finalizarea</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;GC.SuppressFinalize(</span><span class="c2">this</span><span class="c3">);<br> &nbsp; &nbsp;}<br> <br> &nbsp; &nbsp;</span><span class="c2">protected</span><span class="c3">&nbsp;</span><span class="c2">virtual</span><span class="c3">&nbsp;</span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Dispose</span><span class="c3">(</span><span class="c2">bool</span><span class="c3">&nbsp;disposing)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">if</span><span class="c3">&nbsp;(disposed) </span><span class="c2">return</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">if</span><span class="c3">&nbsp;(disposing)<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// Eliber&#259;m resursele administrate</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// Eliber&#259;m obiectele neadministrate</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;disposed = </span><span class="c2">true</span><span class="c3">;<br> &nbsp; &nbsp;}<br> <br> &nbsp; &nbsp;</span><span class="c6">// Destructor</span><span class="c3"><br> &nbsp; &nbsp;~SomeClass()<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Dispose (</span><span class="c2">false</span><span class="c3">);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c10">Logica de cur&#259;&#539;are este implementat&#259; prin versiunea suprascris&#259; a metodei </span><span class="c8">Dispose(bool disposing)</span><span class="c0">. Dac&#259; parametrul disposing are valoarea true, atunci metoda este apelat&#259; din metoda public&#259; Dispose, dac&#259; are valoarea false, este apelat&#259; din destructor.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">C&acirc;nd se apeleaz&#259; destructorul, parametrului disposing i se transmite valoarea false, pentru a evita cur&#259;&#539;area resurselor administrate, deoarece nu putem fi siguri c&#259; acestea mai sunt &icirc;nc&#259; &icirc;n memorie. &Icirc;n acest caz, r&#259;m&acirc;ne s&#259; ne baz&#259;m pe destructoarele acestor resurse. &Icirc;n ambele cazuri, resursele neadministrate sunt eliberate.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c10">Un alt aspect important este apelarea metodei </span><span class="c8">GC.SuppressFinalize(this)</span><span class="c0">&nbsp;&icirc;n metoda Dispose. Aceasta &icirc;mpiedic&#259; sistemul s&#259; execute metoda Finalize pentru obiectul respectiv. Dac&#259; clasa nu are definit un destructor, apelarea acestei metode nu va avea niciun efect.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Astfel, chiar dac&#259; dezvoltatorul nu folose&#537;te metoda Dispose &icirc;n program, resursele vor fi totu&#537;i eliberate.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">Recomand&#259;ri generale pentru utilizarea Finalize &#537;i Dispose.</span></p><p class="c1 c4"><span class="c11"></span></p><p class="c1"><span class="c0">- Destructorul ar trebui implementat doar la obiectele care chiar au nevoie de el, deoarece metoda Finalize are un impact semnificativ asupra performan&#539;ei.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">- Dup&#259; apelarea metodei Dispose, trebuie s&#259; se blocheze apelul metodei Finalize cu ajutorul GC.SuppressFinalize.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">- La crearea claselor derivate din clase de baz&#259; care implementeaz&#259; interfa&#539;a IDisposable, trebuie s&#259; se apeleze &#537;i metoda Dispose a clasei de baz&#259;:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.0539a8d78e6c3da25e277d06a9eed551b6241ac7"></a><a id="t.6"></a><table class="c12"><tr class="c13"></tr></table><p class="c5 c4"><span class="c0"></span></p><a id="t.882d42817ce4f6ec9970e26327b3420753ba654b"></a><a id="t.7"></a><table class="c12"><tr class="c13"><td class="c7" colspan="1" rowspan="1"><p class="c5"><span class="c2">public</span><span class="c3">&nbsp;</span><span class="c2">class</span><span class="c3">&nbsp;</span><span class="c14">Derived</span><span class="c3">: </span><span class="c14">Base</span><span class="c3"><br>{<br> &nbsp; &nbsp;</span><span class="c2">private</span><span class="c3">&nbsp;</span><span class="c2">bool</span><span class="c3">&nbsp;IsDisposed = </span><span class="c2">false</span><span class="c3">;<br> <br> &nbsp; &nbsp;</span><span class="c2">protected</span><span class="c3">&nbsp;</span><span class="c2">override</span><span class="c3">&nbsp;</span><span class="c2">void</span><span class="c3">&nbsp;</span><span class="c14">Dispose</span><span class="c3">(</span><span class="c2">bool</span><span class="c3">&nbsp;disposing)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">if</span><span class="c3">&nbsp;(IsDisposed) </span><span class="c2">return</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">if</span><span class="c3">&nbsp;(disposing)<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// Eliberarea resurselor administrate</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;IsDisposed = </span><span class="c2">true</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">// Apelarea metodei Dispose a clasei de baz&#259;</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">base</span><span class="c3">.Dispose(disposing);<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">- Acorda&#539;i preferin&#539;&#259; &#537;ablonului combinat, care implementeaz&#259; at&acirc;t metoda Dispose, c&acirc;t &#537;i destructorul.</span></p><p class="c1 c4"><span class="c0"></span></p></body></html>