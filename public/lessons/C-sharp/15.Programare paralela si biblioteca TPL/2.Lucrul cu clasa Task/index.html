<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ol{margin:0;padding:0}table td,table th{padding:0}.c1{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left;height:11pt}.c16{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Open Sans";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c12{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c17{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c0{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c8{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#a2fca2;font-weight:400}.c13{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c10{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c9{border-spacing:0;border-collapse:collapse;margin-right:auto}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c7{font-size:12pt;font-family:"Open Sans";font-style:italic;font-weight:400}.c15{font-size:12pt;font-family:"Open Sans";font-weight:400}.c2{font-size:12pt;font-family:"Open Sans";font-weight:700}.c18{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c5{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18 doc-content"><p class="c11"><span class="c4">Lucrul cu clasa Task.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c16">Sarcini imbricate.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">O sarcin&#259; poate lansa o alt&#259; sarcin&#259; imbricat&#259;. Aceste sarcini se execut&#259; independent una de cealalt&#259;. De exemplu:</span></p><p class="c3"><span class="c6"></span></p><a id="t.3536d922c6db74f83376579f4b8c532ecedf4953"></a><a id="t.0"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c12">var</span><span class="c0">&nbsp;outer = Task.Factory.StartNew(() =&gt; &nbsp; &nbsp; &nbsp;</span><span class="c10">// sarcin&#259; exterioar&#259;</span><span class="c0"><br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">&quot;Outer task starting...&quot;</span><span class="c0">);<br> &nbsp; &nbsp;</span><span class="c12">var</span><span class="c0">&nbsp;inner = Task.Factory.StartNew(() =&gt; &nbsp;</span><span class="c10">// sarcin&#259; imbricat&#259;</span><span class="c0"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">&quot;Inner task starting...&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c13">2000</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">&quot;Inner task finished.&quot;</span><span class="c0">);<br> &nbsp; &nbsp;});<br>});<br>outer.Wait(); </span><span class="c10">// a&#537;tept&#259;m finalizarea sarcinii exterioare</span><span class="c0"><br>Console.WriteLine(</span><span class="c8">&quot;End of Main&quot;</span><span class="c0">);</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">De&#537;i aici a&#537;tept&#259;m finalizarea sarcinii exterioare, sarcina imbricat&#259; poate finaliza execu&#539;ia chiar &#537;i dup&#259; &icirc;ncheierea metodei Main:</span></p><p class="c3"><span class="c6"></span></p><a id="t.259068a5d1f0dc0352f283249bcb9c51a6ae7a14"></a><a id="t.1"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Outer task starting...<br>End of Main</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Sarcina intern&#259; poate chiar s&#259; nu &icirc;nceap&#259; execu&#539;ia p&acirc;n&#259; la terminarea thread-ului principal al programului. &Icirc;n acest caz, sarcinile exterioare &#537;i imbricate se execut&#259; independent una de cealalt&#259;.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">Dac&#259; este necesar ca sarcina imbricat&#259; s&#259; se execute ca parte a sarcinii exterioare, trebuie utilizat&#259; valoarea </span><span class="c2">TaskCreationOptions.AttachedToParent</span><span class="c6">:</span></p><p class="c3"><span class="c6"></span></p><a id="t.73df7ff479a4ce5eb3becde225b1c05698d84ec6"></a><a id="t.2"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c12">var</span><span class="c0">&nbsp;outer = Task.Factory.StartNew(() =&gt; &nbsp; &nbsp; &nbsp;</span><span class="c10">// sarcin&#259; exterioar&#259;</span><span class="c0"><br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">&quot;Outer task starting...&quot;</span><span class="c0">);<br> &nbsp; &nbsp;</span><span class="c12">var</span><span class="c0">&nbsp;inner = Task.Factory.StartNew(() =&gt; &nbsp;</span><span class="c10">// sarcin&#259; imbricat&#259;</span><span class="c0"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">&quot;Inner task starting...&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c13">2000</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">&quot;Inner task finished.&quot;</span><span class="c0">);<br> &nbsp; &nbsp;}, TaskCreationOptions.AttachedToParent);<br>});<br>outer.Wait(); </span><span class="c10">// a&#537;tept&#259;m finalizarea sarcinii exterioare</span><span class="c0"><br>Console.WriteLine(</span><span class="c8">&quot;End of Main&quot;</span><span class="c0">);</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Ie&#537;ire pe consol&#259;:</span></p><p class="c3"><span class="c6"></span></p><a id="t.e8f8d1e7dc7d4ffdd790999a4d74ac66fbc3991a"></a><a id="t.3"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Outer task starting...<br>Inner task starting...<br>Inner task finished.<br>End of Main</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">&Icirc;n acest caz, sarcina imbricat&#259; este ata&#537;at&#259; sarcinii exterioare &#537;i se execut&#259; ca parte a acesteia. Sarcina exterioar&#259; se va &icirc;ncheia doar atunci c&acirc;nd toate sarcinile imbricate ata&#537;ate se vor &icirc;ncheia.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c16">Array de sarcini.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">La fel ca &#537;i &icirc;n cazul thread-urilor, putem crea &#537;i lansa un array de sarcini. Putem defini toate sarcinile &icirc;ntr-un array direct prin intermediul obiectului Task:</span></p><p class="c3"><span class="c6"></span></p><a id="t.ec6aebbe403b99c10133019c3158e20d9ce65ee6"></a><a id="t.4"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Task[] tasks1 = </span><span class="c12">new</span><span class="c0">&nbsp;Task[</span><span class="c13">3</span><span class="c0">]<br>{<br> &nbsp; &nbsp;</span><span class="c12">new</span><span class="c0">&nbsp;Task(() =&gt; Console.WriteLine(</span><span class="c8">&quot;First Task&quot;</span><span class="c0">)),<br> &nbsp; &nbsp;</span><span class="c12">new</span><span class="c0">&nbsp;Task(() =&gt; Console.WriteLine(</span><span class="c8">&quot;Second Task&quot;</span><span class="c0">)),<br> &nbsp; &nbsp;</span><span class="c12">new</span><span class="c0">&nbsp;Task(() =&gt; Console.WriteLine(</span><span class="c8">&quot;Third Task&quot;</span><span class="c0">))<br>};<br><br></span><span class="c10">// lans&#259;m sarcinile din array</span><span class="c0"><br></span><span class="c12">foreach</span><span class="c0">&nbsp;(</span><span class="c12">var</span><span class="c0">&nbsp;t </span><span class="c12">in</span><span class="c0">&nbsp;tasks1)<br> &nbsp; &nbsp;t.Start();</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">Sau putem folosi metodele</span><span class="c7">&nbsp;Task.Factory.StartNew </span><span class="c15">sau</span><span class="c7">&nbsp;Task.Run</span><span class="c6">&nbsp;pentru a lansa imediat toate sarcinile:</span></p><p class="c3"><span class="c6"></span></p><a id="t.a81bc4a29f49aa7d70d41f514b16c2c4f1af000d"></a><a id="t.5"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Task[] tasks2 = </span><span class="c12">new</span><span class="c0">&nbsp;Task[</span><span class="c13">3</span><span class="c0">];<br></span><span class="c12">int</span><span class="c0">&nbsp;j = </span><span class="c13">1</span><span class="c0">;<br></span><span class="c12">for</span><span class="c0">&nbsp;(</span><span class="c12">int</span><span class="c0">&nbsp;i = </span><span class="c13">0</span><span class="c0">; i &lt; tasks2.Length; i++)<br> &nbsp; &nbsp;tasks2[i] = Task.Factory.StartNew(() =&gt; Console.WriteLine(</span><span class="c8">$&quot;Task {j++}&quot;</span><span class="c0">));</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">&Icirc;n ambele cazuri, putem &icirc;nt&acirc;lni situa&#539;ia &icirc;n care toate sarcinile din array se pot finaliza dup&#259; ce metoda Main, care lanseaz&#259; aceste sarcini, &icirc;&#537;i termin&#259; execu&#539;ia:</span></p><p class="c3"><span class="c6"></span></p><a id="t.e35a759fa753f83850788ee7be91112b6cfb35a0"></a><a id="t.6"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Task[] tasks = </span><span class="c12">new</span><span class="c0">&nbsp;Task[</span><span class="c13">3</span><span class="c0">];<br></span><span class="c12">for</span><span class="c0">(</span><span class="c12">var</span><span class="c0">&nbsp;i = </span><span class="c13">0</span><span class="c0">; i &lt; tasks.Length; i++)<br>{<br> &nbsp; &nbsp;tasks[i] = </span><span class="c12">new</span><span class="c0">&nbsp;Task(() =&gt;<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c13">1000</span><span class="c0">); </span><span class="c10">// emulare de lucru &icirc;ndelungat</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">$&quot;Task{i} finished&quot;</span><span class="c0">);<br> &nbsp; &nbsp;});<br> &nbsp; &nbsp;tasks[i].Start(); &nbsp; </span><span class="c10">// lans&#259;m sarcina</span><span class="c0"><br>}<br>Console.WriteLine(</span><span class="c8">&quot;Finalizarea metodei Main&quot;</span><span class="c0">);</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Posibil&#259; ie&#537;ire pe consol&#259;:</span></p><p class="c3"><span class="c6"></span></p><a id="t.d2a380a0857ee17cfda3ecc0f85c29f2785dafc6"></a><a id="t.7"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Finalizarea metodei Main</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">Dac&#259; este necesar ca programul s&#259; finalizeze execu&#539;ia sau s&#259; execute un anumit cod doar dup&#259; ce toate sarcinile din array se finalizeaz&#259;, putem folosi metoda </span><span class="c2">Task.WaitAll(tasks)</span><span class="c6">:</span></p><p class="c3"><span class="c6"></span></p><a id="t.27ba0311f07564b7506d3155cb3af5188b84dc4c"></a><a id="t.8"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Task[] tasks = </span><span class="c12">new</span><span class="c0">&nbsp;Task[</span><span class="c13">3</span><span class="c0">];<br></span><span class="c12">for</span><span class="c0">(</span><span class="c12">var</span><span class="c0">&nbsp;i = </span><span class="c13">0</span><span class="c0">; i &lt; tasks.Length; i++)<br>{<br> &nbsp; &nbsp;tasks[i] = </span><span class="c12">new</span><span class="c0">&nbsp;Task(() =&gt;<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c13">1000</span><span class="c0">); </span><span class="c10">// emulare de lucru &icirc;ndelungat</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c8">$&quot;Task{i} finished&quot;</span><span class="c0">);<br> &nbsp; &nbsp;});<br> &nbsp; &nbsp;tasks[i].Start(); &nbsp; </span><span class="c10">// lans&#259;m sarcina</span><span class="c0"><br>}<br>Console.WriteLine(</span><span class="c8">&quot;Finalizarea metodei Main&quot;</span><span class="c0">);<br><br>Task.WaitAll(tasks); </span><span class="c10">// a&#537;tept&#259;m finalizarea tuturor sarcinilor</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">&Icirc;n acest caz, mai &icirc;nt&acirc;i se vor finaliza toate sarcinile, &#537;i abia dup&#259; aceea se va executa codul ulterior din metoda Main:</span></p><p class="c3"><span class="c6"></span></p><a id="t.180feeebd41d595e629db4a5c0586c759b3dbcaa"></a><a id="t.9"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Finalizarea metodei Main<br>Task0 finished<br>Task1 finished<br>Task2 finished</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Totu&#537;i, ordinea de execu&#539;ie a sarcinilor din array nu este determinist&#259;.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">De asemenea, putem folosi metoda </span><span class="c2">Task.WaitAny(tasks)</span><span class="c6">. Aceasta a&#537;teapt&#259; finalizarea oric&#259;rei sarcini din array.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c16">Returnarea rezultatelor din sarcini.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Sarcinile nu doar se execut&#259; ca proceduri, ci pot returna &#537;i anumite rezultate:</span></p><p class="c3"><span class="c6"></span></p><a id="t.d6c1e9d90f6d2083db6206894eaa1a05d2740fa1"></a><a id="t.10"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c12">int</span><span class="c0">&nbsp;n1 = </span><span class="c13">4</span><span class="c0">, n2 = </span><span class="c13">5</span><span class="c0">;<br>Task&lt;</span><span class="c12">int</span><span class="c0">&gt; sumTask = </span><span class="c12">new</span><span class="c0">&nbsp;Task&lt;</span><span class="c12">int</span><span class="c0">&gt;(() =&gt; Sum(n1, n2));<br>sumTask.Start();<br><br></span><span class="c12">int</span><span class="c0">&nbsp;result = sumTask.Result;<br>Console.WriteLine(</span><span class="c8">$&quot;{n1} + {n2} = {result}&quot;</span><span class="c0">); </span><span class="c10">// 4 + 5 = 9</span><span class="c0"><br><br></span><span class="c12">int</span><span class="c0">&nbsp;</span><span class="c17">Sum</span><span class="c0">(</span><span class="c12">int</span><span class="c0">&nbsp;a, </span><span class="c12">int</span><span class="c0">&nbsp;b) =&gt; a + b;</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">&Icirc;n primul r&acirc;nd, pentru a ob&#539;ine un rezultat dintr-o sarcin&#259;, trebuie s&#259; tipiz&#259;m obiectul Task cu tipul obiectului pe care dorim s&#259;-l ob&#539;inem din sarcin&#259;. De exemplu, &icirc;n exemplul de mai sus, a&#537;tept&#259;m s&#259; ob&#539;inem un num&#259;r de tip int din sarcina sumTask, astfel c&#259; tipiz&#259;m obiectul Task cu acest tip - </span><span class="c7">Task&lt;int&gt;</span><span class="c6">.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">&Icirc;n al doilea r&acirc;nd, sarcina trebuie s&#259; execute o metod&#259; care returneaz&#259; acest tip de obiect. &Icirc;n acest caz, sarcina execut&#259; metoda </span><span class="c7">Sum</span><span class="c6">, care prime&#537;te dou&#259; numere &#537;i returneaz&#259; suma lor - o valoare de tip int.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c15">Rezultatul returnat va fi stocat &icirc;n proprietatea Result: </span><span class="c7">sumTask.Result</span><span class="c6">. Nu trebuie s&#259;-l convertim la tipul int, deoarece va reprezenta deja un num&#259;r.</span></p><p class="c3"><span class="c6"></span></p><a id="t.67b4b583f01b5dceb74400144446f8e5669c9bf2"></a><a id="t.11"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c12">int</span><span class="c0">&nbsp;result = sumTask.Result;</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Atunci c&acirc;nd acces&#259;m proprietatea Result, thread-ul curent &icirc;&#537;i opre&#537;te execu&#539;ia &#537;i a&#537;teapt&#259; ob&#539;inerea rezultatului din sarcina executat&#259;.</span></p><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">Un alt exemplu:</span></p><p class="c3"><span class="c6"></span></p><a id="t.28a898f870638ca16e0f55b35a1743bc8bfb8ce4"></a><a id="t.12"></a><table class="c9"><tr class="c5"><td class="c1" colspan="1" rowspan="1"><p class="c14"><span class="c0">Task&lt;Person&gt; defaultPersonTask = </span><span class="c12">new</span><span class="c0">&nbsp;Task&lt;Person&gt;(() =&gt; </span><span class="c12">new</span><span class="c0">&nbsp;Person(</span><span class="c8">&quot;Tom&quot;</span><span class="c0">, </span><span class="c13">37</span><span class="c0">));<br>defaultPersonTask.Start();<br><br>Person defaultPerson = defaultPersonTask.Result;<br>Console.WriteLine(</span><span class="c8">$&quot;{defaultPerson.Name} - {defaultPerson.Age}&quot;</span><span class="c0">); </span><span class="c10">// Tom - 37</span><span class="c0"><br><br>record class </span><span class="c17">Person</span><span class="c0">(</span><span class="c12">string</span><span class="c0">&nbsp;Name, </span><span class="c12">int</span><span class="c0">&nbsp;Age); </span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c11"><span class="c6">&Icirc;n acest caz, sarcina defaultPersonTask returneaz&#259; un obiect de tip Person, pe care &icirc;l putem ob&#539;ine din proprietatea Result.</span></p><p class="c3"><span class="c6"></span></p></body></html>