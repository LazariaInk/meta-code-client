<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c20 doc-content"><p class="c2"><span class="c18">Anularea sarcinilor &#537;i opera&#539;iunilor paralele. CancellationToken.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Execu&#539;ia paralel&#259; a sarcinilor poate dura mult timp. Uneori poate ap&#259;rea necesitatea de a &icirc;ntrerupe o sarcin&#259; &icirc;n execu&#539;ie. Pentru aceasta, platforma .NET ofer&#259; structura </span><span class="c12">CancellationToken </span><span class="c9">din namespace-ul </span><span class="c9 c14">System.Threading</span><span class="c4">.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Algoritmul general pentru anularea unei sarcini presupune urm&#259;torii pa&#537;i:</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">1. Crearea unui obiect </span><span class="c12">CancellationTokenSource</span><span class="c4">, care gestioneaz&#259; &#537;i trimite notificarea de anulare c&#259;tre token.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">2. Ob&#539;inerea token-ului prin proprietatea </span><span class="c12">CancellationTokenSource</span><span class="c9">.</span><span class="c12">Token</span><span class="c4">&nbsp;&#537;i transmiterea acestuia c&#259;tre sarcina ce poate fi anulat&#259;.</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.f83a4e18b1ae195b301884118d38ea8e1b9da85b"></a><a id="t.0"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource(); <br>CancellationToken token = cancelTokenSource.Token;</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Pentru a transmite token-ul c&#259;tre sarcin&#259;, se poate folosi unul dintre constructorii clasei Task:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.1e56c3a24ffa005f65906ad70804a5132788ca0f"></a><a id="t.1"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource(); <br>CancellationToken token = cancelTokenSource.Token;<br>Task task = </span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt; { ac&#539;iuni_de_executat }, token);</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">3. Definirea ac&#539;iunilor &icirc;n sarcin&#259; pentru cazul anul&#259;rii acesteia.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">4. Apel&#259;m metod</span><span class="c12">a CancellationTokenSource.Cancel()</span><span class="c9">, care seteaz&#259; proprietatea </span><span class="c12">CancellationToken.IsCancellationRequested </span><span class="c9">la valoarea true. Este important de &icirc;n&#539;eles c&#259; metoda</span><span class="c12">&nbsp;CancellationTokenSource.Cancel() </span><span class="c9">nu anuleaz&#259; sarcina &icirc;n sine, ci doar trimite o notificare de anulare prin setarea propriet&#259;&#539;ii </span><span class="c9 c14">CancellationToken.IsCancellationRequested</span><span class="c4">. Modul &icirc;n care se va realiza ie&#537;irea din sarcin&#259; este decis de c&#259;tre dezvoltator.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">5. Clasa CancellationTokenSource implementeaz&#259; interfa&#539;a IDisposable. C&acirc;nd lucrul cu obiectul CancellationTokenSource este finalizat, trebuie apelat&#259; metoda Dispose pentru a elibera toate resursele utilizate asociate cu acesta. (&Icirc;n locul apel&#259;rii explicite a metodei Dispose se poate utiliza construc&#539;ia using).</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Acum referitor la al treilea punct - definirea ac&#539;iunilor de anulare a sarcinii. Cum anume s&#259; se &icirc;ncheie sarcina? Ac&#539;iunile specifice depind &icirc;n totalitate de dezvoltator, totu&#537;i exist&#259; dou&#259; variante generale de ie&#537;ire:</span></p><p class="c2 c6"><span class="c4"></span></p><ul class="c15 lst-kix_meoyu4hlko0b-0 start"><li class="c2 c17 li-bullet-0"><span class="c9">la primirea semnalului de anulare ie&#537;irea din metoda sarcinii, de exemplu, cu ajutorul operatorului return sau construind logica metodei &icirc;n mod corespunz&#259;tor. Dar trebuie avut &icirc;n vedere c&#259; &icirc;n acest caz sarcina va trece &icirc;n starea</span><span class="c9 c14">&nbsp;TaskStatus.RanToCompletion</span><span class="c9">, &#537;i nu &icirc;n starea</span><span class="c9 c14">&nbsp;TaskStatus.Canceled</span><span class="c4">.</span></li></ul><p class="c2 c6"><span class="c4"></span></p><ul class="c15 lst-kix_icya3ajo5ahr-0 start"><li class="c2 c17 li-bullet-0"><span class="c9">la primirea semnalului de anulare generarea unei excep&#539;ii </span><span class="c12">OperationCanceledException</span><span class="c9">, apel&acirc;nd metoda </span><span class="c12">ThrowIfCancellationRequested() </span><span class="c9">a tokenului. Dup&#259; aceasta sarcina va trece &icirc;n starea</span><span class="c9 c14">&nbsp;TaskStatus.Canceled</span><span class="c4">.</span></li></ul><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c5">Ie&#537;ire u&#537;oar&#259; din sarcin&#259; f&#259;r&#259; excep&#539;ia OperationCanceledException.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Mai &icirc;nt&acirc;i vom examina prima variant&#259; - ie&#537;irea &quot;u&#537;oar&#259;&quot;:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.5cb5ca331a8dfb82a448bb127e79a4f4ad546c06"></a><a id="t.2"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource():<br>CancellationToken token = cancelTokenSource.Token:<br> <br>Task task = </span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt;<br>{<br> &nbsp; &nbsp;</span><span class="c0">for</span><span class="c3">&nbsp;(</span><span class="c0">int</span><span class="c3">&nbsp;i = </span><span class="c8">1</span><span class="c3">; i &lt; </span><span class="c8">10</span><span class="c3">; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(token.IsCancellationRequested) &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">return</span><span class="c3">: &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;P&#259;tratul num&#259;rului {i} este {i * i}&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">200</span><span class="c3">):<br> &nbsp; &nbsp;}<br>}, token):<br>task.Start():<br> <br>Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br>cancelTokenSource.Cancel():<br>Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br>Console.WriteLine(</span><span class="c13">$&quot;Task Status: {task.Status}&quot;</span><span class="c3">):<br>cancelTokenSource.Dispose(): </span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">&Icirc;n acest caz, sarcina task calculeaz&#259; &#537;i afi&#537;eaz&#259; pe consol&#259; p&#259;tratele numerelor de la 1 la 9. Pentru a anula sarcina, trebuie s&#259; cre&#259;m &#537;i s&#259; folosim un token. La &icirc;nceput se creeaz&#259; un obiect </span><span class="c9 c14">CancellationTokenSource</span><span class="c4">:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.234c85f73874f151fce868c1cf608af0ebe49e0a"></a><a id="t.3"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource():</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Apoi ob&#539;inem token-ul:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.8fd995a2ede0a73ddf368f8711ee663cfb72f870"></a><a id="t.4"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationToken token = cancelTokenSource.Token:</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Pentru a anula opera&#539;iunea, este necesar s&#259; apel&#259;m metoda</span><span class="c9 c14">&nbsp;Cancel()</span><span class="c4">&nbsp;a obiectului CancellationTokenSource:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.7cc7a5f1d67288b69c8bb7f638decc29e29b614c"></a><a id="t.5"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">cancelTokenSource.Cancel():</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">&Icirc;n acest caz, anularea sarcinii este declan&#537;at&#259; dup&#259; o secund&#259; pentru ca sarcina s&#259; efectueze c&acirc;teva ac&#539;iuni.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">&Icirc;n metoda sarcinii, &icirc;n ciclu, putem intercepta semnalul de anulare verific&acirc;nd proprietatea</span><span class="c9 c14">&nbsp;token.IsCancellationRequested</span><span class="c4">:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.2a21d421d3e8aa726ec8ad88abecc51c26913a1e"></a><a id="t.6"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c0">if</span><span class="c3">&nbsp;(token.IsCancellationRequested)<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br> &nbsp; &nbsp;</span><span class="c0">return</span><span class="c3">:<br>}</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Dac&#259; a fost apelat&#259; metoda c</span><span class="c9 c14">ancelTokenSource.Cancel()</span><span class="c4">, expresia token.IsCancellationRequested va &icirc;ntoarce true.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Dup&#259; finalizarea sarcinii, verific&#259;m starea acesteia:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.104a8baf49b3919dd7898820ec8b2bc6c75e4dd6"></a><a id="t.7"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">Console.WriteLine(</span><span class="c13">$&quot;Task Status: {task.Status}&quot;</span><span class="c3">):</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Deoarece sarcina a fost finalizat&#259; cu succes, aceasta va avea statusul </span><span class="c9 c14">RanToCompletion</span><span class="c4">.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">La sf&acirc;r&#537;it, apel&#259;m metoda Dispose a obiectului CancellationTokenSource:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.781e46a30ddf30df973f72a7c63e7c864c8debbc"></a><a id="t.8"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">cancelTokenSource.Dispose():</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Ie&#537;irea consolei programului:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.364730775a02dcc8c17f29521a7a895254b104cb"></a><a id="t.9"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">P&#259;tratul num&#259;rului </span><span class="c8">1</span><span class="c3">&nbsp;este <br>P&#259;tratul num&#259;rului </span><span class="c8">2</span><span class="c3">&nbsp;este </span><span class="c8">4</span><span class="c3">:<br>P&#259;tratul num&#259;rului </span><span class="c8">3</span><span class="c3">&nbsp;este </span><span class="c8">9</span><span class="c3">:<br>P&#259;tratul num&#259;rului </span><span class="c8">4</span><span class="c3">&nbsp;este </span><span class="c8">16</span><span class="c3">:<br>P&#259;tratul num&#259;rului </span><span class="c8">5</span><span class="c3">&nbsp;este </span><span class="c8">25</span><span class="c3">:<br>Opera&#539;iunea a fost &icirc;ntrerupt&#259;:<br>Task Status: RanToCompletion:</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c5">Anularea sarcinii cu generarea unei excep&#539;ii.</span></p><p class="c2 c6"><span class="c5"></span></p><p class="c2"><span class="c9">Al doilea mod de a finaliza o sarcin&#259; este generarea unei excep&#539;ii </span><span class="c12">OperationCanceledException</span><span class="c9">. Pentru aceasta se folose&#537;te metoda </span><span class="c12">ThrowIfCancellationRequested()</span><span class="c4">&nbsp;a obiectului CancellationToken:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.a45aa856b11f6984c3728cca24df9628ac510090"></a><a id="t.10"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource():<br>CancellationToken token = cancelTokenSource.Token:<br> <br>Task task = </span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt;<br>{<br> &nbsp; &nbsp;</span><span class="c0">for</span><span class="c3">&nbsp;(</span><span class="c0">int</span><span class="c3">&nbsp;i = </span><span class="c8">1</span><span class="c3">; i &lt; </span><span class="c8">10</span><span class="c3">; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(token.IsCancellationRequested)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;token.ThrowIfCancellationRequested():<br><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;P&#259;tratul num&#259;rului {i} este {i * i}&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">200</span><span class="c3">):<br> &nbsp; &nbsp;}<br>}, token):<br></span><span class="c0">try</span><span class="c3"><br>{<br> &nbsp; &nbsp;task.Start():<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br> &nbsp; &nbsp;cancelTokenSource.Cancel():<br> <br> &nbsp; &nbsp;task.Wait():<br>}<br></span><span class="c0">catch</span><span class="c3">&nbsp;(AggregateException ae)<br>{<br> &nbsp; &nbsp;</span><span class="c0">foreach</span><span class="c3">&nbsp;(Exception e </span><span class="c0">in</span><span class="c3">&nbsp;ae.InnerExceptions)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(e </span><span class="c0">is</span><span class="c3">&nbsp;TaskCanceledException)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">else</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(e.Message):<br> &nbsp; &nbsp;}<br>}<br></span><span class="c0">finally</span><span class="c3"><br>{<br> &nbsp; &nbsp;cancelTokenSource.Dispose():<br>}<br> <br>Console.WriteLine(</span><span class="c13">$&quot;Task Status: {task.Status}&quot;</span><span class="c3">):</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Din nou, verific&#259;m valoarea propriet&#259;&#539;ii IsCancellationRequested &#537;i, dac&#259; este true, gener&#259;m o excep&#539;ie:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.a4505d02f145cf83a56bcd2239cafdc823f7b9ff"></a><a id="t.11"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c0">if</span><span class="c3">&nbsp;(token.IsCancellationRequested)<br> &nbsp; &nbsp;token.ThrowIfCancellationRequested():</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Pentru a gestiona excep&#539;ia, plas&#259;m &icirc;ntregul cod de lucru cu sarcina &icirc;n construc&#539;ia try..catch &#537;i, de asemenea, apel&#259;m metoda</span><span class="c9 c14">&nbsp;cancelTokenSource.Cancel() </span><span class="c4">pentru a trimite mesajul de anulare a sarcinii.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Este de remarcat faptul c&#259; excep&#539;ia generat&#259; va fi ascuns&#259; &icirc;n obiectul AggregateException, care reprezint&#259; de fapt un set de excep&#539;ii. Dac&#259; motivul excep&#539;iei const&#259; &icirc;n anularea sarcinii, putem g&#259;si &icirc;n acest set de excep&#539;ii o excep&#539;ie de tipul </span><span class="c12">TaskCanceledException</span><span class="c4">.</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.571a7397d6bc13bb9f10228dc545422140dc4609"></a><a id="t.12"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c0">catch</span><span class="c3">&nbsp;(AggregateException ae)<br>{<br> &nbsp; &nbsp;</span><span class="c0">foreach</span><span class="c3">&nbsp;(Exception e </span><span class="c0">in</span><span class="c3">&nbsp;ae.InnerExceptions)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(e </span><span class="c0">is</span><span class="c3">&nbsp;TaskCanceledException)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">else</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(e.Message):<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Clasa TaskCanceledException este derivat&#259; din OperationCanceledException. Excep&#539;ia de tip TaskCanceledException apare dac&#259; sarcinii i se seteaz&#259; statusul </span><span class="c9 c14">Canceled</span><span class="c4">.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Ie&#537;irea consolei programului:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.c0948b85d63b0a8254f5f8c533a50c029d4207dd"></a><a id="t.13"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">P&#259;tratul num&#259;rului </span><span class="c8">1</span><span class="c3">&nbsp;este <br>P&#259;tratul num&#259;rului </span><span class="c8">2</span><span class="c3">&nbsp;este </span><span class="c8">4</span><span class="c3"><br>P&#259;tratul num&#259;rului </span><span class="c8">3</span><span class="c3">&nbsp;este </span><span class="c8">9</span><span class="c3"><br>P&#259;tratul num&#259;rului </span><span class="c8">4</span><span class="c3">&nbsp;este </span><span class="c8">16</span><span class="c3"><br>P&#259;tratul num&#259;rului </span><span class="c8">5</span><span class="c3">&nbsp;este </span><span class="c8">25</span><span class="c3"><br>Opera&#539;iunea a fost &icirc;ntrerupt&#259;<br>Task Status: Canceled:</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Este de remarcat faptul c&#259; excep&#539;ia apare numai atunci c&acirc;nd oprim firul curent &#537;i a&#537;tept&#259;m finalizarea sarcinii folosind metodele Wait sau WaitAll. Dac&#259; aceste metode nu sunt utilizate pentru a a&#537;tepta sarcina, sarcinii i se seteaz&#259; pur &#537;i simplu starea Canceled. De exemplu, &icirc;n urm&#259;torul caz, excep&#539;ia nu va ap&#259;rea:</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">CancellationTokenSource cancelTokenSource = new CancellationTokenSource():</span></p><p class="c2"><span class="c4">CancellationToken token = cancelTokenSource.Token:</span></p><p class="c2"><span class="c4">&nbsp;</span></p><a id="t.78140bb416f19fc90446eaf0c9ed4810642c7b22"></a><a id="t.14"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">Task task = </span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt;<br>{<br> &nbsp; &nbsp;</span><span class="c0">for</span><span class="c3">&nbsp;(</span><span class="c0">int</span><span class="c3">&nbsp;i = </span><span class="c8">1</span><span class="c3">; i &lt; </span><span class="c8">10</span><span class="c3">; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(token.IsCancellationRequested)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;token.ThrowIfCancellationRequested():<br><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;P&#259;tratul num&#259;rului {i} este {i * i}&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">200</span><span class="c3">):<br> &nbsp; &nbsp;}<br>}, token):<br></span><span class="c0">try</span><span class="c3"><br>{<br> &nbsp; &nbsp;task.Start():<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br> &nbsp; &nbsp;cancelTokenSource.Cancel():<br> <br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br>}<br></span><span class="c0">catch</span><span class="c3">&nbsp;(AggregateException ae)<br>{<br> &nbsp; &nbsp;</span><span class="c0">foreach</span><span class="c3">&nbsp;(Exception e </span><span class="c0">in</span><span class="c3">&nbsp;ae.InnerExceptions)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(e </span><span class="c0">is</span><span class="c3">&nbsp;TaskCanceledException)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">else</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(e.Message):<br> &nbsp; &nbsp;}<br>}<br></span><span class="c0">finally</span><span class="c3"><br>{<br> &nbsp; &nbsp;cancelTokenSource.Dispose():<br>}<br> <br>Console.WriteLine(</span><span class="c13">$&quot;Task Status: {task.Status}&quot;</span><span class="c3">):</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Ie&#537;irea consolei programului:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.dfebf03a50eb915011d9dde99dc23a1343cf5dbc"></a><a id="t.15"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">P&#259;tratul num&#259;rului </span><span class="c8">1</span><span class="c3">&nbsp;este <br>P&#259;tratul num&#259;rului </span><span class="c8">2</span><span class="c3">&nbsp;este </span><span class="c8">4</span><span class="c3"><br>P&#259;tratul num&#259;rului </span><span class="c8">3</span><span class="c3">&nbsp;este </span><span class="c8">9</span><span class="c3"><br>P&#259;tratul num&#259;rului </span><span class="c8">4</span><span class="c3">&nbsp;este </span><span class="c8">16</span><span class="c3"><br>P&#259;tratul num&#259;rului </span><span class="c8">5</span><span class="c3">&nbsp;este </span><span class="c8">25</span><span class="c3"><br>Task Status: Canceled:</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c5">&Icirc;nregistrarea unui handler de anulare a sarcinii.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Mai sus, pentru a verifica semnalul de anulare, s-a folosit proprietatea IsCancellationRequested. Dar exist&#259; &#537;i o alt&#259; metod&#259; de a afla c&#259; a fost trimis un semnal de anulare a sarcinii. Metoda </span><span class="c12">Register() </span><span class="c4">permite &icirc;nregistrarea unui handler de anulare a sarcinii sub forma unui delegat Action:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.4344e81ed287c3617e48f775dc1c82437f6aa8a3"></a><a id="t.16"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource():<br>CancellationToken token = cancelTokenSource.Token:<br> <br>Task task = </span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt;<br>{<br> &nbsp; &nbsp;</span><span class="c0">int</span><span class="c3">&nbsp;i = <br> &nbsp; &nbsp;token.Register(() =&gt; <br> &nbsp; &nbsp;{ <br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">): <br> &nbsp; &nbsp; &nbsp; &nbsp;i = </span><span class="c8">10</span><span class="c3">: <br> &nbsp; &nbsp;}):<br> &nbsp; &nbsp;</span><span class="c0">for</span><span class="c3">&nbsp;(; i &lt; </span><span class="c8">10</span><span class="c3">; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;P&#259;tratul num&#259;rului {i} este {i * i}&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">400</span><span class="c3">):<br> &nbsp; &nbsp;}<br>}, token):<br>task.Start():<br> <br>Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br>cancelTokenSource.Cancel():<br>Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br>Console.WriteLine(</span><span class="c13">$&quot;Task Status: {task.Status}&quot;</span><span class="c3">):<br>cancelTokenSource.Dispose(): </span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Aici handler-ul de anulare este reprezentat de o expresie lambda:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.45f56a0293974aebb65eb4f8fb1345c6d79d484d"></a><a id="t.17"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">token.Register(() =&gt; <br>{ <br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">): <br> &nbsp; &nbsp;i = </span><span class="c8">10</span><span class="c3">: <br>}):</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Deoarece ac&#539;iunea sarcinii este reprezentat&#259; de un ciclu care se execut&#259; la valoarea i mai mic&#259; de 10, setarea acestei variabile &icirc;n handler-ul de anulare va duce la ie&#537;irea din ciclu &#537;i, &icirc;n consecin&#539;&#259;, la finalizarea sarcinii.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c5">Transmiterea token-ului &icirc;ntr-o metod&#259; extern&#259;.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c4">Dac&#259; opera&#539;iunea care se efectueaz&#259; &icirc;n sarcin&#259; reprezint&#259; o metod&#259; extern&#259;, &icirc;i putem transmite token-ul ca unul dintre parametri:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.3c6792304320ef2a1d3f3d7dd82593d44e063cfb"></a><a id="t.18"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource():<br>CancellationToken token = cancelTokenSource.Token:<br> <br>Task task = </span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt;PrintSquares(token), token):<br></span><span class="c0">try</span><span class="c3"><br>{<br> &nbsp; &nbsp;task.Start():<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">1000</span><span class="c3">):<br> &nbsp; &nbsp;cancelTokenSource.Cancel():<br> <br> &nbsp; &nbsp;task.Wait():<br>}<br></span><span class="c0">catch</span><span class="c3">&nbsp;(AggregateException ae)<br>{<br> &nbsp; &nbsp;</span><span class="c0">foreach</span><span class="c3">&nbsp;(Exception e </span><span class="c0">in</span><span class="c3">&nbsp;ae.InnerExceptions)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(e </span><span class="c0">is</span><span class="c3">&nbsp;TaskCanceledException)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">else</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(e.Message):<br> &nbsp; &nbsp;}<br>}<br></span><span class="c0">finally</span><span class="c3"><br>{<br> &nbsp; &nbsp;cancelTokenSource.Dispose():<br>}<br> <br>Console.WriteLine(</span><span class="c13">$&quot;Task Status: {task.Status}&quot;</span><span class="c3">):<br><br></span><span class="c0">void</span><span class="c3">&nbsp;</span><span class="c16">PrintSquares</span><span class="c3">(CancellationToken token)<br>{<br> &nbsp; &nbsp;</span><span class="c0">for</span><span class="c3">&nbsp;(</span><span class="c0">int</span><span class="c3">&nbsp;i = </span><span class="c8">1</span><span class="c3">; i &lt; </span><span class="c8">10</span><span class="c3">; i++)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">if</span><span class="c3">&nbsp;(token.IsCancellationRequested)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;token.ThrowIfCancellationRequested():<br><br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;P&#259;tratul num&#259;rului {i} este {i * i}&quot;</span><span class="c3">):<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">200</span><span class="c3">):<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c5">Anularea opera&#539;iunilor paralele Parallel.</span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">Pentru a anula executarea opera&#539;iunilor paralele, lansate cu ajutorul metodelor </span><span class="c12">Parallel.For()</span><span class="c9">&nbsp;&#537;i </span><span class="c12">Parallel.ForEach()</span><span class="c9">, se pot folosi versiuni supra&icirc;nc&#259;rcate ale acestor metode, care accept&#259; ca parametru un obiect </span><span class="c12">ParallelOptions</span><span class="c4">. Acest obiect permite setarea token-ului:</span></p><p class="c2 c6"><span class="c4"></span></p><a id="t.426bdabcbd9dd76be883282bdb8f0332648c9651"></a><a id="t.19"></a><table class="c7"><tr class="c10"><td class="c1" colspan="1" rowspan="1"><p class="c11"><span class="c3">CancellationTokenSource cancelTokenSource = </span><span class="c0">new</span><span class="c3">&nbsp;CancellationTokenSource():<br>CancellationToken token = cancelTokenSource.Token:<br> <br></span><span class="c0">new</span><span class="c3">&nbsp;Task(() =&gt;<br>{<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">400</span><span class="c3">):<br> &nbsp; &nbsp;cancelTokenSource.Cancel():<br>}).Start():<br> <br></span><span class="c0">try</span><span class="c3"><br>{<br> &nbsp; &nbsp;Parallel.ForEach&lt;</span><span class="c0">int</span><span class="c3">&gt;(</span><span class="c0">new</span><span class="c3">&nbsp;List&lt;</span><span class="c0">int</span><span class="c3">&gt;() { </span><span class="c8">1</span><span class="c3">, </span><span class="c8">2</span><span class="c3">, </span><span class="c8">3</span><span class="c3">, </span><span class="c8">4</span><span class="c3">, </span><span class="c8">5</span><span class="c3">},<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">new</span><span class="c3">&nbsp;ParallelOptions { CancellationToken = token }, Square):<br> &nbsp; &nbsp;</span><span class="c19">// sau a&#537;a</span><span class="c3"><br> &nbsp; &nbsp;</span><span class="c19">//Parallel.For(1, 5, new ParallelOptions { CancellationToken = token }, Square):</span><span class="c3"><br>}<br></span><span class="c0">catch</span><span class="c3">&nbsp;(OperationCanceledException)<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c3">):<br>}<br></span><span class="c0">finally</span><span class="c3"><br>{<br> &nbsp; &nbsp;cancelTokenSource.Dispose():<br>}<br><br></span><span class="c0">void</span><span class="c3">&nbsp;</span><span class="c16">Square</span><span class="c3">(</span><span class="c0">int</span><span class="c3">&nbsp;n)<br>{<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c8">3000</span><span class="c3">):<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c13">$&quot;P&#259;tratul num&#259;rului {n} este {n * n}&quot;</span><span class="c3">):<br>}</span></p></td></tr></table><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c9">&Icirc;n sarcina paralel&#259; lansat&#259;, dup&#259; 400 de milisecunde, are loc apelarea metodei </span><span class="c9 c14">cancelTokenSource.Cancel()</span><span class="c4">, rezult&acirc;nd c&#259; programul arunc&#259; excep&#539;ia OperationCanceledException, iar executarea opera&#539;iunilor paralele se opre&#537;te.</span></p><p class="c2 c6"><span class="c4"></span></p></body></html>