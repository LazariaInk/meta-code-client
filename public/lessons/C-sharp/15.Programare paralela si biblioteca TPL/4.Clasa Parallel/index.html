<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c13 doc-content"><p class="c0"><span class="c18">Clasa Parallel.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Clasa </span><span class="c5">Parallel </span><span class="c12">face parte din TPL &#537;i este conceput&#259; pentru a simplifica execu&#539;ia paralel&#259; a codului. </span><span class="c5">Parallel </span><span class="c4">are o serie de metode care permit paralelizarea unei sarcini.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Una dintre metodele care permit execu&#539;ia paralel&#259; a sarcinilor este metoda </span><span class="c5">Invoke</span><span class="c4">:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.e10dcf9bb5b73b2af35921848eb710033349e02c"></a><a id="t.0"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c14">// metoda Parallel.Invoke execut&#259; trei metode</span><span class="c2"><br>Parallel.Invoke(<br> &nbsp; &nbsp;Print,<br> &nbsp; &nbsp;() =&gt;<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Se execut&#259; sarcina {Task.CurrentId}&quot;</span><span class="c2">);<br> &nbsp; &nbsp; &nbsp; &nbsp;Thread.Sleep(</span><span class="c3">3000</span><span class="c2">);<br> &nbsp; &nbsp;},<br> &nbsp; &nbsp;() =&gt; Square(</span><span class="c3">5</span><span class="c2">)<br>);<br><br></span><span class="c7">void</span><span class="c2">&nbsp;</span><span class="c11">Print</span><span class="c2">()<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Se execut&#259; sarcina {Task.CurrentId}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c3">3000</span><span class="c2">);<br>}<br><br></span><span class="c14">// calcul&#259;m p&#259;tratul unui num&#259;r</span><span class="c2"><br></span><span class="c7">void</span><span class="c2">&nbsp;</span><span class="c11">Square</span><span class="c2">(</span><span class="c7">int</span><span class="c2">&nbsp;n)<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Se execut&#259; sarcina {Task.CurrentId}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c3">3000</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Rezultatul {n * n}&quot;</span><span class="c2">);<br>}</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Metoda </span><span class="c6">Parallel.Invoke</span><span class="c4">&nbsp;prime&#537;te ca parametru un array de obiecte Action, ceea ce &icirc;nseamn&#259; c&#259; putem transmite &icirc;n aceast&#259; metod&#259; un set de metode care vor fi apelate la execu&#539;ia sa. Num&#259;rul de metode poate varia, dar &icirc;n acest caz, am definit trei metode. La fel ca &icirc;n cazul clasei Task, putem transmite fie numele metodei, fie o expresie lambda.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c4">Astfel, dac&#259; ma&#537;ina &#539;int&#259; are mai multe nuclee, aceste metode vor fi executate &icirc;n paralel pe diferite nuclee. Ie&#537;ire pe consol&#259; a programului:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.357f586fcd8252260a4233306b6d6657187574da"></a><a id="t.1"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">Se execut&#259; sarcina </span><span class="c3">1</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">3</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">2</span><span class="c2"><br>Rezultatul </span><span class="c3">25</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c17">Metoda Parallel.For.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Metoda </span><span class="c5">Parallel.For</span><span class="c4">&nbsp;permite execu&#539;ia paralel&#259; a itera&#539;iilor unui ciclu. Are urm&#259;toarea defini&#539;ie:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.a4e3ccc7771a34aee25eace359d59e73ad68573a"></a><a id="t.2"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">For(</span><span class="c7">int</span><span class="c2">, </span><span class="c7">int</span><span class="c2">, Action&lt;</span><span class="c7">int</span><span class="c2">&gt;)</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c4">Primul parametru al metodei specific&#259; indexul de &icirc;nceput al elementului din ciclu, iar al doilea parametru - indexul final. Al treilea parametru - delegatul Action - specific&#259; metoda care va fi executat&#259; o dat&#259; pe itera&#539;ie:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.72ccc3eb8c813800e1c547388f4be1e5111dc080"></a><a id="t.3"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">Parallel.For(</span><span class="c3">1</span><span class="c2">, </span><span class="c3">5</span><span class="c2">, Square);<br><br></span><span class="c14">// calcul&#259;m p&#259;tratul unui num&#259;r</span><span class="c2"><br></span><span class="c7">void</span><span class="c2">&nbsp;</span><span class="c11">Square</span><span class="c2">(</span><span class="c7">int</span><span class="c2">&nbsp;n)<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Se execut&#259; sarcina {Task.CurrentId}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;P&#259;tratul num&#259;rului {n} este {n * n}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c3">2000</span><span class="c2">);<br>}</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c4">&Icirc;n acest caz, primul parametru transmis metodei Parallel.For este num&#259;rul 1, iar al doilea - num&#259;rul 5. Astfel, metoda va itera de la 1 la 4 inclusiv. Al treilea parametru reprezint&#259; metoda care calculeaz&#259; p&#259;tratul unui num&#259;r. Deoarece acest parametru reprezint&#259; tipul Action&lt;int&gt;, metoda trebuie s&#259; accepte un parametru de tip int.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c4">Parametrul transmis metodei este contorul care parcurge ciclul de la 1 la 4 inclusiv. Metoda Square va fi astfel apelat&#259; de 4 ori. Ie&#537;ire pe consol&#259;:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.ac16b613084d826154f4b5320875410b1a80698e"></a><a id="t.4"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">Se execut&#259; sarcina </span><span class="c3">1</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">2</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">4</span><span class="c2">&nbsp;este </span><span class="c3">16</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">4</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">1</span><span class="c2">&nbsp;este </span><span class="c3">1</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">3</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">3</span><span class="c2">&nbsp;este </span><span class="c3">9</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">2</span><span class="c2">&nbsp;este </span><span class="c3">4</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c17">Metoda Parallel.ForEach.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Metoda</span><span class="c5">&nbsp;Parallel.ForEach</span><span class="c12">&nbsp;realizeaz&#259; itera&#539;ii pe o colec&#539;ie care implementeaz&#259; interfa&#539;a </span><span class="c5">IEnumerable</span><span class="c4">, similar ciclului foreach, dar execut&#259; itera&#539;iile &icirc;n paralel. Are urm&#259;toarea defini&#539;ie:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.7b7db944bbb7d0a64cd43ea1cccc2eff4a5b0fe1"></a><a id="t.5"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2 c19">ParallelLoopResult ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source,</span></p><p class="c9"><span class="c2">Action&lt;TSource&gt; body)</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c4">Primul parametru reprezint&#259; colec&#539;ia care va fi iterat&#259;, iar al doilea parametru - delegatul care se execut&#259; o dat&#259; pe itera&#539;ie pentru fiecare element al colec&#539;iei.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">La ie&#537;ire, metoda returneaz&#259; structura </span><span class="c6">ParallelLoopResult</span><span class="c4">, care con&#539;ine informa&#539;ii despre execu&#539;ia ciclului.</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.0c7f384be3eca92d91324978d31051e5414f2677"></a><a id="t.6"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">ParallelLoopResult result = Parallel.ForEach&lt;</span><span class="c7">int</span><span class="c2">&gt;(<br> &nbsp; &nbsp;</span><span class="c7">new</span><span class="c2">&nbsp;List&lt;</span><span class="c7">int</span><span class="c2">&gt;() { </span><span class="c3">1</span><span class="c2">, </span><span class="c3">3</span><span class="c2">, </span><span class="c3">5</span><span class="c2">, </span><span class="c3">8</span><span class="c2">&nbsp;},<br> &nbsp; &nbsp;Square<br>);<br><br></span><span class="c14">// calcul&#259;m p&#259;tratul unui num&#259;r</span><span class="c2"><br></span><span class="c7">void</span><span class="c2">&nbsp;</span><span class="c11">Square</span><span class="c2">(</span><span class="c7">int</span><span class="c2">&nbsp;n)<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Se execut&#259; sarcina {Task.CurrentId}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;P&#259;tratul num&#259;rului {n} este {n * n}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c3">2000</span><span class="c2">);<br>}</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c4">&Icirc;n acest caz, folosim o colec&#539;ie de obiecte int, astfel c&#259; metoda transmis&#259; ca al doilea parametru trebuie s&#259; accepte un parametru de tip int. Ie&#537;ire pe consol&#259;:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.b6e8c4a8c6386a0aac0fd7e92230e2129f706c00"></a><a id="t.7"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">Se execut&#259; sarcina </span><span class="c3">1</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">3</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">8</span><span class="c2">&nbsp;este </span><span class="c3">64</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">4</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">3</span><span class="c2">&nbsp;este </span><span class="c3">9</span><span class="c2"><br>Se execut&#259; sarcina </span><span class="c3">2</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">5</span><span class="c2">&nbsp;este </span><span class="c3">25</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c3">1</span><span class="c2">&nbsp;este </span><span class="c3">1</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c17">Ie&#537;irea din ciclu.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">&Icirc;n ciclurile for &#537;i foreach standard, ie&#537;irea anticipat&#259; din ciclu se face cu ajutorul operatorului </span><span class="c5">break</span><span class="c4">. &Icirc;n metodele Parallel.ForEach &#537;i Parallel.For, putem ie&#537;i din ciclu &icirc;nainte de finalizarea acestuia:</span></p><p class="c0 c1"><span class="c4"></span></p><a id="t.4ffe0e6cf750edb420d88e1e021949e19634df8a"></a><a id="t.8"></a><table class="c10"><tr class="c15"><td class="c8" colspan="1" rowspan="1"><p class="c9"><span class="c2">ParallelLoopResult result = Parallel.For(</span><span class="c3">1</span><span class="c2">, </span><span class="c3">10</span><span class="c2">, Square);<br></span><span class="c7">if</span><span class="c2">&nbsp;(!result.IsCompleted)<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;Execu&#539;ia ciclului s-a terminat la itera&#539;ia {result.LowestBreakIteration}&quot;</span><span class="c2">);<br><br></span><span class="c14">// calcul&#259;m p&#259;tratul unui num&#259;r</span><span class="c2"><br></span><span class="c7">void</span><span class="c2">&nbsp;</span><span class="c11">Square</span><span class="c2">(</span><span class="c7">int</span><span class="c2">&nbsp;n, ParallelLoopState pls)<br>{<br> &nbsp; &nbsp;</span><span class="c7">if</span><span class="c2">&nbsp;(n == </span><span class="c3">5</span><span class="c2">) pls.Break(); &nbsp; &nbsp;</span><span class="c14">// dac&#259; parametrul este 5, ie&#537;im din ciclu</span><span class="c2"><br><br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c16">$&quot;P&#259;tratul num&#259;rului {n} este {n * n}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c3">2000</span><span class="c2">);<br>}</span></p></td></tr></table><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Aici, metoda Square, care proceseaz&#259; fiecare itera&#539;ie, accept&#259; un parametru suplimentar - obiectul </span><span class="c5">ParallelLoopState</span><span class="c4">. Dac&#259; contorul din ciclu ajunge la valoarea 5, se apeleaz&#259; metoda Break. Acest lucru face ca sistemul s&#259; ias&#259; din execu&#539;ia metodei Parallel.For la prima ocazie disponibil&#259;.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Metodele Parallel.ForEach &#537;i Parallel.For returneaz&#259; un obiect </span><span class="c5">ParallelLoopResult</span><span class="c4">, care are dou&#259; propriet&#259;&#539;i importante:</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">- </span><span class="c5">IsCompleted</span><span class="c4">: indic&#259; dac&#259; execu&#539;ia complet&#259; a ciclului paralel s-a finalizat.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">- </span><span class="c5">LowestBreakIteration</span><span class="c4">: returneaz&#259; indexul la care execu&#539;ia ciclului a fost &icirc;ntrerupt&#259;.</span></p><p class="c0 c1"><span class="c4"></span></p><p class="c0"><span class="c12">Deoarece &icirc;n exemplul nostru execu&#539;ia ciclului se &icirc;ntrerupe la indexul 5, proprietatea IsCompleted va avea valoarea </span><span class="c6">false</span><span class="c12">, iar </span><span class="c6">LowestBreakIteration </span><span class="c4">va fi egal&#259; cu 5.</span></p><p class="c0 c1"><span class="c4"></span></p></body></html>