<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT);ol{margin:0;padding:0}table td,table th{padding:0}.c3{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c12{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:27pt;font-family:"Open Sans";font-style:normal}.c6{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Open Sans";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c11{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#888888;font-weight:400}.c1{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#d36363;font-weight:400}.c4{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#fcc28c;font-weight:400}.c9{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffaa;font-weight:400}.c0{background-color:#333333;font-size:12pt;font-family:"Consolas";color:#ffffff;font-weight:400}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c8{border-spacing:0;border-collapse:collapse;margin-right:auto}.c15{font-size:12pt;font-family:"Open Sans";font-weight:700}.c13{font-size:12pt;font-family:"Open Sans";font-weight:400}.c17{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c16{font-style:italic}.c14{height:0pt}.c10{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c17 doc-content"><p class="c7"><span class="c12">Introducere &icirc;n Parallel LINQ. Metoda AsParallel.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c13">&Icirc;n mod implicit, toate elementele colec&#539;iei &icirc;n LINQ sunt procesate secven&#539;ial, dar &icirc;ncep&acirc;nd cu .NET 4.0, &icirc;n spa&#539;iul de nume System.Linq a fost ad&#259;ugat&#259; clasa </span><span class="c15">ParallelEnumerable</span><span class="c2">, care &icirc;ncorporeaz&#259; func&#539;ionalitatea PLINQ (Parallel LINQ) &#537;i permite efectuarea interog&#259;rilor asupra colec&#539;iei &icirc;n mod paralel.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">&Icirc;n timpul proces&#259;rii colec&#539;iei, PLINQ utilizeaz&#259; capacit&#259;&#539;ile tuturor procesoarelor din sistem. Sursa de date este &icirc;mp&#259;r&#539;it&#259; &icirc;n segmente, iar fiecare segment este procesat &icirc;ntr-un fir de execu&#539;ie separat. Acest lucru permite efectuarea interog&#259;rii pe ma&#537;ini multicore mult mai rapid.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">&Icirc;n acela&#537;i timp, implicit, PLINQ alege procesarea secven&#539;ial&#259; a datelor. Trecerea la procesarea paralel&#259; are loc &icirc;n cazul &icirc;n care aceasta duce la o accelerare a muncii. Totu&#537;i, de obicei, &icirc;n opera&#539;iile paralele cresc costurile suplimentare. Prin urmare, dac&#259; procesarea paralel&#259; necesit&#259; poten&#539;ial resurse mari, PLINQ poate alege procesarea secven&#539;ial&#259;, dac&#259; aceasta nu necesit&#259; resurse mari.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">Astfel, sensul utiliz&#259;rii PLINQ este predominant &icirc;n colec&#539;iile mari sau &icirc;n opera&#539;iile complexe, unde beneficiul paraleliz&#259;rii interog&#259;rilor poate compensa costurile suplimentare generate.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">De asemenea, trebuie s&#259; avem &icirc;n vedere c&#259;, atunci c&acirc;nd acces&#259;m un stat partajat &icirc;n opera&#539;iile paralele, se va folosi implicit sincronizarea pentru a evita blocarea reciproc&#259; a accesului la aceste resurse comune. Costurile de sincronizare duc la sc&#259;derea performan&#539;ei, astfel &icirc;nc&acirc;t este recomandabil s&#259; evit&#259;m sau s&#259; limit&#259;m utilizarea resurselor partajate &icirc;n opera&#539;iile paralele.</span></p><p class="c7 c10"><span class="c6"></span></p><p class="c7"><span class="c6">Metoda AsParallel.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c13">Metoda </span><span class="c15">AsParallel()</span><span class="c2">&nbsp;permite paralelizarea interog&#259;rii asupra sursei de date. Ea este implementat&#259; ca metod&#259; de extensie LINQ pentru array-uri &#537;i colec&#539;ii. La apelarea acestei metode, sursa de date este &icirc;mp&#259;r&#539;it&#259; &icirc;n p&#259;r&#539;i (dac&#259; este posibil) &#537;i asupra fiec&#259;rei p&#259;r&#539;i se efectueaz&#259; opera&#539;ii separat.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">S&#259; analiz&#259;m un exemplu simplu de g&#259;sire a p&#259;tratelor numerelor:</span></p><p class="c7 c10"><span class="c2"></span></p><a id="t.b7e3d41a934c93c4694d12e50c8b66f1a84a72e8"></a><a id="t.0"></a><table class="c8"><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c4">int</span><span class="c0">[] numbers = </span><span class="c4">new</span><span class="c0">&nbsp;</span><span class="c4">int</span><span class="c0">[] { </span><span class="c1">1</span><span class="c0">, </span><span class="c1">2</span><span class="c0">, </span><span class="c1">3</span><span class="c0">, </span><span class="c1">4</span><span class="c0">, </span><span class="c1">5</span><span class="c0">, </span><span class="c1">6</span><span class="c0">, </span><span class="c1">7</span><span class="c0">, </span><span class="c1">8</span><span class="c0">, };<br></span><span class="c4">var</span><span class="c0">&nbsp;squares = </span><span class="c4">from</span><span class="c0">&nbsp;n </span><span class="c4">in</span><span class="c0">&nbsp;numbers.AsParallel()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4">select</span><span class="c0">&nbsp;</span><span class="c9">Square</span><span class="c0">(n);<br> <br></span><span class="c4">foreach</span><span class="c0">&nbsp;(</span><span class="c4">var</span><span class="c0">&nbsp;n </span><span class="c4">in</span><span class="c0">&nbsp;squares)<br> &nbsp; &nbsp;Console.WriteLine(n);<br> <br></span><span class="c4">int</span><span class="c0">&nbsp;</span><span class="c9">Square</span><span class="c0">(</span><span class="c4">int</span><span class="c0">&nbsp;n) =&gt; n * n;</span></p></td></tr></table><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">De fapt, aici avem o interogare LINQ obi&#537;nuit&#259;, doar c&#259; asupra sursei de date se aplic&#259; metoda AsParallel.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">Rezultatul programului arat&#259; c&#259; datele au fost selectate pentru g&#259;sirea p&#259;tratelor nu secven&#539;ial. Deci, a avut loc paralelizarea muncii programului:</span></p><p class="c7 c10"><span class="c2"></span></p><a id="t.d19c6e0968cb1ff53bb194df715fff35b57c0e38"></a><a id="t.1"></a><table class="c8"><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c1">49</span><span class="c0"><br></span><span class="c1">1</span><span class="c0"><br></span><span class="c1">9</span><span class="c0"><br></span><span class="c1">25</span><span class="c0"><br></span><span class="c1">64</span><span class="c0"><br></span><span class="c1">4</span><span class="c0"><br></span><span class="c1">16</span><span class="c0"><br></span><span class="c1">36</span></p></td></tr></table><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c2">Opera&#539;ie similar&#259; folosind metode de extensie:</span></p><p class="c7 c10"><span class="c2"></span></p><a id="t.de8789a56f4fd1e26bde2868532a7cb467fd8bf5"></a><a id="t.2"></a><table class="c8"><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c4">var</span><span class="c0">&nbsp;squares = numbers.AsParallel().Select(x =&gt; Square(x));</span></p></td></tr></table><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c6">Metoda ForAll.</span></p><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c13">Codul de mai sus pentru calcularea p&#259;tratului unui num&#259;r poate fi optimizat &#537;i mai mult din punct de vedere al paraleliz&#259;rii. &Icirc;n special, pentru afi&#537;area rezultatului opera&#539;iei paralele se folose&#537;te ciclul foreach. Dar utilizarea acestuia duce la cre&#537;terea costurilor - este necesar s&#259; se uneasc&#259; datele ob&#539;inute &icirc;n diferite fire de execu&#539;ie &icirc;ntr-un singur set &#537;i apoi s&#259; se parcurg&#259; &icirc;n ciclu. Mai optim &icirc;n acest caz ar fi utilizarea metodei</span><span class="c15">&nbsp;ForAll()</span><span class="c2">, care afi&#537;eaz&#259; datele &icirc;n acela&#537;i fir de execu&#539;ie &icirc;n care sunt procesate:</span></p><p class="c7 c10"><span class="c2"></span></p><a id="t.0f9fb6ef72491ffd4be76dd75fca08425e47ab0c"></a><a id="t.3"></a><table class="c8"><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c4">int</span><span class="c0">[] numbers = </span><span class="c4">new</span><span class="c0">&nbsp;</span><span class="c4">int</span><span class="c0">[] { </span><span class="c1">1</span><span class="c0">, </span><span class="c1">2</span><span class="c0">, </span><span class="c1">3</span><span class="c0">, </span><span class="c1">4</span><span class="c0">, </span><span class="c1">5</span><span class="c0">, </span><span class="c1">6</span><span class="c0">, </span><span class="c1">7</span><span class="c0">, </span><span class="c1">8</span><span class="c0">, };<br> <br></span><span class="c11">// cu ajutorul operatorilor LINQ</span><span class="c0"><br>(</span><span class="c4">from</span><span class="c0">&nbsp;n </span><span class="c4">in</span><span class="c0">&nbsp;numbers.AsParallel() </span><span class="c4">select</span><span class="c0">&nbsp;</span><span class="c9">Square</span><span class="c0">(n)).</span><span class="c9">ForAll</span><span class="c0">(Console.WriteLine);<br> <br></span><span class="c11">// cu ajutorul metodelor de extensie LINQ</span><span class="c0"><br>numbers.AsParallel().Select(n =&gt; Square(n)).ForAll(Console.WriteLine);<br> <br></span><span class="c4">int</span><span class="c0">&nbsp;</span><span class="c9">Square</span><span class="c0">(</span><span class="c4">int</span><span class="c0">&nbsp;n) =&gt; n * n;</span></p></td></tr></table><p class="c7 c10"><span class="c2"></span></p><p class="c7"><span class="c13">Metoda</span><span class="c13 c16">&nbsp;ForAll()</span><span class="c2">&nbsp;accept&#259; ca parametru un delegat Action, care specific&#259; ac&#539;iunea de executat.</span></p><p class="c7 c10"><span class="c2"></span></p></body></html>