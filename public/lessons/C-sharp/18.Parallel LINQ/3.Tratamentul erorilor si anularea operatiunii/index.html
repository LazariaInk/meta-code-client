<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><link rel="stylesheet" type="text/css" href="/lessons/styles.css"></head><body class="c9 doc-content"><p class="c7"><span class="c16">Tratamentul erorilor &#537;i anularea opera&#539;iunii.</span></p><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c1">&Icirc;n timpul execu&#539;iei opera&#539;iunilor paralele pot ap&#259;rea erori, a c&#259;ror tratare are particularit&#259;&#539;ile sale. &Icirc;n procesarea paralel&#259;, colec&#539;ia este &icirc;mp&#259;r&#539;it&#259; &icirc;n p&#259;r&#539;i, iar fiecare parte este procesat&#259; &icirc;ntr-un fir de execu&#539;ie separat. Totu&#537;i, dac&#259; apare o eroare &icirc;ntr-unul dintre firele de execu&#539;ie, sistemul &icirc;ntrerupe execu&#539;ia tuturor firelor.</span></p><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c5">La generarea excep&#539;iilor, toate acestea sunt agregate &icirc;ntr-o excep&#539;ie de tip </span><span class="c6">AggregateException</span><span class="c1">.</span></p><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c1">De exemplu, s&#259; presupunem c&#259; &icirc;n metoda factorialului se transmite un array de obiecte care con&#539;ine nu doar numere, ci &#537;i &#537;iruri de caractere:</span></p><p class="c4"><span class="c1"></span></p><a id="t.d6b6e9058c6791ee442cf2c1839669a18e09e08a"></a><a id="t.0"></a><table class="c11"><tr class="c10"><td class="c14" colspan="1" rowspan="1"><p class="c17"><span class="c3">object</span><span class="c2">[] numbers = </span><span class="c3">new</span><span class="c2">&nbsp;</span><span class="c3">object</span><span class="c2">[] { </span><span class="c0">1</span><span class="c2">, </span><span class="c0">2</span><span class="c2">, </span><span class="c0">3</span><span class="c2">, </span><span class="c0">4</span><span class="c2">, </span><span class="c0">5</span><span class="c2">, </span><span class="c12">&quot;6&quot;</span><span class="c2">&nbsp;};<br><br></span><span class="c3">var</span><span class="c2">&nbsp;squares = </span><span class="c3">from</span><span class="c2">&nbsp;n </span><span class="c3">in</span><span class="c2">&nbsp;numbers.AsParallel()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">let</span><span class="c2">&nbsp;x = (</span><span class="c3">int</span><span class="c2">)n<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">select</span><span class="c2">&nbsp;</span><span class="c8">Square</span><span class="c2">(x);<br></span><span class="c3">try</span><span class="c2"><br>{<br> &nbsp; &nbsp;squares.ForAll(n =&gt; Console.WriteLine(n));<br>}<br></span><span class="c3">catch</span><span class="c2">&nbsp;(AggregateException ex)<br>{<br> &nbsp; &nbsp;</span><span class="c3">foreach</span><span class="c2">&nbsp;(</span><span class="c3">var</span><span class="c2">&nbsp;e </span><span class="c3">in</span><span class="c2">&nbsp;ex.InnerExceptions)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(e.Message);<br> &nbsp; &nbsp;}<br>}<br><br></span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c8">Square</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;n) =&gt; n * n;</span></p></td></tr></table><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c5">Lans&#259;m proiectul </span><span class="c6">f&#259;r&#259; depanare</span><span class="c1">. &#536;i deoarece array-ul con&#539;ine un &#537;ir de caractere, &icirc;ncercarea de conversie va e&#537;ua, iar pe consol&#259; va fi afi&#537;at un mesaj de eroare. La rularea aplica&#539;iei &icirc;n Visual Studio &icirc;n modul de depanare, execu&#539;ia se va opri la linia de conversie. Dup&#259; continuare, va func&#539;iona &#537;i capturarea excep&#539;iei &icirc;n blocul catch, iar pe consol&#259; va fi afi&#537;at mesajul de eroare.</span></p><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c15">&Icirc;ntreruperea opera&#539;iunii paralele.</span></p><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c5">Este foarte probabil s&#259; avem nevoie s&#259; &icirc;ntrerupem o opera&#539;iune &icirc;nainte de finalizarea acesteia. &Icirc;n acest caz, putem folosi metoda</span><span class="c6">&nbsp;WithCancellation()</span><span class="c5">, c&#259;reia i se transmite un token </span><span class="c6">CancellationToken </span><span class="c1">ca parametru:</span></p><p class="c4"><span class="c1"></span></p><a id="t.58d49c8afe923050ff702f340fb001be30d6f3b0"></a><a id="t.1"></a><table class="c11"><tr class="c10"><td class="c14" colspan="1" rowspan="1"><p class="c17"><span class="c2">CancellationTokenSource cts = </span><span class="c3">new</span><span class="c2">&nbsp;CancellationTokenSource();<br></span><span class="c13">// lans&#259;m o sarcin&#259; suplimentar&#259; care &icirc;ntrerupe opera&#539;iunea dup&#259; 400 ms</span><span class="c2"><br></span><span class="c3">new</span><span class="c2">&nbsp;Task(() =&gt;<br>{<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c0">400</span><span class="c2">);<br> &nbsp; &nbsp;cts.Cancel();<br>}).Start();<br><br></span><span class="c3">try</span><span class="c2"><br>{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c2">[] numbers = </span><span class="c3">new</span><span class="c2">&nbsp;</span><span class="c3">int</span><span class="c2">[] { </span><span class="c0">1</span><span class="c2">, </span><span class="c0">2</span><span class="c2">, </span><span class="c0">3</span><span class="c2">, </span><span class="c0">4</span><span class="c2">, </span><span class="c0">5</span><span class="c2">, </span><span class="c0">6</span><span class="c2">, </span><span class="c0">7</span><span class="c2">, </span><span class="c0">8</span><span class="c2">, };<br><br> &nbsp; &nbsp;</span><span class="c3">var</span><span class="c2">&nbsp;squares = </span><span class="c3">from</span><span class="c2">&nbsp;n </span><span class="c3">in</span><span class="c2">&nbsp;numbers.AsParallel().WithCancellation(cts.Token)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">select</span><span class="c2">&nbsp;</span><span class="c8">Square</span><span class="c2">(n);<br><br> &nbsp; &nbsp;</span><span class="c3">foreach</span><span class="c2">&nbsp;(</span><span class="c3">var</span><span class="c2">&nbsp;n </span><span class="c3">in</span><span class="c2">&nbsp;squares)<br> &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(n);<br>}<br></span><span class="c3">catch</span><span class="c2">&nbsp;(OperationCanceledException)<br>{<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c12">&quot;Opera&#539;iunea a fost &icirc;ntrerupt&#259;&quot;</span><span class="c2">);<br>}<br></span><span class="c3">catch</span><span class="c2">&nbsp;(AggregateException ex)<br>{<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c2">&nbsp;(ex.InnerExceptions != </span><span class="c3">null</span><span class="c2">)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">foreach</span><span class="c2">&nbsp;(Exception e </span><span class="c3">in</span><span class="c2">&nbsp;ex.InnerExceptions)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(e.Message);<br> &nbsp; &nbsp;}<br>}<br></span><span class="c3">finally</span><span class="c2"><br>{<br> &nbsp; &nbsp;cts.Dispose();<br>}<br></span><span class="c3">int</span><span class="c2">&nbsp;</span><span class="c8">Square</span><span class="c2">(</span><span class="c3">int</span><span class="c2">&nbsp;n)<br>{<br> &nbsp; &nbsp;</span><span class="c3">var</span><span class="c2">&nbsp;result = n * n;<br> &nbsp; &nbsp;Console.WriteLine(</span><span class="c12">$&quot;P&#259;tratul num&#259;rului {n} este {result}&quot;</span><span class="c2">);<br> &nbsp; &nbsp;Thread.Sleep(</span><span class="c0">1000</span><span class="c2">); </span><span class="c13">// imita&#539;ia unui calcul de durat&#259;</span><span class="c2"><br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c2">&nbsp;result;<br>}</span></p></td></tr></table><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c5">&Icirc;n sarcina paralel&#259; lansat&#259;, se apeleaz&#259; metoda</span><span class="c5 c18">&nbsp;cts.Cancel()</span><span class="c5">, ceea ce duce la terminarea opera&#539;iunii &#537;i generarea excep&#539;iei </span><span class="c6">OperationCanceledException</span><span class="c1">:</span></p><p class="c4"><span class="c1"></span></p><a id="t.1201dff8a0930d89bcc3ad7df9f3a8e1384b483a"></a><a id="t.2"></a><table class="c11"><tr class="c10"><td class="c14" colspan="1" rowspan="1"><p class="c17"><span class="c2">P&#259;tratul num&#259;rului </span><span class="c0">5</span><span class="c2">&nbsp;este </span><span class="c0">25</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c0">3</span><span class="c2">&nbsp;este </span><span class="c0">9</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c0">1</span><span class="c2">&nbsp;este </span><span class="c0">1</span><span class="c2"><br>P&#259;tratul num&#259;rului </span><span class="c0">7</span><span class="c2">&nbsp;este </span><span class="c0">49</span><span class="c2"><br>Opera&#539;iunea a fost &icirc;ntrerupt&#259;</span></p></td></tr></table><p class="c4"><span class="c1"></span></p><p class="c7"><span class="c1">&Icirc;n acest caz, este de asemenea logic s&#259; se trateze excep&#539;ia AggregateException, deoarece dac&#259; apare o alt&#259; excep&#539;ie &icirc;n paralel, aceasta &#537;i OperationCanceledException sunt plasate &icirc;ntr-un singur obiect AggregateException.</span></p><p class="c4"><span class="c1"></span></p></body></html>