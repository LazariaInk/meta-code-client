[
    {
        "problemId": 1,
        "problemName": "Xerocopii",
        "problemComplexity": "MEDIU",
        "problemTheme": "CAUTARE_BINARA",
        "problemContent": "Secretara Delia a întârziat astăzi la muncă și trebuie să facă urgent până la prânz N copii ale unui document. Ea are la dispoziție două copiatoare, unul care face o copie în x secunde și altul care face o copie în y secunde. (Este permis să folosească fie un singur copiator, fie ambele simultan. De asemenea, se poate face o copie nu doar după original, ci și după o altă copie. Ajutați-o să afle timpul minim necesar pentru a realiza toate copiile.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li><strong>N</strong> - numărul total de copii necesare.</li>\n        <li><strong>x</strong> - timpul în secunde necesar pentru primul copiator.</li>\n        <li><strong>y</strong> - timpul în secunde necesar pentru al doilea copiator.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Timpul minim necesar pentru a face <strong>N</strong> copii.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Ambele copiatoare pot lucra simultan.</li>\n        <li>Este permis să copiezi după copii, nu doar după documentul original.</li>\n        <li>Trebuie să folosim o strategie eficientă pentru a minimiza timpul.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Dacă N = 4, x = 1, y = 2:</strong></p>\n    <ul>\n        <li>Folosind copiatorul mai rapid (<strong>x = 1</strong>), o copie inițială poate fi făcută în <strong>1 secundă</strong>.</li>\n        <li>Celelalte 3 copii pot fi făcute în paralel folosind ambele copiatoare, minimizând timpul total.</li>\n        <li><strong>Răspuns:</strong> 3 secunde.</li>\n    </ul>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Sortează</strong> copiatoarele după timp (<code>x &lt;= y</code>).</li>\n        <li><strong>Generează</strong> copia inițială folosind primul copiator.</li>\n        <li><strong>Folosim căutare binară</strong> pentru a determina timpul minim în care putem obține <strong>N</strong> copii:\n            <div style=\"background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 5px;\">\n                <code>\n                    Copii produse = ⌊t / x⌋ + ⌊t / y⌋\n                </code>\n            </div>\n        </li>\n        <li>Dacă suma este cel puțin <strong>N</strong>, încercăm un timp mai mic (pentru a optimiza).</li>\n        <li>Dacă suma este mai mică decât <strong>N</strong>, creștem timpul.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p>\n        <code>O(log(T))</code>, unde <code>T</code> este limita superioară estimată a timpului.\n    </p>\n</div>"
    },
    {
        "problemId": 2,
        "problemName": "Roman în Tomuri",
        "problemComplexity": "MEDIU",
        "problemTheme": "CAUTARE_BINARA",
        "problemContent": "Un roman conține <strong>N</strong> capitole. Al <strong>i-lea</strong> capitol are <strong>a[i]</strong> pagini. Este necesar să publicăm romanul în <strong>K</strong> tomuri astfel încât volumul celui mai «gros» tom să fie minim. Fiecare tom conține capitole în ordinea lor numerică. Scrieți un program care determină numărul de pagini din cel mai «gros» tom.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li><strong>N</strong> - numărul total de capitole din roman.</li>\n        <li><strong>K</strong> - numărul total de tomuri.</li>\n        <li><strong>a[i]</strong> - numărul de pagini din fiecare capitol <code>i</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Numărul minim de pagini în cel mai «gros» tom.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Toate capitolele dintr-un tom trebuie să fie consecutive.</li>\n        <li>Trebuie să împărțim capitolele în <strong>K</strong> tomuri astfel încât volumul maxim al unui tom să fie minimizat.</li>\n        <li>Folosim căutare binară pentru a rezolva problema eficient.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Dacă N = 4, K = 2, a = [100, 200, 300, 400]:</strong></p>\n    <ul>\n        <li>Cel mai bun mod de a împărți romanul este:</li>\n        <li>Primul tom conține capitolele 1 și 2 (300 pagini).</li>\n        <li>Al doilea tom conține capitolele 3 și 4 (700 pagini).</li>\n        <li><strong>Răspuns:</strong> 700 pagini (volumul maxim al unui tom).</li>\n    </ul>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Determinăm intervalul de căutare binară:</li>\n        <ul>\n            <li>Limita inferioară: cel mai mare capitol (<code>max(a[i])</code>).</li>\n            <li>Limita superioară: suma tuturor capitolelor (<code>sum(a[i])</code>).</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Verificăm dacă putem împărți capitolele în <strong>K</strong> tomuri, astfel încât fiecare tom să aibă cel mult <strong>t</strong> pagini.</li>\n        <li><strong>Pas 3:</strong> Dacă este posibil, încercăm o valoare mai mică pentru <strong>t</strong> (optimizăm). Dacă nu, creștem <strong>t</strong>.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(N * log(S))</code>, unde <code>S = sum(a[i])</code> este suma tuturor paginilor.</p>\n</div>"
    },
    {
        "problemId": 3,
        "problemName": "Diplome",
        "problemComplexity": "MEDIU",
        "problemTheme": "CAUTARE_BINARA",
        "problemContent": "Petru a participat în timpul școlii la olimpiade de informatică, matematică și fizică. Deoarece era un băiat talentat și harnic, a câștigat <strong>n</strong> diplome. Toate diplomele au aceeași dimensiune: <strong>w</strong> în lățime și <strong>h</strong> în înălțime. Acum, fiind student la o universitate de prestigiu, Petru locuiește în cămin și dorește să decoreze camera sa, agățând diplomele pe un perete. Pentru a ușura fixarea pe peretele din beton, el a decis să folosească o placă pătrată din lemn de plută, pe care să o prindă de perete și să aranjeze diplomele pe aceasta. Placa trebuie să fie pătrată și să ocupe cât mai puțin spațiu. Fiecare diplomă trebuie să fie plasată într-un dreptunghi de dimensiuni <strong>w</strong> x <strong>h</strong>. Dreptunghiurile nu trebuie să se suprapună. Scrieți un program care calculează dimensiunea minimă a unei laturi a plăcii necesare pentru a aranja toate diplomele.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li><strong>n</strong> - numărul total de diplome.</li>\n        <li><strong>w</strong> - lățimea fiecărei diplome.</li>\n        <li><strong>h</strong> - înălțimea fiecărei diplome.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Dimensiunea minimă a unei laturi a plăcii pătrate necesare pentru a aranja diplomele.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Toate diplomele trebuie să fie aranjate fără suprapuneri.</li>\n        <li>Placa trebuie să fie pătrată, iar dimensiunea laturii să fie cât mai mică.</li>\n        <li>Folosim căutare binară pentru a determina dimensiunea optimă a laturii plăcii.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Dacă n = 10, w = 2, h = 3:</strong></p>\n    <ul>\n        <li>Pentru o placă cu latura <strong>L = 6</strong>, nu putem aranja toate diplomele.</li>\n        <li>Pentru o placă cu latura <strong>L = 12</strong>, diplomele pot fi aranjate pe 2 rânduri și 5 coloane.</li>\n        <li><strong>Răspuns:</strong> Latura minimă a plăcii este 12.</li>\n    </ul>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Determinăm intervalul de căutare binară:</li>\n        <ul>\n            <li>Limita inferioară: <code>max(w, h)</code> (dimensiunea minimă necesară pentru o diplomă).</li>\n            <li>Limita superioară: <code>sqrt(n) * max(w, h)</code> (dacă diplomele sunt puse într-o matrice ideală).</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Verificăm dacă putem aranja diplomele pe o placă cu latura <strong>L</strong>:</li>\n        <ul>\n            <li>Calculăm câte diplome încap pe fiecare rând: <code>L / w</code>.</li>\n            <li>Calculăm câte rânduri încap: <code>L / h</code>.</li>\n            <li>Produsul celor două valori trebuie să fie cel puțin <strong>n</strong>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Ajustăm latura <strong>L</strong> folosind căutarea binară:</li>\n        <ul>\n            <li>Dacă diplomele încap, încercăm o valoare mai mică pentru <strong>L</strong>.</li>\n            <li>Altfel, creștem valoarea <strong>L</strong>.</li>\n        </ul>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n * log(L))</code>, unde <code>L</code> este dimensiunea maximă estimată a laturii.</p>\n</div>"
    },
    {
        "problemId": 4,
        "problemName": "Vile",
        "problemComplexity": "MEDIU",
        "problemTheme": "GEOMETRIE",
        "problemContent": "Unii oameni excentrici decid să-și construiască vile în locuri îndepărtate și greu accesibile, pe insule izolate. Ajung acolo cu avionul, iar deoarece insulele nu au piste de aterizare, trebuie să sară cu parașuta. Fiecare persoană dorește să aterizeze cât mai aproape de terenul pe care își construiește vila dreptunghiulară. Pilotul, însă, dorește să organizeze aterizările astfel încât fiecare persoană să ajungă pe terenul său. Este curios să știe câți oameni vor ateriza exact pe propriile lor terenuri. Ajutați pilotul să rezolve această problemă!",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li><strong>N</strong> - numărul total de persoane.</li>\n        <li>Fiecare persoană are coordonatele punctului unde aterizează: <code>(x[i], y[i])</code>.</li>\n        <li>Fiecare teren este un dreptunghi definit de colțurile opuse: <code>(x1[j], y1[j])</code> și <code>(x2[j], y2[j])</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Numărul de persoane care aterizează exact pe terenurile lor.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Fiecare persoană are un teren propriu.</li>\n        <li>O persoană este considerată că a aterizat pe propriul teren dacă punctul său <code>(x[i], y[i])</code> se află în interiorul sau pe marginea dreptunghiului asociat.</li>\n        <li>Folosim verificări geometrice simple pentru a determina dacă un punct aparține unui dreptunghi.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Dacă N = 3, coordonatele sunt:</strong></p>\n    <ul>\n        <li>Persoana 1 aterizează la <code>(2, 3)</code>, iar terenul său este delimitat de <code>(1, 2)</code> și <code>(4, 5)</code>.</li>\n        <li>Persoana 2 aterizează la <code>(6, 7)</code>, iar terenul său este delimitat de <code>(5, 6)</code> și <code>(8, 9)</code>.</li>\n        <li>Persoana 3 aterizează la <code>(10, 11)</code>, iar terenul său este delimitat de <code>(0, 0)</code> și <code>(9, 12)</code>.</li>\n    </ul>\n    <p><strong>Răspuns:</strong> 2 persoane aterizează pe terenurile lor (primele două).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Pentru fiecare persoană, verificăm dacă punctul său <code>(x[i], y[i])</code> se află în dreptunghiul său:</li>\n        <ul>\n            <li>Un punct <code>(x[i], y[i])</code> este în dreptunghi dacă:</li>\n            <li><code>x1[j] &lt;= x[i] &lt;= x2[j]</code> și <code>y1[j] &lt;= y[i] &lt;= y2[j]</code>.</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Numărăm persoanele care respectă această condiție.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(N)</code>, unde <code>N</code> este numărul de persoane.</p>\n</div>"
    },
    {
        "problemId": 5,
        "problemName": "Lungimea unui Segment",
        "problemComplexity": "USOR",
        "problemTheme": "GEOMETRIE",
        "problemContent": "Un segment este definit prin coordonatele extremităților sale: <code>(x1, y1)</code> și <code>(x2, y2)</code>. Este necesar să se calculeze lungimea acestui segment.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Coordonatele primului punct: <code>(x1, y1)</code>.</li>\n        <li>Coordonatele celui de-al doilea punct: <code>(x2, y2)</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Lungimea segmentului definit de cele două puncte.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Lungimea unui segment poate fi calculată folosind formula distanței euclidiene între cele două puncte:</li>\n        <li>\n            <code>L = sqrt((x2 - x1)^2 + (y2 - y1)^2)</code>\n        </li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Dacă coordonatele sunt:</strong></p>\n    <ul>\n        <li><code>(x1, y1) = (0, 0)</code></li>\n        <li><code>(x2, y2) = (3, 4)</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>\n            <code>L = sqrt((3 - 0)^2 + (4 - 0)^2) = sqrt(9 + 16) = sqrt(25) = 5</code>\n        </li>\n    </ul>\n    <p><strong>Răspuns:</strong> 5</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Citim coordonatele punctelor: <code>(x1, y1)</code> și <code>(x2, y2)</code>.</li>\n        <li><strong>Pas 2:</strong> Calculăm pătratul diferențelor:</li>\n        <ul>\n            <li>\n                <code>(x2 - x1)^2</code>\n            </li>\n            <li>\n                <code>(y2 - y1)^2</code>\n            </li>\n        </ul>\n        <li><strong>Pas 3:</strong> Adunăm cele două valori calculate și aplicăm rădăcina pătrată:</li>\n        <ul>\n            <li>\n                <code>L = sqrt((x2 - x1)^2 + (y2 - y1)^2)</code>\n            </li>\n        </ul>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(1)</code>, deoarece calculul este constant și nu depinde de dimensiunea datelor de intrare.</p>\n</div>"
    },
    {
        "problemId": 6,
        "problemName": "Aria unui Triunghi",
        "problemComplexity": "USOR",
        "problemTheme": "GEOMETRIE",
        "problemContent": "Se dau coordonatele întregi ale vârfurilor unui triunghi: <code>(x1, y1)</code>, <code>(x2, y2)</code> și <code>(x3, y3)</code>. Este necesar să se calculeze aria triunghiului.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Coordonatele primului vârf: <code>(x1, y1)</code>.</li>\n        <li>Coordonatele celui de-al doilea vârf: <code>(x2, y2)</code>.</li>\n        <li>Coordonatele celui de-al treilea vârf: <code>(x3, y3)</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Aria triunghiului definit de cele trei vârfuri.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Aria unui triunghi poate fi calculată folosind formula determinantului:</li>\n        <li>\n            <code>Aria = |(x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)) / 2|</code>\n        </li>\n        <li>Rezultatul trebuie să fie pozitiv, deoarece aria nu poate fi negativă.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Dacă coordonatele sunt:</strong></p>\n    <ul>\n        <li><code>(x1, y1) = (0, 0)</code></li>\n        <li><code>(x2, y2) = (4, 0)</code></li>\n        <li><code>(x3, y3) = (0, 3)</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>\n            <code>Aria = |(0 * (0 - 3) + 4 * (3 - 0) + 0 * (0 - 0)) / 2|</code>\n        </li>\n        <li>\n            <code>Aria = |(0 + 12 + 0) / 2| = |12 / 2| = 6</code>\n        </li>\n    </ul>\n    <p><strong>Răspuns:</strong> 6</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Citim coordonatele vârfurilor: <code>(x1, y1)</code>, <code>(x2, y2)</code>, <code>(x3, y3)</code>.</li>\n        <li><strong>Pas 2:</strong> Aplicăm formula determinantului pentru a calcula aria:</li>\n        <ul>\n            <li>\n                <code>Aria = |(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2|</code>\n            </li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm valoarea absolută a rezultatului.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(1)</code>, deoarece calculul este constant și nu depinde de dimensiunea datelor de intrare.</p>\n</div>"
    },
    {
        "problemId": 7,
        "problemName": "Mihai și Negativul",
        "problemComplexity": "USOR",
        "problemTheme": "MASIV_PATRAT",
        "problemContent": "Mihai a învățat să fotografieze bine și recent a devenit pasionat de programare. Prima sa aplicație generează negativul unei imagini binare alb-negru. O imagine binară alb-negru este un dreptunghi format din pixeli, fiecare fiind fie negru (0), fie alb (1). Negativul imaginii este obținut prin inversarea fiecărui pixel: un pixel negru devine alb, iar un pixel alb devine negru. Totuși, aplicația lui Mihai conține o eroare, iar negativul generat poate să nu fie corect. Pentru a verifica nivelul de eroare, Mihai analizează rezultatul și determină numărul de pixeli greșiți comparând imaginea originală cu negativul generat. Scrieți un program care determină numărul de erori din negativul generat, pe baza unei imagini binare și a negativului său.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Dimensiunile imaginii: <code>n</code> (număr de rânduri) și <code>m</code> (număr de coloane).</li>\n        <li>O matrice <code>original[n][m]</code>, care reprezintă imaginea originală binară.</li>\n        <li>O matrice <code>negative[n][m]</code>, care reprezintă negativul generat de aplicația lui Mihai.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Numărul total de erori (pixeli unde <code>negative[i][j]</code> nu este inversul lui <code>original[i][j]</code>).</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Un pixel este considerat greșit dacă:</li>\n        <li>\n            <code>original[i][j] == negative[i][j]</code>\n        </li>\n        <li>Rezultatul trebuie să fie suma tuturor astfel de erori din matrice.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 3</code>, <code>m = 3</code></li>\n        <li><code>original = [[0, 1, 0], [1, 0, 1], [0, 1, 1]]</code></li>\n        <li><code>negative = [[1, 0, 1], [0, 1, 0], [0, 0, 1]]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Comparații pixel cu pixel:</li>\n        <li>\n            <code>(0 != 1)</code> corect, <code>(1 != 0)</code> corect, <code>(0 != 1)</code> corect\n        </li>\n        <li>\n            <code>(1 != 0)</code> corect, <code>(0 != 1)</code> corect, <code>(1 != 0)</code> corect\n        </li>\n        <li>\n            <code>(0 != 0)</code> greșit, <code>(1 != 0)</code> greșit, <code>(1 != 1)</code> greșit\n        </li>\n    </ul>\n    <p><strong>Erori totale:</strong> 3</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Citim dimensiunile <code>n</code> și <code>m</code>.</li>\n        <li><strong>Pas 2:</strong> Parcurgem fiecare pixel din matricele <code>original</code> și <code>negative</code>.</li>\n        <ul>\n            <li>Dacă <code>original[i][j] == negative[i][j]</code>, incrementăm contorul de erori.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm numărul total de erori.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n * m)</code>, unde <code>n</code> și <code>m</code> sunt dimensiunile matricei.</p>\n</div>"
    },
    {
        "problemId": 8,
        "problemName": "Spirală",
        "problemComplexity": "MEDIU",
        "problemTheme": "MASIV_PATRAT",
        "problemContent": "Se cere generarea unui pătrat de dimensiune <code>N × N</code>, în care celulele sunt umplute cu numere de la 1 la <code>N^2</code>, în ordine crescătoare, într-o formă spiralată (vezi exemplu).",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li><code>N</code> - dimensiunea pătratului (<code>N × N</code>).</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>O matrice pătrată de dimensiune <code>N × N</code>, umplută în spirală cu numere de la 1 la <code>N^2</code>.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Numerotarea începe de la 1 și continuă până la <code>N^2</code>.</li>\n        <li>Celulele sunt completate într-o spirală care începe din colțul stânga-sus și se deplasează în sensul acelor de ceasornic.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong> <code>N = 3</code></p>\n    <p><strong>Output:</strong></p>\n    <pre>\n    1 2 3\n    8 9 4\n    7 6 5\n    </pre>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm o matrice <code>N × N</code> cu 0.</li>\n        <li><strong>Pas 2:</strong> Definim limitele inițiale:</li>\n        <ul>\n            <li>Rânduri: <code>top = 0</code>, <code>bottom = N - 1</code>.</li>\n            <li>Coloane: <code>left = 0</code>, <code>right = N - 1</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Umplem matricea în spirală:</li>\n        <ul>\n            <li>Umplem linia de sus de la <code>left</code> la <code>right</code> și incrementăm <code>top</code>.</li>\n            <li>Umplem coloana din dreapta de la <code>top</code> la <code>bottom</code> și decrementăm <code>right</code>.</li>\n            <li>Umplem linia de jos de la <code>right</code> la <code>left</code> (dacă mai există) și decrementăm <code>bottom</code>.</li>\n            <li>Umplem coloana din stânga de la <code>bottom</code> la <code>top</code> (dacă mai există) și incrementăm <code>left</code>.</li>\n        </ul>\n        <li><strong>Pas 4:</strong> Repetăm pașii de mai sus până când toate celulele sunt completate.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(N^2)</code>, deoarece completăm fiecare celulă o singură dată.</p>\n</div>"
    },
    {
        "problemId": 9,
        "problemName": "Decor Simpatic",
        "problemComplexity": "USOR",
        "problemTheme": "MASIV_PATRAT",
        "problemContent": "Ionel și-a decorat recent holul cu gresie formată din plăci pătrate albe și negre. Holul are o formă pătrată de <code>4 × 4</code>, conținând în total 16 plăci. Acum Ion este îngrijorat că decorul său poate să nu fie simpatic. Un decor este considerat simpatic dacă nu conține niciun sub-pătrat de <code>2 × 2</code> format din plăci de aceeași culoare. Ajutați-l pe Ion să verifice dacă decorul său este simpatic.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>O matrice <code>4 × 4</code> formată din valori <code>0</code> (negru) și <code>1</code> (alb).</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un răspuns: <code>DA</code>, dacă decorul este simpatic, sau <code>NU</code>, dacă conține un sub-pătrat de <code>2 × 2</code> cu plăci de aceeași culoare.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Verificăm toate sub-pătratele de <code>2 × 2</code> din matricea de intrare.</li>\n        <li>Un sub-pătrat <code>2 × 2</code> este considerat nesimpatic dacă toate cele patru valori din matrice sunt egale:</li>\n        <li>\n            <code>grid[i][j] == grid[i][j+1] == grid[i+1][j] == grid[i+1][j+1]</code>\n        </li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <pre>\n    0 1 0 1\n    1 0 1 0\n    0 1 0 1\n    1 0 1 0\n    </pre>\n    <p><strong>Output:</strong> <code>DA</code> (decorul este simpatic).</p>\n    <h4>Exemplu 2:</h4>\n    <p><strong>Input:</strong></p>\n    <pre>\n    1 1 0 0\n    1 1 0 0\n    0 0 1 1\n    0 0 1 1\n    </pre>\n    <p><strong>Output:</strong> <code>NU</code> (există sub-pătrate nesimpatice).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Parcurgem matricea și verificăm toate sub-pătratele de <code>2 × 2</code>:</li>\n        <ul>\n            <li>Verificăm toate combinațiile posibile de <code>i</code> și <code>j</code>, unde <code>0 ≤ i, j ≤ 2</code>.</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Pentru fiecare poziție <code>(i, j)</code>, verificăm condiția:</li>\n        <ul>\n            <li>\n                <code>grid[i][j] == grid[i][j+1] == grid[i+1][j] == grid[i+1][j+1]</code>\n            </li>\n        </ul>\n        <li><strong>Pas 3:</strong> Dacă găsim un sub-pătrat nesimpatic, returnăm <code>NU</code>.</li>\n        <li><strong>Pas 4:</strong> Dacă nicio condiție nu este încălcată, returnăm <code>DA</code>.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n × m)</code>, unde <code>n</code> și <code>m</code> sunt dimensiunile matricei (în acest caz, 4 × 4).</p>\n</div>"
    },
    {
        "problemId": 10,
        "problemName": "Pizza",
        "problemComplexity": "USOR",
        "problemTheme": "PROGRAMARE_DINAMICA",
        "problemContent": "Pizza este deliciul preferat al lui Vasile. Îi place să cumpere și să savureze diferite sortimente ale acestui preparat delicios. Într-o zi, tăind o pizza rotundă în mai multe felii, Vasile s-a întrebat: în câte bucăți poate fi tăiată o pizza folosind <code>N</code> tăieturi drepte? Ajutați-l pe Vasile să rezolve această problemă și să determine numărul maxim de bucăți de pizza pe care le poate obține.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li><code>N</code> - numărul de tăieturi drepte.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Numărul maxim de bucăți de pizza obținute.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Fiecare tăietură dreaptă poate împărți anterior toate bucățile existente.</li>\n        <li>Numărul maxim de bucăți de pizza, după <code>N</code> tăieturi, este dat de formula:</li>\n        <li>\n            <code>P(N) = 1 + N + N * (N - 1) / 2</code>\n        </li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong> <code>N = 3</code></p>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li><code>P(3) = 1 + 3 + 3 * (3 - 1) / 2</code></li>\n        <li><code>P(3) = 1 + 3 + 3 * 2 / 2</code></li>\n        <li><code>P(3) = 1 + 3 + 3 = 7</code></li>\n    </ul>\n    <p><strong>Output:</strong> 7 bucăți</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Calculăm numărul maxim de bucăți folosind formula:</li>\n        <ul>\n            <li>\n                <code>P(N) = 1 + N + N * (N - 1) / 2</code>\n            </li>\n        </ul>\n        <li><strong>Pas 2:</strong> Returnăm valoarea calculată.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(1)</code>, deoarece calculul se face în timp constant, folosind formula matematică.</p>\n</div>"
    },
    {
        "problemId": 11,
        "problemName": "Doar la Dreapta sau în Jos",
        "problemComplexity": "USOR",
        "problemTheme": "PROGRAMARE_DINAMICA",
        "problemContent": "Un teren de joc de dimensiune <code>N × M</code> este completat cu numere întregi, fiecare celulă conținând un număr întreg nenegativ. Scopul jocului este de a găsi un drum de la colțul stânga-sus până la colțul dreapta-jos. Fiecare celulă indică lungimea pasului care poate fi făcut din acea celulă. Toți pașii trebuie să fie fie la dreapta, fie în jos. Dacă un pas iese din limitele terenului, acesta este interzis.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Dimensiunile terenului de joc: <code>N</code> (număr de rânduri) și <code>M</code> (număr de coloane).</li>\n        <li>O matrice <code>grid[N][M]</code>, unde fiecare celulă conține lungimea pasului.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un drum valid de la colțul stânga-sus la colțul dreapta-jos, dacă acesta există.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Se poate face un pas fie la dreapta, fie în jos.</li>\n        <li>Dintr-o celulă <code>(i, j)</code>, pasul trebuie să fie exact de lungimea indicată în acea celulă.</li>\n        <li>Pașii care duc în afara matricei sunt interziși.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>N = 3</code>, <code>M = 4</code></li>\n        <li><code>grid = [[2, 1, 1, 1], [1, 1, 2, 1], [1, 1, 1, 0]]</code></li>\n    </ul>\n    <p><strong>Output:</strong> <code>DA</code> (drumul există).</p>\n    <p><strong>Exemplu Drumul:</strong></p>\n    <pre>\n    2 → 1 → 1\n              ↓\n    1 → 1     2\n              ↓\n    1 → 1 → 1\n    </pre>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm o matrice de vizitare <code>visited[N][M]</code>, toate valorile fiind inițial false.</li>\n        <li><strong>Pas 2:</strong> Folosim un algoritm de tip BFS (Breadth-First Search) pentru a explora toate drumurile posibile:</li>\n        <ul>\n            <li>Începem din celula <code>(0, 0)</code>.</li>\n            <li>Pentru fiecare celulă curentă <code>(i, j)</code>, calculăm următoarele celule:</li>\n            <ul>\n                <li><code>(i, j + grid[i][j])</code> - pas la dreapta.</li>\n                <li><code>(i + grid[i][j], j)</code> - pas în jos.</li>\n            </ul>\n            <li>Adăugăm celulele valabile la coada de explorare și le marcăm ca vizitate.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Dacă ajungem la celula <code>(N-1, M-1)</code>, returnăm <code>DA</code>.</li>\n        <li><strong>Pas 4:</strong> Dacă nu mai există celule de explorat și nu am ajuns la final, returnăm <code>NU</code>.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(N × M)</code>, deoarece explorăm fiecare celulă o singură dată.</p>\n</div>"
    },
    {
        "problemId": 12,
        "problemName": "Este oare viață pe Marte?",
        "problemComplexity": "MEDIU",
        "problemTheme": "PROGRAMARE_DINAMICA",
        "problemContent": "Un grup de prieteni discută despre o afirmație legată de existența vieții pe Marte, care provine de la profesorul lor de biologie, Vladimir Alekseevici. Informația este transmisă în lanț prin intermediul a <code>n</code> persoane, fiecare având o probabilitate <code>pi</code> de a transmite informația corect și <code>qi = 1 - pi</code> de a o distorsiona. Problema constă în a determina probabilitatea ca informația transmisă de ultima persoană să reflecte adevărul spus de Vladimir Alekseevici. Adevărul rămâne intact dacă numărul de distorsiuni este par. Ajutați-i pe prieteni să determine această probabilitate pentru orice număr de persoane <code>n</code>.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Numărul de persoane <code>n</code> care transmit informația.</li>\n        <li>Probabilitățile <code>p1, p2, ..., pn</code>, unde <code>pi</code> este probabilitatea ca persoana <code>i</code> să transmită informația corect.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Probabilitatea ca informația transmisă de ultima persoană să reflecte adevărul spus inițial de Vladimir Alekseevici.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>O informație este considerată corectă dacă numărul de distorsiuni (negări) aplicate este par.</li>\n        <li>Formula recursivă pentru probabilitatea de a menține adevărul la persoana <code>k</code> este:</li>\n        <li>\n            <code>T(k) = pk * T(k-1) + qk * (1 - T(k-1))</code>\n        </li>\n        <li>Unde <code>qk = 1 - pk</code>.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 3</code></li>\n        <li><code>p1 = 0.9, p2 = 0.8, p3 = 0.7</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li><code>T(1) = p1 = 0.9</code></li>\n        <li><code>T(2) = p2 * T(1) + q2 * (1 - T(1))</code></li>\n        <li><code>T(2) = 0.8 * 0.9 + 0.2 * (1 - 0.9) = 0.8 * 0.9 + 0.2 * 0.1 = 0.72 + 0.02 = 0.74</code></li>\n        <li><code>T(3) = p3 * T(2) + q3 * (1 - T(2))</code></li>\n        <li><code>T(3) = 0.7 * 0.74 + 0.3 * (1 - 0.74) = 0.7 * 0.74 + 0.3 * 0.26 = 0.518 + 0.078 = 0.596</code></li>\n    </ul>\n    <p><strong>Output:</strong> Probabilitatea ca informația să reflecte adevărul este <code>0.596</code>.</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm <code>T(0) = 1</code> (informația este complet adevărată la sursă).</li>\n        <li><strong>Pas 2:</strong> Iterăm de la <code>k = 1</code> la <code>n</code>, calculând:</li>\n        <ul>\n            <li><code>T(k) = pk * T(k-1) + qk * (1 - T(k-1))</code>, unde <code>qk = 1 - pk</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm <code>T(n)</code>, probabilitatea ca ultima persoană să reflecte adevărul.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n)</code>, unde <code>n</code> este numărul de persoane care transmit informația.</p>\n</div>"
    },
    {
        "problemId": 13,
        "problemName": "Tehnologia Programării",
        "problemComplexity": "GREU",
        "problemTheme": "ALGORITMUL_LACOM",
        "problemContent": "Tolik a inventat o nouă tehnologie de programare și dorește să-și convingă prietenii să o folosească. Totuși, nu este atât de simplu. Al <code>i-lea</code> prieten va accepta să folosească tehnologia lui Tolik dacă autoritatea lui Tolik este cel puțin <code>ai</code>. După ce prietenul acceptă, autoritatea lui Tolik va crește cu <code>bi</code> (există prieteni pentru care <code>bi &lt; 0</code>). Ajutați-l pe Tolik să convingă cât mai mulți prieteni să folosească tehnologia sa.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Numărul de prieteni: <code>n</code>.</li>\n        <li>Două liste:</li>\n        <ul>\n            <li><code>ai</code> - autoritatea minimă necesară pentru a convinge prietenul <code>i</code>.</li>\n            <li><code>bi</code> - schimbarea autorității lui Tolik după ce prietenul <code>i</code> acceptă.</li>\n        </ul>\n        <li>Autoritatea inițială a lui Tolik: <code>S</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Numărul maxim de prieteni pe care Tolik îi poate convinge.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Autoritatea lui Tolik trebuie să fie cel puțin <code>ai</code> pentru a convinge prietenul <code>i</code>.</li>\n        <li>Prieteni cu <code>bi &lt; 0</code> pot scădea autoritatea lui Tolik, deci trebuie abordați cu grijă.</li>\n        <li>Ordinea în care Tolik încearcă să convingă prietenii este importantă.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li><strong>Prieteni cu <code>bi &gt;= 0</code>:</strong> Sortăm crescător după <code>ai</code> și îi abordăm mai întâi, deoarece nu scad autoritatea lui Tolik.</li>\n        <li><strong>Prieteni cu <code>bi &lt; 0</code>:</strong> Sortăm descrescător după <code>ai</code> (dificultatea) și îi abordăm doar dacă autoritatea actuală permite acest lucru.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 4</code>, <code>S = 10</code></li>\n        <li><code>ai = [5, 15, 10, 20]</code></li>\n        <li><code>bi = [10, -5, 5, -10]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Prieteni cu <code>bi &gt;= 0</code>: Sortăm după <code>ai</code> - <code>(5, 10)</code>.</li>\n        <li>Prieteni cu <code>bi &lt; 0</code>: Sortăm descrescător după <code>ai</code> - <code>(20, 15)</code>.</li>\n        <li>Abordare:</li>\n        <ul>\n            <li>Convingem prietenul 1 (creștere +10, autoritate devine 20).</li>\n            <li>Convingem prietenul 3 (creștere +5, autoritate devine 25).</li>\n            <li>Convingem prietenul 4 (scădere -10, autoritate devine 15).</li>\n            <li>Convingem prietenul 2 (scădere -5, autoritate devine 10).</li>\n        </ul>\n    </ul>\n    <p><strong>Output:</strong> 4 (toți prietenii convinși).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Împărțim prietenii în două grupuri:</li>\n        <ul>\n            <li><code>bi &gt;= 0</code> - prieteni care cresc autoritatea.</li>\n            <li><code>bi &lt; 0</code> - prieteni care scad autoritatea.</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Sortăm fiecare grup:</li>\n        <ul>\n            <li>Pentru <code>bi &gt;= 0</code>: Sortăm crescător după <code>ai</code>.</li>\n            <li>Pentru <code>bi &lt; 0</code>: Sortăm descrescător după <code>ai</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Convingem prietenii în ordinea sortată, actualizând autoritatea lui Tolik la fiecare pas.</li>\n        <li><strong>Pas 4:</strong> Returnăm numărul total de prieteni convinși.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n log n)</code>, datorită sortării celor două grupuri.</p>\n</div>"
    },
    {
        "problemId": 14,
        "problemName": "Uscătorul",
        "problemComplexity": "GREU",
        "problemTheme": "ALGORITMUL_LACOM",
        "problemContent": "Tanti Luba tocmai a spălat toate hainele și acum are o sarcină dificilă - cum să le usuce astfel încât niciuna dintre ele să nu se strice. După spălare, hainele au o umiditate inițială <code>wi</code>. Dacă sunt uscate pe sfoară, umiditatea scade cu 1 pe minut. Dacă sunt uscate pe radiator, umiditatea scade cu <code>r</code> pe minut (dacă <code>wi &lt; r</code>, atunci devine <code>0</code>). Există suficiente sfori pentru a usca toate hainele simultan, dar radiatorul este mic și poate usca doar un singur articol la un moment dat. Fiecare haină <code>i</code> se strică dacă nu este complet uscată în timpul <code>di</code>. Ajutați-o pe tanti Luba să stabilească un plan pentru a decide ce haină să pună pe radiator și când.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Numărul de articole: <code>n</code>.</li>\n        <li>Lista umidităților inițiale: <code>wi</code> (pentru fiecare articol <code>i</code>).</li>\n        <li>Lista timpilor maxim disponibili până când fiecare articol <code>i</code> se strică: <code>di</code>.</li>\n        <li>Rata de uscare pe radiator: <code>r</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un plan care să indice ordinea în care articolele trebuie uscate pe radiator astfel încât toate să fie uscate complet.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Articolele pot fi uscate simultan pe sfoară, dar doar unul poate fi pe radiator.</li>\n        <li>Fiecare articol trebuie să fie complet uscat (umiditate 0) înainte de expirarea timpului său maxim <code>di</code>.</li>\n        <li>Ordinea articolelor pe radiator este crucială pentru a evita stricarea hainelor.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Calculăm timpul necesar pentru ca fiecare articol să se usuce complet:</li>\n        <ul>\n            <li>Pe sfoară: <code>time_line[i] = wi</code>.</li>\n            <li>Pe radiator: <code>time_radiator[i] = ceil(wi / r)</code>.</li>\n        </ul>\n        <li>Sortează articolele crescător după <code>di</code> pentru a procesa mai întâi hainele cu termene limită mai stricte.</li>\n        <li>Procesăm fiecare articol:</li>\n        <ul>\n            <li>Verificăm dacă poate fi uscat complet pe sfoară până la <code>di</code>. Dacă da, îl lăsăm pe sfoară.</li>\n            <li>Altfel, planificăm uscarea sa pe radiator, luând în considerare timpul necesar pentru uscarea articolelor anterioare.</li>\n        </ul>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 3</code></li>\n        <li><code>wi = [5, 10, 6]</code></li>\n        <li><code>di = [7, 12, 8]</code></li>\n        <li><code>r = 3</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Articol 1: <code>time_line[1] = 5</code>, <code>time_radiator[1] = 2</code>.</li>\n        <li>Articol 2: <code>time_line[2] = 10</code>, <code>time_radiator[2] = 4</code>.</li>\n        <li>Articol 3: <code>time_line[3] = 6</code>, <code>time_radiator[3] = 2</code>.</li>\n    </ul>\n    <p>Sortează după <code>di</code>: ordine inițială = 1, 3, 2.</p>\n    <p>Plan:</p>\n    <ul>\n        <li>Articol 1: Lăsat pe sfoară (timp suficient).</li>\n        <li>Articol 3: Radiator (2 minute).</li>\n        <li>Articol 2: Radiator (4 minute).</li>\n    </ul>\n    <p><strong>Output:</strong> Toate articolele sunt uscate complet.</p>\n    <h4>Complexitate:</h4>\n    <p><code>O(n log n)</code>, datorită sortării, plus timpul de procesare al fiecărui articol.</p>\n</div>"
    },
    {
        "problemId": 15,
        "problemName": "Olimpiada",
        "problemComplexity": "FOARTE_USOR",
        "problemTheme": "INCEPATORI",
        "problemContent": "Trei studenți – un student din anul 5, un student din anul 3 și unul din anul 1 – participă la o olimpiadă de programare ACM. Fiecare student are o strategie diferită pentru rezolvarea problemelor: \n<ul>\n<li>Studentul din anul 5 rezolvă problemele în ordine strictă (prima, a doua, ..., ultima).</li>\n<li>Studentul din anul 3 rezolvă problemele în ordine inversă (ultima, penultima, ..., prima).</li>\n<li>Studentul din anul 1 începe cu cea mai simplă problemă (cea care necesită cel mai puțin timp) și continuă cu următoarea cea mai simplă dintre cele rămase.</li>\n</ul>\nScopul este să determinați cine câștigă competiția. Conform regulilor ACM, câștigătorul este studentul care rezolvă cele mai multe probleme în 300 de minute. În caz de egalitate, câștigătorul este cel care are cel mai mic timp de penalizare. Dacă și timpul de penalizare este egal, câștigătorul este studentul mai tânăr (anul mai mic).",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Numărul total de probleme: <code>n</code>.</li>\n        <li>Lista timpilor de rezolvare a problemelor: <code>t[i]</code>, unde <code>t[i]</code> este timpul necesar pentru problema <code>i</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Numele studentului câștigător: \"Anul 1\", \"Anul 3\", sau \"Anul 5\".</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Fiecare student încearcă să rezolve cât mai multe probleme în <code>300</code> minute.</li>\n        <li>La fiecare problemă rezolvată, timpul total crește cu timpul necesar pentru acea problemă.</li>\n        <li>Penalizarea totală se calculează ca suma timpilor de rezolvare până la fiecare problemă trimisă.</li>\n        <li>În caz de egalitate la numărul de probleme rezolvate și penalizare, câștigă studentul mai tânăr (anul mai mic).</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 5</code></li>\n        <li><code>t = [50, 40, 30, 20, 10]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li><strong>Anul 5:</strong> Rezolvă problemele în ordine: <code>[50, 40, 30, 20, 10]</code>. Rezolvă 4 probleme în 140 de minute, penalizare = <code>50 + 90 + 120 + 140 = 400</code>.</li>\n        <li><strong>Anul 3:</strong> Rezolvă problemele în ordine inversă: <code>[10, 20, 30, 40, 50]</code>. Rezolvă 4 probleme în 140 de minute, penalizare = <code>10 + 30 + 60 + 100 = 200</code>.</li>\n        <li><strong>Anul 1:</strong> Rezolvă problemele în ordine crescătoare a timpului: <code>[10, 20, 30, 40, 50]</code>. Rezolvă 4 probleme în 140 de minute, penalizare = <code>10 + 30 + 60 + 100 = 200</code>.</li>\n    </ul>\n    <p><strong>Output:</strong> \"Anul 1\" (tânărul câștigă în caz de egalitate).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Calculăm câte probleme poate rezolva fiecare student în 300 de minute și penalizarea corespunzătoare:</li>\n        <ul>\n            <li><strong>Anul 5:</strong> Problemele în ordine naturală.</li>\n            <li><strong>Anul 3:</strong> Problemele în ordine inversă.</li>\n            <li><strong>Anul 1:</strong> Problemele sortate crescător după timp.</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Comparăm numărul de probleme rezolvate:</li>\n        <ul>\n            <li>Dacă un student rezolvă mai multe probleme, el câștigă.</li>\n            <li>Dacă există egalitate, comparăm penalizarea totală.</li>\n            <li>Dacă și penalizarea este egală, câștigă studentul mai tânăr.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm numele câștigătorului.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n log n)</code>, datorită sortării pentru studentul din anul 1.</p>\n</div>"
    },
    {
        "problemId": 16,
        "problemName": "A+B",
        "problemComplexity": "FOARTE_USOR",
        "problemTheme": "INCEPATORI",
        "problemContent": "Se dau două numere întregi <code>A</code> și <code>B</code>. Este necesar să calculați suma lor.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Două numere întregi: <code>A</code> și <code>B</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un singur număr întreg - suma <code>A + B</code>.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Nu există constrângeri speciale; este o simplă adunare a două numere întregi.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>A = 2</code></li>\n        <li><code>B = 3</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li><code>Suma = A + B = 2 + 3 = 5</code></li>\n    </ul>\n    <p><strong>Output:</strong> <code>5</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Citim valorile <code>A</code> și <code>B</code>.</li>\n        <li><strong>Pas 2:</strong> Calculăm suma:</li>\n        <ul>\n            <li><code>Suma = A + B</code></li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm rezultatul.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(1)</code>, deoarece este o singură operație de adunare.</p>\n</div>"
    },
    {
        "problemId": 17,
        "problemName": "Hochei",
        "problemComplexity": "USOR",
        "problemTheme": "COMBINATORICA",
        "problemContent": "La o competiție de hochei participă <code>N</code> echipe. Câte moduri există de a distribui seturile de medalii de aur, argint și bronz, astfel încât o echipă să ocupe un singur loc pe podium?",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>N</code>, reprezentând numărul de echipe participante.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un singur număr întreg - numărul total de moduri în care se pot distribui medaliile.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Podiumul are trei locuri: aur, argint și bronz.</li>\n        <li>O echipă poate ocupa un singur loc pe podium.</li>\n        <li>Numărul total de distribuții este dat de formula:</li>\n        <li>\n            <code>Rezultat = N * (N - 1) * (N - 2)</code>\n        </li>\n        <li>Explicație:</li>\n        <ul>\n            <li>Aurul poate fi câștigat de oricare dintre cele <code>N</code> echipe.</li>\n            <li>Argintul poate fi câștigat de oricare dintre cele <code>N - 1</code> echipe rămase.</li>\n            <li>Bronzul poate fi câștigat de oricare dintre cele <code>N - 2</code> echipe rămase.</li>\n        </ul>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>N = 5</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>\n            <code>Rezultat = 5 * 4 * 3 = 60</code>\n        </li>\n    </ul>\n    <p><strong>Output:</strong> <code>60</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Citim valoarea <code>N</code>.</li>\n        <li><strong>Pas 2:</strong> Verificăm dacă <code>N &gt;= 3</code> (altfel, nu este posibil să formăm un podium complet).</li>\n        <li><strong>Pas 3:</strong> Calculăm numărul total de moduri folosind formula:</li>\n        <ul>\n            <li><code>Rezultat = N * (N - 1) * (N - 2)</code></li>\n        </ul>\n        <li><strong>Pas 4:</strong> Returnăm rezultatul.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(1)</code>, deoarece este un calcul direct bazat pe formula combinatorică.</p>\n</div>"
    },
    {
        "problemId": 18,
        "problemName": "Numărul de Triunghiuri",
        "problemComplexity": "GREU",
        "problemTheme": "COMBINATORICA",
        "problemContent": "Se dă o figură compusă dintr-un triunghi echilateral mare format din triunghiuri echilaterale mai mici, organizate în <code>n</code> niveluri. Trebuie să determinați câte triunghiuri în total (de toate dimensiunile) există în această figură. Toate triunghiurile – de la cele mai mici până la cel mai mare – sunt luate în considerare.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>n</code>, reprezentând numărul de niveluri ale triunghiurilor mici.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - numărul total de triunghiuri din figură.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Un triunghi mare de nivel <code>n</code> conține:</li>\n        <ul>\n            <li><strong>Triunghiuri mici:</strong> Fiecare nivel <code>k</code> conține <code>k^2</code> triunghiuri mici.</li>\n            <li><strong>Triunghiuri mai mari:</strong> Acestea sunt compuse din mai multe triunghiuri mici și se pot forma la fiecare nivel.</li>\n        </ul>\n        <li>Numărul total de triunghiuri se calculează astfel:</li>\n        <ul>\n            <li><code>Total = Sum_{k=1}^{n} (k^2) + Sum_{k=1}^{n-1} (triunghiuri din nivelurile mai mari)</code>.</li>\n        </ul>\n    </ul>\n    <h4>Formulă Generală:</h4>\n    <p>Numărul total de triunghiuri este:</p>\n    <ul>\n        <li><code>Total = n * (n + 1) * (2n + 1) / 6</code> (pentru triunghiuri mici).</li>\n        <li>Adăugăm triunghiurile mai mari formate pe fiecare nivel:</li>\n        <li><code>Total += (n-1)*n/2</code>.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 4</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li><strong>Triunghiuri mici:</strong> <code>1^2 + 2^2 + 3^2 + 4^2 = 1 + 4 + 9 + 16 = 30</code>.</li>\n        <li><strong>Triunghiuri mai mari:</strong> Formate din mai multe niveluri:</li>\n        <ul>\n            <li><code>(4-1)*4/2 = 6</code>.</li>\n        </ul>\n        <li><code>Total = 30 + 6 = 36</code>.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>36</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Calculăm numărul de triunghiuri mici folosind formula:</li>\n        <ul>\n            <li><code>small = n * (n + 1) * (2n + 1) / 6</code>.</li>\n        </ul>\n        <li><strong>Pas 2:</strong> Calculăm numărul de triunghiuri mai mari folosind:</li>\n        <ul>\n            <li><code>large = (n-1) * n / 2</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Adunăm cele două rezultate:</li>\n        <ul>\n            <li><code>Total = small + large</code>.</li>\n        </ul>\n        <li><strong>Pas 4:</strong> Returnăm rezultatul.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(1)</code>, deoarece formulele sunt calculate direct.</p>\n</div>"
    },
    {
        "problemId": 19,
        "problemName": "Scară",
        "problemComplexity": "USOR",
        "problemTheme": "MODELARE",
        "problemContent": "Petrică construiește o scară din cuburi. Scara constă din mai multe turnulețe așezate unul lângă altul, fiecare având exact un cub mai mult decât cel precedent. Trebuie să determinați, folosind numărul total de cuburi pe care îl are Petrică, care va fi înălțimea (în cuburi) a ultimei trepte construite.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>n</code>, reprezentând numărul total de cuburi pe care îl are Petrică.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - înălțimea ultimei trepte a scării construite.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Fiecare treaptă a scării are nevoie de un număr de cuburi egal cu înălțimea sa:</li>\n        <ul>\n            <li>Treapta 1 necesită 1 cub.</li>\n            <li>Treapta 2 necesită 2 cuburi.</li>\n            <li>Treapta 3 necesită 3 cuburi, și așa mai departe.</li>\n        </ul>\n        <li>Numărul total de cuburi necesar pentru a construi primele <code>h</code> trepte este:</li>\n        <li>\n            <code>S = 1 + 2 + 3 + ... + h = h * (h + 1) / 2</code>\n        </li>\n        <li>Dacă <code>S ≤ n</code>, atunci treptele pot fi construite. Dacă nu, înălțimea maximă este <code>h - 1</code>.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Calculăm suma <code>S</code> pentru fiecare înălțime posibilă, până când <code>S</code> depășește <code>n</code>.</li>\n        <li>Returnăm ultima înălțime posibilă <code>h</code> care respectă <code>S ≤ n</code>.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 10</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Treapta 1: <code>S = 1</code>, cuburi rămase = 9.</li>\n        <li>Treapta 2: <code>S = 1 + 2 = 3</code>, cuburi rămase = 7.</li>\n        <li>Treapta 3: <code>S = 1 + 2 + 3 = 6</code>, cuburi rămase = 4.</li>\n        <li>Treapta 4: <code>S = 1 + 2 + 3 + 4 = 10</code>, cuburi rămase = 0.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>4</code> (ultima treaptă are înălțimea 4).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm suma <code>S = 0</code> și înălțimea <code>h = 0</code>.</li>\n        <li><strong>Pas 2:</strong> Iterăm cât timp <code>S + (h + 1) ≤ n</code>:</li>\n        <ul>\n            <li>Incrementăm <code>h</code>.</li>\n            <li>Adăugăm <code>h</code> la <code>S</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm <code>h</code>.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(sqrt(n))</code>, deoarece suma <code>h * (h + 1) / 2</code> crește cu pătratul lui <code>h</code>.</p>\n</div>"
    },
    {
        "problemId": 20,
        "problemName": "Experimentul",
        "problemComplexity": "MEDIU",
        "problemTheme": "MODELARE",
        "problemContent": "Într-un laborator secret, oamenii de știință realizează experimente cu gaze speciale numite gaze Ackerman. La începutul experimentului, există <code>n</code> eprubete numerotate, fiecare conținând un gaz diferit. Eprubetele pot fi conectate cu tuburi, iar gazele din ele intră în contact. Dacă două gaze intră în contact, gazul din eprubeta cu numărul mai mare distruge gazul din eprubeta cu numărul mai mic și ocupă întreg spațiul. Pentru o secvență de conexiuni între eprubete, trebuie să preziceți rezultatul final al experimentului.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Numărul de eprubete: <code>n</code>.</li>\n        <li>Lista conexiunilor între eprubete: <code>connections</code>, unde fiecare conexiune este de forma <code>(a, b)</code>, indicând că gazele din eprubetele <code>a</code> și <code>b</code> intră în contact.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>O listă care arată gazul final din fiecare eprubetă, după ce toate conexiunile sunt aplicate.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Folosim un algoritm de tip \"union-find\" pentru a modela distrugerea gazelor și expansiunea lor.</li>\n        <li>Inițial, fiecare eprubetă conține gazul său unic.</li>\n        <li>La fiecare conexiune <code>(a, b)</code>:</li>\n        <ul>\n            <li>Determinăm care dintre <code>a</code> și <code>b</code> are numărul mai mare.</li>\n            <li>Gazul din eprubeta cu numărul mai mare \"cucerește\" eprubeta cu numărul mai mic.</li>\n        </ul>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Inițializăm un vector <code>parent</code>, unde <code>parent[i]</code> indică gazul final din eprubeta <code>i</code>.</li>\n        <li>Pentru fiecare conexiune <code>(a, b)</code>:</li>\n        <ul>\n            <li>Determinăm reprezentantul (gazul curent) pentru <code>a</code> și <code>b</code> folosind funcția \"find\".</li>\n            <li>Actualizăm reprezentantul eprubetei cu numărul mai mic astfel încât să fie cel al eprubetei cu numărul mai mare.</li>\n        </ul>\n        <li>Returnăm vectorul final de reprezentanți, indicând gazul din fiecare eprubetă.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 5</code></li>\n        <li><code>connections = [(1, 2), (3, 4), (2, 3), (4, 5)]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Inițial: <code>parent = [1, 2, 3, 4, 5]</code></li>\n        <li>Conexiune (1, 2): Gazul din 2 distruge gazul din 1 → <code>parent = [2, 2, 3, 4, 5]</code>.</li>\n        <li>Conexiune (3, 4): Gazul din 4 distruge gazul din 3 → <code>parent = [2, 2, 4, 4, 5]</code>.</li>\n        <li>Conexiune (2, 3): Gazul din 4 distruge gazul din 2 → <code>parent = [4, 4, 4, 4, 5]</code>.</li>\n        <li>Conexiune (4, 5): Gazul din 5 distruge gazul din 4 → <code>parent = [5, 5, 5, 5, 5]</code>.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>[5, 5, 5, 5, 5]</code> (toate eprubetele conțin gazul din eprubeta 5).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm un vector <code>parent</code> astfel încât fiecare eprubetă să fie propriul său reprezentant.</li>\n        <li><strong>Pas 2:</strong> Implementăm funcția \"find\" pentru a determina reprezentantul unui gaz:</li>\n        <ul>\n            <li>Dacă <code>parent[x] != x</code>, actualizăm <code>parent[x]</code> recursiv.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Pentru fiecare conexiune <code>(a, b)</code>, aplicăm funcția \"union\" pentru a actualiza reprezentanții:</li>\n        <ul>\n            <li>Dacă <code>a &lt; b</code>, facem gazul din <code>b</code> reprezentant pentru <code>a</code>.</li>\n            <li>Altminteri, gazul din <code>a</code> devine reprezentant pentru <code>b</code>.</li>\n        </ul>\n        <li><strong>Pas 4:</strong> Returnăm vectorul final de reprezentanți.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(m log n)</code>, unde <code>m</code> este numărul de conexiuni, iar <code>n</code> este numărul de eprubete (folosind optimizarea \"path compression\").</p>\n</div>"
    },
    {
        "problemId": 21,
        "problemName": "Numere de autobuz",
        "problemComplexity": "USOR",
        "problemTheme": "STRING",
        "problemContent": "Vasya, în timp ce aștepta autobuzul său, a început să noteze pe o foaie numerele de înmatriculare ale altor autobuze care treceau pe lângă el. El a reținut doar numerele principale, fără a lua în considerare apartenența regională. Numerele principale sunt formate din 6 caractere: trei litere și trei cifre, într-un format specific: prima este o literă, urmate de trei cifre, și apoi alte două litere. Literele valide sunt: <code>A, B, C, E, H, K, M, O, P, T, X, Y</code>. Numerele corecte trebuie să respecte această structură. De exemplu, <code>P204BT</code> este un număr valid, dar <code>X182YZ</code> și <code>ABC216</code> nu sunt valide. Scrieți un program care verifică dacă numerele notate de Vasya respectă standardul sau nu.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>N</code>, reprezentând numărul de numere notate de Vasya.</li>\n        <li>O listă de <code>N</code> numere, fiecare format din 6 caractere.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Pentru fiecare număr, afișați <code>DA</code> dacă este valid și <code>NU</code> dacă nu este valid.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Structura unui număr valid este:</li>\n        <ul>\n            <li>Prima literă este una dintre <code>A, B, C, E, H, K, M, O, P, T, X, Y</code>.</li>\n            <li>Urmează trei cifre de la 0 la 9.</li>\n            <li>Ultimele două litere sunt dintre <code>A, B, C, E, H, K, M, O, P, T, X, Y</code>.</li>\n        </ul>\n        <li>Numerele care nu respectă această structură sunt considerate invalide.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Definim un set de litere valide: <code>VALID_LETTERS = {'A', 'B', 'C', 'E', 'H', 'K', 'M', 'O', 'P', 'T', 'X', 'Y'}</code>.</li>\n        <li>Iterăm prin lista de numere.</li>\n        <li>Pentru fiecare număr:</li>\n        <ul>\n            <li>Verificăm dacă lungimea este 6.</li>\n            <li>Verificăm dacă primul caracter și ultimele două caractere sunt litere valide.</li>\n            <li>Verificăm dacă caracterele 2, 3 și 4 sunt cifre.</li>\n        </ul>\n        <li>Dacă toate condițiile sunt respectate, marcăm numărul ca <code>DA</code>, altfel <code>NU</code>.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>N = 3</code></li>\n        <li><code>numere = ['P204BT', 'X182YZ', 'ABC216']</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li><code>'P204BT'</code> este valid: prima literă <code>'P'</code>, trei cifre <code>'204'</code>, ultimele două litere <code>'BT'</code> - <code>DA</code>.</li>\n        <li><code>'X182YZ'</code> nu este valid: ultimele două litere <code>'YZ'</code> nu sunt în lista validă - <code>NU</code>.</li>\n        <li><code>'ABC216'</code> nu este valid: nu respectă formatul <code>literă-cifre-două litere</code> - <code>NU</code>.</li>\n    </ul>\n    <p><strong>Output:</strong></p>\n    <ul>\n        <li><code>DA</code></li>\n        <li><code>NU</code></li>\n        <li><code>NU</code></li>\n    </ul>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Citim <code>N</code> și lista de numere.</li>\n        <li><strong>Pas 2:</strong> Pentru fiecare număr:</li>\n        <ul>\n            <li>Verificăm condițiile:</li>\n            <ul>\n                <li>Lungimea este 6.</li>\n                <li>Primul caracter și ultimele două sunt litere valide.</li>\n                <li>Caracterele 2, 3, 4 sunt cifre.</li>\n            </ul>\n            <li>Dacă toate sunt adevărate, returnăm <code>DA</code>, altfel <code>NU</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm lista răspunsurilor.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(N)</code>, unde <code>N</code> este numărul de numere, deoarece verificăm fiecare număr o singură dată.</p>\n</div>"
    },
    {
        "problemId": 22,
        "problemName": "Cadouri de la Moș Crăciun",
        "problemComplexity": "MEDIU",
        "problemTheme": "RECURSIE",
        "problemContent": "Moș Crăciun pregătește cadouri pentru copii. Există trei tipuri de articole pe care le poate pune în cadouri: \n<ul>\n<li>O caramea care cântărește <code>X</code> grame.</li>\n<li>O mandarină care cântărește <code>Y</code> grame.</li>\n<li>Un turta dulce care cântărește <code>Z</code> grame.</li>\n</ul>\nScopul este să determinați câte combinații diferite de articole pot forma un cadou cu greutatea exactă de <code>W</code> grame.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Greutățile: <code>X</code>, <code>Y</code>, <code>Z</code> (greutatea în grame a unei caramele, unei mandarine și unei turte dulci).</li>\n        <li>Greutatea totală <code>W</code>, pe care trebuie să o atingă cadoul.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - numărul total de combinații posibile de articole care au exact greutatea <code>W</code>.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Putem folosi oricâte articole din fiecare tip.</li>\n        <li>Numărătoarea combinațiilor diferite trebuie să fie completă.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Folosim o funcție recursivă pentru a încerca toate combinațiile posibile:</li>\n        <ul>\n            <li><code>solve(W)</code>: determină câte combinații pot forma greutatea <code>W</code>.</li>\n        </ul>\n        <li>În funcția recursivă:</li>\n        <ul>\n            <li>Dacă <code>W == 0</code>, returnăm <code>1</code> (o combinație validă).</li>\n            <li>Dacă <code>W &lt; 0</code>, returnăm <code>0</code> (combinația nu este validă).</li>\n            <li>Altfel, încercăm să adăugăm fiecare articol (<code>X</code>, <code>Y</code>, <code>Z</code>) și continuăm recursiv.</li>\n        </ul>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>X = 2</code>, <code>Y = 3</code>, <code>Z = 5</code>, <code>W = 10</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Încercăm toate combinațiile:</li>\n        <li>Folosești 5 caramele: <code>5 * 2 = 10</code> (valid).</li>\n        <li>Folosești 1 mandarină și 2 turte dulci: <code>3 + 5 + 5 = 10</code> (valid).</li>\n        <li>Rezultatul final este <code>2</code> combinații valide.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>2</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Scriem funcția recursivă <code>solve(W)</code>.</li>\n        <li><strong>Pas 2:</strong> În funcție:</li>\n        <ul>\n            <li>Returnăm <code>1</code> dacă <code>W == 0</code>.</li>\n            <li>Returnăm <code>0</code> dacă <code>W &lt; 0</code>.</li>\n            <li>Altfel, apelăm recursiv funcția pentru <code>W - X</code>, <code>W - Y</code> și <code>W - Z</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Suma apelurilor recursiei este răspunsul final.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(W)</code> cu memorare, deoarece fiecare valoare a lui <code>W</code> este calculată o singură dată.</p>\n</div>"
    },
    {
        "problemId": 23,
        "problemName": "Numere frumoase",
        "problemComplexity": "GREU",
        "problemTheme": "RECURSIE",
        "problemContent": "Multe companii folosesc „numere frumoase” de telefon pentru a atrage clienți. Dacă numărul companiei tale nu este memorabil, poate fi reorganizat astfel încât să devină mai atractiv. Numărul poate fi împărțit în grupuri de dimensiuni între 2 și 4 cifre, separate de cratime. Fiecare grup primește un punctaj în funcție de un tabel predefinit al modelelor de cifre. Sarcina este să găsiți cea mai frumoasă împărțire a unui număr dat pentru a obține cel mai mare punctaj posibil.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un șir <code>num</code>, reprezentând numărul de telefon (o secvență de cifre).</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - punctajul maxim al celui mai frumos mod de a împărți numărul.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Fiecare grup trebuie să aibă dimensiunea între 2 și 4 cifre.</li>\n        <li>Punctajul fiecărui grup se calculează pe baza unui tabel de modele:</li>\n        <ul>\n            <li><code>aa</code>: 2 puncte (ex: 11, 22).</li>\n            <li><code>aaa</code>: 5 puncte (ex: 111, 222).</li>\n            <li><code>aab</code>: 3 puncte (ex: 112, 223).</li>\n            <li><code>abba</code>: 6 puncte (ex: 1221, 3443).</li>\n            <li>Orice altă combinație: 0 puncte.</li>\n        </ul>\n        <li>Trebuie să găsiți împărțirea care maximizează suma punctelor.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Folosim o funcție recursivă cu memorare (dynamic programming) pentru a explora toate împărțirile posibile:</li>\n        <ul>\n            <li><code>solve(index)</code>: determină punctajul maxim începând de la poziția <code>index</code> în număr.</li>\n        </ul>\n        <li>Pentru fiecare poziție <code>index</code>:</li>\n        <ul>\n            <li>Luăm segmente de lungime 2, 3 și 4.</li>\n            <li>Calculăm punctajul segmentului folosind tabela de modele.</li>\n            <li>Adăugăm punctajul segmentului la rezultatul recursiv pentru segmentul următor.</li>\n        </ul>\n        <li>Reținem cel mai mare punctaj obținut pentru fiecare poziție.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>num = '8727333'</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Împărțiri posibile:</li>\n        <ul>\n            <li><code>8727-333</code>: <code>'8727'</code> (0 puncte), <code>'333'</code> (5 puncte) → Total = 5.</li>\n            <li><code>872-7333</code>: <code>'872'</code> (0 puncte), <code>'7333'</code> (5 puncte) → Total = 5.</li>\n        </ul>\n        <li>Punctaj maxim: <code>5</code>.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>5</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Scriem funcția recursivă <code>solve(index)</code>.</li>\n        <li><strong>Pas 2:</strong> Pentru fiecare poziție:</li>\n        <ul>\n            <li>Luăm segmente de lungime 2, 3 și 4.</li>\n            <li>Calculăm punctajul segmentului și adăugăm rezultatul recursiv.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Reținem rezultatul pentru a evita recalculările.</li>\n        <li><strong>Pas 4:</strong> Returnăm rezultatul maxim.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n)</code>, unde <code>n</code> este lungimea numărului, datorită utilizării memorării.</p>\n</div>"
    },
    {
        "problemId": 24,
        "problemName": "Trenul Rapid",
        "problemComplexity": "MEDIU",
        "problemTheme": "SORTARE",
        "problemContent": "Între două dintre cele mai mari orașe din România, București și Cluj-Napoca, circulă zilnic <code>n</code> trenuri. Pentru fiecare tren sunt cunoscute ora de plecare din București și ora de sosire în Cluj-Napoca. Lungimea căii ferate între București și Cluj-Napoca este de 650 km. Sarcina este să determinați care este cel mai rapid tren și viteza sa medie.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>n</code>, reprezentând numărul de trenuri.</li>\n        <li>O listă de <code>n</code> trenuri, fiecare având:</li>\n        <ul>\n            <li><code>ora_plecare</code>: ora de plecare din București (format HH:MM).</li>\n            <li><code>ora_sosire</code>: ora de sosire în Cluj-Napoca (format HH:MM).</li>\n        </ul>\n    </ul>\n    <h4>Output:</h4>\n    <p>Identitatea trenului cel mai rapid (indicele său) și viteza sa medie (în km/h).</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Viteza medie a unui tren este calculată astfel:</li>\n        <ul>\n            <li><code>viteza = 650 / timpul_total</code>, unde <code>timpul_total</code> este timpul de deplasare al trenului în ore.</li>\n        </ul>\n        <li>Timpul dintre două ore este calculat astfel:</li>\n        <ul>\n            <li><code>timp = ora_sosire - ora_plecare</code>, convertit în ore.</li>\n        </ul>\n        <li>Dacă două trenuri au aceeași viteză, primul apărut în listă este considerat cel mai rapid.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Parcurgem lista de trenuri și pentru fiecare tren:</li>\n        <ul>\n            <li>Convertim ora de plecare și ora de sosire în minute totale.</li>\n            <li>Calculăm durata călătoriei în ore.</li>\n            <li>Calculăm viteza medie.</li>\n        </ul>\n        <li>Reținem trenul cu cea mai mare viteză medie.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 3</code></li>\n        <li><code>trenuri = [('08:00', '12:00'), ('06:30', '10:00'), ('09:00', '13:30')]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Tren 1: Durata = 4 ore → Viteza = 650 / 4 = 162.5 km/h.</li>\n        <li>Tren 2: Durata = 3.5 ore → Viteza = 650 / 3.5 = 185.7 km/h.</li>\n        <li>Tren 3: Durata = 4.5 ore → Viteza = 650 / 4.5 = 144.4 km/h.</li>\n    </ul>\n    <p><strong>Output:</strong> Trenul 2 (viteza 185.7 km/h).</p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm variabile pentru cel mai rapid tren și viteza sa maximă.</li>\n        <li><strong>Pas 2:</strong> Pentru fiecare tren:</li>\n        <ul>\n            <li>Convertim ora de plecare și sosire în minute totale (de la miezul nopții).</li>\n            <li>Calculăm durata călătoriei în ore.</li>\n            <li>Calculăm viteza medie.</li>\n            <li>Actualizăm trenul cel mai rapid dacă viteza curentă este mai mare decât viteza maximă reținută.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Returnăm indicele trenului cel mai rapid și viteza sa medie.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n)</code>, deoarece parcurgem lista o singură dată.</p>\n</div>"
    },
    {
        "problemId": 25,
        "problemName": "Statistică",
        "problemComplexity": "MEDIU",
        "problemTheme": "SORTARE",
        "problemContent": "Vasya urăște engleza, dar se străduiește să obțină cel puțin nota 4 la sfârșitul trimestrului pentru a rămâne printre cei mai buni elevi. În acest trimestru, el a observat o regularitate: în zilele pare ale lunii primea nota 4, iar în zilele impare nota 3. Vasya a notat toate zilele în care a primit note și acum vrea să știe câte note de 3 și câte note de 4 a primit. Ajutați-l pe Vasya să determine acest lucru și să afișați zilele pare și impare în linii separate.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>n</code>, reprezentând numărul total de zile notate de Vasya.</li>\n        <li>O listă de <code>n</code> numere întregi, fiecare reprezentând o zi a lunii.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Două linii:</p>\n    <ul>\n        <li>Prima linie conține toate zilele pare (corespunzătoare notelor de 4), separate prin spațiu.</li>\n        <li>A doua linie conține toate zilele impare (corespunzătoare notelor de 3), separate prin spațiu.</li>\n        <li>La final, afișați mesajul <code>DA</code> dacă numărul de note de 4 este mai mare sau egal cu cel de 3, altfel <code>NU</code>.</li>\n    </ul>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Zilele pare reprezintă notele de 4.</li>\n        <li>Zilele impare reprezintă notele de 3.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Inițializăm două liste goale: una pentru zilele pare și alta pentru zilele impare.</li>\n        <li>Iterăm prin lista de zile și pentru fiecare zi:</li>\n        <ul>\n            <li>Dacă ziua este pară, o adăugăm în lista zilelor pare.</li>\n            <li>Dacă ziua este impară, o adăugăm în lista zilelor impare.</li>\n        </ul>\n        <li>Calculăm lungimile celor două liste.</li>\n        <li>Comparăm lungimea listei de zile pare cu cea a listei de zile impare:</li>\n        <ul>\n            <li>Dacă numărul de zile pare este mai mare sau egal cu cel de zile impare, afișăm <code>DA</code>.</li>\n            <li>În caz contrar, afișăm <code>NU</code>.</li>\n        </ul>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 7</code></li>\n        <li><code>zile = [1, 2, 3, 4, 5, 6, 7]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Zile pare: <code>[2, 4, 6]</code></li>\n        <li>Zile impare: <code>[1, 3, 5, 7]</code></li>\n        <li>Număr de zile pare: <code>3</code>.</li>\n        <li>Număr de zile impare: <code>4</code>.</li>\n    </ul>\n    <p><strong>Output:</strong></p>\n    <ul>\n        <li><code>2 4 6</code></li>\n        <li><code>1 3 5 7</code></li>\n        <li><code>NU</code></li>\n    </ul>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm două liste goale: <code>pare</code> și <code>impare</code>.</li>\n        <li><strong>Pas 2:</strong> Iterăm prin lista de zile și sortăm valorile în cele două liste.</li>\n        <li><strong>Pas 3:</strong> Calculăm lungimile listelor <code>pare</code> și <code>impare</code>.</li>\n        <li><strong>Pas 4:</strong> Afișăm cele două liste și verificăm condiția finală (<code>DA</code> sau <code>NU</code>).</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n)</code>, unde <code>n</code> este numărul de zile.</p>\n</div>"
    },
    {
        "problemId": 26,
        "problemName": "Sumă sau Produs",
        "problemComplexity": "FOARTE_GREA",
        "problemTheme": "STRUCTURI_DE_DATE",
        "problemContent": "Ghiță a început recent să învețe matematică. A învățat să adune și să înmulțească și a fost uimit să descopere că <code>2 + 2 = 2 x 2</code>. Acum vrea să găsească mai multe exemple de astfel de relații. Ghiță numește un set de numere <em>interesant</em> dacă produsul numerelor din acel set este egal cu suma lor. De exemplu, seturile <code>{2, 2}</code>, <code>{5}</code>, <code>{1, 2, 3}</code> sunt interesante, dar setul <code>{2, 3}</code> nu este. Pentru un număr dat <code>N</code>, Ghiță dorește să găsească numărul de seturi interesante care conțin exact <code>N</code> numere. Ajutați-l să rezolve problema!",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>N</code>, reprezentând numărul de elemente dintr-un set.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - numărul total de seturi interesante care conțin exact <code>N</code> numere.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Un set este interesant dacă:</li>\n        <ul>\n            <li><code>sum(set) = product(set)</code>.</li>\n        </ul>\n        <li>Seturile trebuie să aibă exact <code>N</code> elemente.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Reprezentăm numerele setului printr-un vector <code>[a1, a2, ..., aN]</code>.</li>\n        <li>Folosim o funcție recursivă pentru a genera toate combinațiile de <code>N</code> numere întregi (pozitive).</li>\n        <li>Pentru fiecare combinație, verificăm dacă produsul și suma elementelor sunt egale:</li>\n        <ul>\n            <li>Calculăm <code>product = a1 * a2 * ... * aN</code>.</li>\n            <li>Calculăm <code>sum = a1 + a2 + ... + aN</code>.</li>\n            <li>Dacă <code>sum == product</code>, incrementăm un contor.</li>\n        </ul>\n        <li>Returnăm numărul total de seturi interesante.</li>\n    </ol>\n    <h4>Optimizare:</h4>\n    <ul>\n        <li>Observăm că numerele mici (de exemplu, 1, 2, 3) generează cele mai multe seturi interesante, deoarece cresc lent produsul față de sumă.</li>\n        <li>Putem limita valoarea maximă a elementelor setului, deoarece valori mari vor face ca produsul să depășească suma.</li>\n    </ul>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>N = 2</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Seturi posibile:</li>\n        <ul>\n            <li><code>{2, 2}</code>: <code>sum = 2 + 2 = 4</code>, <code>product = 2 * 2 = 4</code> (interesant).</li>\n            <li><code>{1, 3}</code>: <code>sum = 1 + 3 = 4</code>, <code>product = 1 * 3 = 3</code> (neinteresant).</li>\n        </ul>\n        <li>Total: <code>1</code> set interesant.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>1</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm o funcție recursivă <code>find_sets(index, current_set, current_sum, current_product)</code>.</li>\n        <li><strong>Pas 2:</strong> Pentru fiecare element posibil al setului:</li>\n        <ul>\n            <li>Adăugăm elementul la set.</li>\n            <li>Actualizăm suma și produsul curent.</li>\n            <li>Continuăm recursiv pentru următoarea poziție.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> La finalul recursiei, verificăm dacă <code>current_sum == current_product</code>.</li>\n        <li><strong>Pas 4:</strong> Returnăm totalul seturilor valide.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(K^N)</code>, unde <code>K</code> este limita maximă a valorilor setului și <code>N</code> este numărul de elemente. Optimizările reduc <code>K</code> pentru a limita numărul total de combinații.</p>\n</div>"
    },
    {
        "problemId": 27,
        "problemName": "Raftul",
        "problemComplexity": "MEDIU",
        "problemTheme": "STRUCTURI_DE_DATE",
        "problemContent": "Andrei are un frate mai mic, Ionel, care adoră să urmărească desene animate. Totuși, Ionel avea obiceiul de a împrăștia și pierde DVD-urile sale prin casă. Pentru ziua lui de naștere, Andrei i-a făcut cadou un raft lung, astfel încât Ionel să își poată organiza DVD-urile. Pentru a menține ordinea pe raft, Andrei i-a explicat lui Ionel câteva reguli simple:\n<ul>\n<li>Dacă raftul este gol, Ionel pune DVD-ul pe el.</li>\n<li>Dacă există deja DVD-uri, Ionel pune DVD-ul fie în partea stângă, fie în partea dreaptă.</li>\n<li>Atunci când ia un DVD, o face doar de la marginea stângă sau dreaptă.</li>\n</ul>\nAcum, Andrei vrea să știe dacă Ionel a respectat regulile atunci când a utilizat raftul.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>n</code>, reprezentând numărul de operații efectuate de Ionel.</li>\n        <li>O listă de <code>n</code> operații, fiecare fiind de una dintre următoarele forme:</li>\n        <ul>\n            <li><code>ADD_LEFT x</code> – pune DVD-ul <code>x</code> în partea stângă a raftului.</li>\n            <li><code>ADD_RIGHT x</code> – pune DVD-ul <code>x</code> în partea dreaptă a raftului.</li>\n            <li><code>REMOVE_LEFT</code> – ia DVD-ul din partea stângă a raftului.</li>\n            <li><code>REMOVE_RIGHT</code> – ia DVD-ul din partea dreaptă a raftului.</li>\n        </ul>\n    </ul>\n    <h4>Output:</h4>\n    <p>Afișați <code>DA</code> dacă toate operațiile sunt valide conform regulilor, altfel <code>NU</code>.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Operațiile de <code>REMOVE_LEFT</code> și <code>REMOVE_RIGHT</code> sunt valide doar dacă raftul nu este gol și există un DVD pe partea respectivă.</li>\n        <li>Fiecare DVD are un identificator unic.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Folosim o structură de date de tip deque pentru a simula raftul.</li>\n        <li>Iterăm prin lista de operații:</li>\n        <ul>\n            <li>Adăugăm DVD-ul fie la stânga, fie la dreapta, în funcție de operație.</li>\n            <li>Înlăturăm DVD-ul de la stânga sau dreapta doar dacă raftul nu este gol.</li>\n        </ul>\n        <li>Dacă întâlnim o operație invalidă (de exemplu, scoaterea unui DVD de pe un raft gol), returnăm <code>NU</code>.</li>\n        <li>Dacă toate operațiile sunt valide, returnăm <code>DA</code>.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 5</code></li>\n        <li><code>operații = ['ADD_LEFT 1', 'ADD_RIGHT 2', 'REMOVE_LEFT', 'REMOVE_RIGHT', 'REMOVE_LEFT']</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Operația 1: Adăugăm <code>1</code> la stânga → raftul = <code>[1]</code>.</li>\n        <li>Operația 2: Adăugăm <code>2</code> la dreapta → raftul = <code>[1, 2]</code>.</li>\n        <li>Operația 3: Scoatem <code>1</code> de la stânga → raftul = <code>[2]</code>.</li>\n        <li>Operația 4: Scoatem <code>2</code> de la dreapta → raftul = <code>[]</code>.</li>\n        <li>Operația 5: Încercăm să scoatem de la stânga, dar raftul este gol → Invalid.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>NU</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm un deque gol pentru raft.</li>\n        <li><strong>Pas 2:</strong> Iterăm prin lista de operații:</li>\n        <ul>\n            <li>Adăugăm DVD-ul la stânga sau dreapta, conform instrucțiunii.</li>\n            <li>Scoatem DVD-ul de la stânga sau dreapta doar dacă raftul nu este gol.</li>\n            <li>Dacă raftul este gol când trebuie să scoatem un DVD, returnăm <code>NU</code>.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Dacă toate operațiile sunt valide, returnăm <code>DA</code>.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n)</code>, unde <code>n</code> este numărul de operații.</p>\n</div>"
    },
    {
        "problemId": 28,
        "problemName": "Capitale",
        "problemComplexity": "STEVE_WOZNIAK",
        "problemTheme": "TEOREMA_GRAFELOR",
        "problemContent": "În țara Trilandia se apropie alegerile pentru noile capitale. Spre deosebire de alte țări, în Trilandia există trei capitale simultan. Această abordare este bazată pe cercetări privind eficiența guvernării realizate de economiștii de top ai Trilandiei.\n\nExistă <code>n</code> orașe în Trilandia, iar unele perechi de orașe sunt conectate prin drumuri bidirecționale. Fiecare drum poate fi parcurs în ambele direcții și timpul necesar pentru a călători pe un drum este de 1 oră. Toate orașele sunt conectate astfel încât să fie posibil să se ajungă din orice oraș în oricare altul, folosind un singur drum o singură dată.\n\nPentru ca guvernarea să fie eficientă, cele trei capitale trebuie să fie alese astfel încât distanța pe drumul cel mai scurt între fiecare pereche de capitale să fie exact <code>d</code> ore. Sarcina este să găsiți numărul total de combinații de câte trei orașe care pot fi alese ca și capitale, respectând aceste reguli.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>n</code>, reprezentând numărul de orașe din Trilandia.</li>\n        <li>Un număr întreg <code>m</code>, reprezentând numărul de drumuri.</li>\n        <li>O listă de <code>m</code> perechi <code>(a, b)</code>, fiecare reprezentând un drum între orașele <code>a</code> și <code>b</code>.</li>\n        <li>Un număr întreg <code>d</code>, reprezentând distanța exactă în ore între capitale.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - numărul total de combinații de câte trei orașe care pot fi alese ca și capitale.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Rețeaua de drumuri este unică și fără cicluri (un arbore).</li>\n        <li>Folosim algoritmul lui Floyd-Warshall sau BFS pentru a calcula distanțele între toate perechile de orașe.</li>\n        <li>Verificăm toate combinațiile de câte trei orașe pentru a determina dacă distanțele între ele sunt toate egale cu <code>d</code>.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Reprezentăm rețeaua de orașe ca un graf utilizând liste de adiacență.</li>\n        <li>Calculăm distanțele dintre toate perechile de orașe folosind BFS:</li>\n        <ul>\n            <li>Pentru fiecare oraș, inițiem o parcurgere BFS și determinăm distanțele către toate celelalte orașe.</li>\n        </ul>\n        <li>Iterăm prin toate combinațiile de câte trei orașe și verificăm distanțele dintre ele.</li>\n        <li>Numărăm combinațiile valide.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>n = 5</code></li>\n        <li><code>m = 4</code></li>\n        <li><code>drumuri = [(1, 2), (2, 3), (3, 4), (4, 5)]</code></li>\n        <li><code>d = 2</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Distante între orașe:</li>\n        <ul>\n            <li><code>1 → 3 = 2</code>, <code>2 → 4 = 2</code>, etc.</li>\n        </ul>\n        <li>Combinațiile valide sunt:</li>\n        <ul>\n            <li><code>(1, 3, 5)</code> → toate distanțele sunt 2.</li>\n        </ul>\n        <li>Total: <code>1</code> combinație.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>1</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm un vector pentru distanțele între toate perechile de orașe.</li>\n        <li><strong>Pas 2:</strong> Calculăm distanțele folosind BFS din fiecare oraș.</li>\n        <li><strong>Pas 3:</strong> Verificăm toate combinațiile de câte trei orașe.</li>\n        <li><strong>Pas 4:</strong> Dacă toate distanțele sunt egale cu <code>d</code>, incrementăm contorul.</li>\n        <li><strong>Pas 5:</strong> Returnăm contorul final.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(n^3)</code> pentru verificarea tuturor combinațiilor și <code>O(n^2)</code> pentru calcularea distanțelor.</p>\n</div>"
    },
    {
        "problemId": 29,
        "problemName": "Căile",
        "problemComplexity": "USOR",
        "problemTheme": "TEOREMA_GRAFELOR",
        "problemContent": "În galaxia „Calea Lactee”, pe planeta „Fulgi de Zăpadă”, există <code>N</code> orașe, unele dintre ele fiind conectate prin drumuri. Împăratul galaxiei „Calea Lactee” a decis să facă o inventariere a drumurilor de pe planeta „Fulgi de Zăpadă”. Totuși, el nu este foarte priceput la matematică, așa că vă cere să numărați câte drumuri există pe această planetă. Scrieți un program care să determine numărul total de drumuri pe baza unei liste de conexiuni între orașe.",
        "problemSolution": "<div>\n    <h3>Soluție pas cu pas:</h3>\n    <h4>Input:</h4>\n    <ul>\n        <li>Un număr întreg <code>N</code>, reprezentând numărul total de orașe de pe planetă.</li>\n        <li>Un număr întreg <code>M</code>, reprezentând numărul total de drumuri între orașe.</li>\n        <li>O listă de <code>M</code> perechi <code>(a, b)</code>, fiecare reprezentând un drum între orașele <code>a</code> și <code>b</code>.</li>\n    </ul>\n    <h4>Output:</h4>\n    <p>Un număr întreg - numărul total de drumuri existente pe planetă.</p>\n    <h4>Detalii:</h4>\n    <ul>\n        <li>Fiecare drum este bidirecțional.</li>\n        <li>Lista de drumuri poate conține duplicate, iar aceste duplicate trebuie eliminate înainte de numărare.</li>\n    </ul>\n    <h4>Strategie:</h4>\n    <ol>\n        <li>Reprezentăm drumurile folosind o structură de date care elimină duplicatele (de exemplu, un set).</li>\n        <li>Adăugăm fiecare drum la set în ambele direcții (<code>(a, b)</code> și <code>(b, a)</code>).</li>\n        <li>Numărăm elementele din setul de drumuri și împărțim rezultatul la 2 pentru a elimina duplicarea perechilor.</li>\n    </ol>\n    <h4>Exemplu:</h4>\n    <p><strong>Input:</strong></p>\n    <ul>\n        <li><code>N = 4</code></li>\n        <li><code>M = 5</code></li>\n        <li><code>drumuri = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]</code></li>\n    </ul>\n    <p><strong>Calcul:</strong></p>\n    <ul>\n        <li>Adăugăm fiecare pereche la un set:</li>\n        <ul>\n            <li><code>{(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)}</code></li>\n        </ul>\n        <li>Numărăm perechile din set: <code>5</code>.</li>\n    </ul>\n    <p><strong>Output:</strong> <code>5</code></p>\n    <h4>Soluție algoritmică:</h4>\n    <ol>\n        <li><strong>Pas 1:</strong> Inițializăm un set gol pentru a stoca drumurile unice.</li>\n        <li><strong>Pas 2:</strong> Iterăm prin lista de drumuri și pentru fiecare pereche <code>(a, b)</code>:</li>\n        <ul>\n            <li>Adăugăm perechea <code>(a, b)</code> și <code>(b, a)</code> în set.</li>\n        </ul>\n        <li><strong>Pas 3:</strong> Numărăm perechile din set și împărțim rezultatul la 2.</li>\n        <li><strong>Pas 4:</strong> Returnăm rezultatul final.</li>\n    </ol>\n    <h4>Complexitate:</h4>\n    <p><code>O(M)</code>, unde <code>M</code> este numărul de drumuri. Inserarea și verificarea într-un set sunt operații constante, în medie.</p>\n</div>"
    }
]